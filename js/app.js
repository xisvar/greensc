!function() {
    "use strict";
    function t(t) {
        if (void 0 === t)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }
    function e(t, e) {
        t.prototype = Object.create(e.prototype),
        t.prototype.constructor = t,
        t.__proto__ = e
    }
    /*!
   * GSAP 3.12.5
   * https://gsap.com
   *
   * @license Copyright 2008-2024, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license or for
   * Club GSAP members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */
    var i, n, r, s, a, o, l, c, h, u, d, p, f, m, g, v, y, x = {
        autoSleep: 120,
        force3D: "auto",
        nullTargetWarn: 1,
        units: {
            lineHeight: ""
        }
    }, _ = {
        duration: .5,
        overwrite: !1,
        delay: 0
    }, w = 1e8, b = 1e-8, M = 2 * Math.PI, S = M / 4, T = 0, E = Math.sqrt, L = Math.cos, A = Math.sin, C = function(t) {
        return "string" == typeof t
    }, P = function(t) {
        return "function" == typeof t
    }, R = function(t) {
        return "number" == typeof t
    }, I = function(t) {
        return void 0 === t
    }, D = function(t) {
        return "object" == typeof t
    }, N = function(t) {
        return !1 !== t
    }, O = function() {
        return "undefined" != typeof window
    }, z = function(t) {
        return P(t) || C(t)
    }, k = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function() {}
    , B = Array.isArray, F = /(?:-?\.?\d|\.)+/gi, H = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, U = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, G = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, V = /[+-]=-?[.\d]+/, W = /[^,'"\[\]\s]+/gi, q = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, j = {}, Y = {}, X = function(t) {
        return (Y = St(t, j)) && Ti
    }, J = function(t, e) {
        return console.warn("Invalid property", t, "set to", e, "Missing plugin? gsap.registerPlugin()")
    }, Z = function(t, e) {
        return !e && console.warn(t)
    }, Q = function(t, e) {
        return t && (j[t] = e) && Y && (Y[t] = e) || j
    }, K = function() {
        return 0
    }, tt = {
        suppressEvents: !0,
        isStart: !0,
        kill: !1
    }, et = {
        suppressEvents: !0,
        kill: !1
    }, it = {
        suppressEvents: !0
    }, nt = {}, rt = [], st = {}, at = {}, ot = {}, lt = 30, ct = [], ht = "", ut = function(t) {
        var e, i, n = t[0];
        if (D(n) || P(n) || (t = [t]),
        !(e = (n._gsap || {}).harness)) {
            for (i = ct.length; i-- && !ct[i].targetTest(n); )
                ;
            e = ct[i]
        }
        for (i = t.length; i--; )
            t[i] && (t[i]._gsap || (t[i]._gsap = new Fe(t[i],e))) || t.splice(i, 1);
        return t
    }, dt = function(t) {
        return t._gsap || ut(ie(t))[0]._gsap
    }, pt = function(t, e, i) {
        return (i = t[e]) && P(i) ? t[e]() : I(i) && t.getAttribute && t.getAttribute(e) || i
    }, ft = function(t, e) {
        return (t = t.split(",")).forEach(e) || t
    }, mt = function(t) {
        return Math.round(1e5 * t) / 1e5 || 0
    }, gt = function(t) {
        return Math.round(1e7 * t) / 1e7 || 0
    }, vt = function(t, e) {
        var i = e.charAt(0)
          , n = parseFloat(e.substr(2));
        return t = parseFloat(t),
        "+" === i ? t + n : "-" === i ? t - n : "*" === i ? t * n : t / n
    }, yt = function(t, e) {
        for (var i = e.length, n = 0; t.indexOf(e[n]) < 0 && ++n < i; )
            ;
        return n < i
    }, xt = function() {
        var t, e, i = rt.length, n = rt.slice(0);
        for (st = {},
        rt.length = 0,
        t = 0; t < i; t++)
            (e = n[t]) && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0)
    }, _t = function(t, e, i, r) {
        rt.length && !n && xt(),
        t.render(e, i, r || n && e < 0 && (t._initted || t._startAt)),
        rt.length && !n && xt()
    }, wt = function(t) {
        var e = parseFloat(t);
        return (e || 0 === e) && (t + "").match(W).length < 2 ? e : C(t) ? t.trim() : t
    }, bt = function(t) {
        return t
    }, Mt = function(t, e) {
        for (var i in e)
            i in t || (t[i] = e[i]);
        return t
    }, St = function(t, e) {
        for (var i in e)
            t[i] = e[i];
        return t
    }, Tt = function t(e, i) {
        for (var n in i)
            "__proto__" !== n && "constructor" !== n && "prototype" !== n && (e[n] = D(i[n]) ? t(e[n] || (e[n] = {}), i[n]) : i[n]);
        return e
    }, Et = function(t, e) {
        var i, n = {};
        for (i in t)
            i in e || (n[i] = t[i]);
        return n
    }, Lt = function(t) {
        var e, i = t.parent || s, n = t.keyframes ? (e = B(t.keyframes),
        function(t, i) {
            for (var n in i)
                n in t || "duration" === n && e || "ease" === n || (t[n] = i[n])
        }
        ) : Mt;
        if (N(t.inherit))
            for (; i; )
                n(t, i.vars.defaults),
                i = i.parent || i._dp;
        return t
    }, At = function(t, e, i, n, r) {
        void 0 === i && (i = "_first"),
        void 0 === n && (n = "_last");
        var s, a = t[n];
        if (r)
            for (s = e[r]; a && a[r] > s; )
                a = a._prev;
        return a ? (e._next = a._next,
        a._next = e) : (e._next = t[i],
        t[i] = e),
        e._next ? e._next._prev = e : t[n] = e,
        e._prev = a,
        e.parent = e._dp = t,
        e
    }, Ct = function(t, e, i, n) {
        void 0 === i && (i = "_first"),
        void 0 === n && (n = "_last");
        var r = e._prev
          , s = e._next;
        r ? r._next = s : t[i] === e && (t[i] = s),
        s ? s._prev = r : t[n] === e && (t[n] = r),
        e._next = e._prev = e.parent = null
    }, Pt = function(t, e) {
        t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove && t.parent.remove(t),
        t._act = 0
    }, Rt = function(t, e) {
        if (t && (!e || e._end > t._dur || e._start < 0))
            for (var i = t; i; )
                i._dirty = 1,
                i = i.parent;
        return t
    }, It = function(t, e, i, r) {
        return t._startAt && (n ? t._startAt.revert(et) : t.vars.immediateRender && !t.vars.autoRevert || t._startAt.render(e, !0, r))
    }, Dt = function t(e) {
        return !e || e._ts && t(e.parent)
    }, Nt = function(t) {
        return t._repeat ? Ot(t._tTime, t = t.duration() + t._rDelay) * t : 0
    }, Ot = function(t, e) {
        var i = Math.floor(t /= e);
        return t && i === t ? i - 1 : i
    }, zt = function(t, e) {
        return (t - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
    }, kt = function(t) {
        return t._end = gt(t._start + (t._tDur / Math.abs(t._ts || t._rts || b) || 0))
    }, Bt = function(t, e) {
        var i = t._dp;
        return i && i.smoothChildTiming && t._ts && (t._start = gt(i._time - (t._ts > 0 ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)),
        kt(t),
        i._dirty || Rt(i, t)),
        t
    }, Ft = function(t, e) {
        var i;
        if ((e._time || !e._dur && e._initted || e._start < t._time && (e._dur || !e.add)) && (i = zt(t.rawTime(), e),
        (!e._dur || Qt(0, e.totalDuration(), i) - e._tTime > b) && e.render(i, !0)),
        Rt(t, e)._dp && t._initted && t._time >= t._dur && t._ts) {
            if (t._dur < t.duration())
                for (i = t; i._dp; )
                    i.rawTime() >= 0 && i.totalTime(i._tTime),
                    i = i._dp;
            t._zTime = -1e-8
        }
    }, Ht = function(t, e, i, n) {
        return e.parent && Pt(e),
        e._start = gt((R(i) ? i : i || t !== s ? Xt(t, i, e) : t._time) + e._delay),
        e._end = gt(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)),
        At(t, e, "_first", "_last", t._sort ? "_start" : 0),
        Wt(e) || (t._recent = e),
        n || Ft(t, e),
        t._ts < 0 && Bt(t, t._tTime),
        t
    }, Ut = function(t, e) {
        return (j.ScrollTrigger || J("scrollTrigger", e)) && j.ScrollTrigger.create(e, t)
    }, Gt = function(t, e, i, r, s) {
        return Ye(t, e, s),
        t._initted ? !i && t._pt && !n && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) && h !== Ee.frame ? (rt.push(t),
        t._lazy = [s, r],
        1) : void 0 : 1
    }, Vt = function t(e) {
        var i = e.parent;
        return i && i._ts && i._initted && !i._lock && (i.rawTime() < 0 || t(i))
    }, Wt = function(t) {
        var e = t.data;
        return "isFromStart" === e || "isStart" === e
    }, qt = function(t, e, i, n) {
        var r = t._repeat
          , s = gt(e) || 0
          , a = t._tTime / t._tDur;
        return a && !n && (t._time *= s / t._dur),
        t._dur = s,
        t._tDur = r ? r < 0 ? 1e10 : gt(s * (r + 1) + t._rDelay * r) : s,
        a > 0 && !n && Bt(t, t._tTime = t._tDur * a),
        t.parent && kt(t),
        i || Rt(t.parent, t),
        t
    }, jt = function(t) {
        return t instanceof Ue ? Rt(t) : qt(t, t._dur)
    }, Yt = {
        _start: 0,
        endTime: K,
        totalDuration: K
    }, Xt = function t(e, i, n) {
        var r, s, a, o = e.labels, l = e._recent || Yt, c = e.duration() >= w ? l.endTime(!1) : e._dur;
        return C(i) && (isNaN(i) || i in o) ? (s = i.charAt(0),
        a = "%" === i.substr(-1),
        r = i.indexOf("="),
        "<" === s || ">" === s ? (r >= 0 && (i = i.replace(/=/, "")),
        ("<" === s ? l._start : l.endTime(l._repeat >= 0)) + (parseFloat(i.substr(1)) || 0) * (a ? (r < 0 ? l : n).totalDuration() / 100 : 1)) : r < 0 ? (i in o || (o[i] = c),
        o[i]) : (s = parseFloat(i.charAt(r - 1) + i.substr(r + 1)),
        a && n && (s = s / 100 * (B(n) ? n[0] : n).totalDuration()),
        r > 1 ? t(e, i.substr(0, r - 1), n) + s : c + s)) : null == i ? c : +i
    }, Jt = function(t, e, i) {
        var n, r, s = R(e[1]), a = (s ? 2 : 1) + (t < 2 ? 0 : 1), o = e[a];
        if (s && (o.duration = e[1]),
        o.parent = i,
        t) {
            for (n = o,
            r = i; r && !("immediateRender"in n); )
                n = r.vars.defaults || {},
                r = N(r.vars.inherit) && r.parent;
            o.immediateRender = N(n.immediateRender),
            t < 2 ? o.runBackwards = 1 : o.startAt = e[a - 1]
        }
        return new $e(e[0],o,e[a + 1])
    }, Zt = function(t, e) {
        return t || 0 === t ? e(t) : e
    }, Qt = function(t, e, i) {
        return i < t ? t : i > e ? e : i
    }, $t = function(t, e) {
        return C(t) && (e = q.exec(t)) ? e[1] : ""
    }, Kt = [].slice, te = function(t, e) {
        return t && D(t) && "length"in t && (!e && !t.length || t.length - 1 in t && D(t[0])) && !t.nodeType && t !== a
    }, ee = function(t, e, i) {
        return void 0 === i && (i = []),
        t.forEach((function(t) {
            var n;
            return C(t) && !e || te(t, 1) ? (n = i).push.apply(n, ie(t)) : i.push(t)
        }
        )) || i
    }, ie = function(t, e, i) {
        return r && !e && r.selector ? r.selector(t) : !C(t) || i || !o && Le() ? B(t) ? ee(t, i) : te(t) ? Kt.call(t, 0) : t ? [t] : [] : Kt.call((e || l).querySelectorAll(t), 0)
    }, ne = function(t) {
        return t = ie(t)[0] || Z("Invalid scope") || {},
        function(e) {
            var i = t.current || t.nativeElement || t;
            return ie(e, i.querySelectorAll ? i : i === t ? Z("Invalid scope") || l.createElement("div") : t)
        }
    }, re = function(t) {
        return t.sort((function() {
            return .5 - Math.random()
        }
        ))
    }, se = function(t) {
        if (P(t))
            return t;
        var e = D(t) ? t : {
            each: t
        }
          , i = Ne(e.ease)
          , n = e.from || 0
          , r = parseFloat(e.base) || 0
          , s = {}
          , a = n > 0 && n < 1
          , o = isNaN(n) || a
          , l = e.axis
          , c = n
          , h = n;
        return C(n) ? c = h = {
            center: .5,
            edges: .5,
            end: 1
        }[n] || 0 : !a && o && (c = n[0],
        h = n[1]),
        function(t, a, u) {
            var d, p, f, m, g, v, y, x, _, b = (u || e).length, M = s[b];
            if (!M) {
                if (!(_ = "auto" === e.grid ? 0 : (e.grid || [1, w])[1])) {
                    for (y = -1e8; y < (y = u[_++].getBoundingClientRect().left) && _ < b; )
                        ;
                    _ < b && _--
                }
                for (M = s[b] = [],
                d = o ? Math.min(_, b) * c - .5 : n % _,
                p = _ === w ? 0 : o ? b * h / _ - .5 : n / _ | 0,
                y = 0,
                x = w,
                v = 0; v < b; v++)
                    f = v % _ - d,
                    m = p - (v / _ | 0),
                    M[v] = g = l ? Math.abs("y" === l ? m : f) : E(f * f + m * m),
                    g > y && (y = g),
                    g < x && (x = g);
                "random" === n && re(M),
                M.max = y - x,
                M.min = x,
                M.v = b = (parseFloat(e.amount) || parseFloat(e.each) * (_ > b ? b - 1 : l ? "y" === l ? b / _ : _ : Math.max(_, b / _)) || 0) * ("edges" === n ? -1 : 1),
                M.b = b < 0 ? r - b : r,
                M.u = $t(e.amount || e.each) || 0,
                i = i && b < 0 ? Ie(i) : i
            }
            return b = (M[t] - M.min) / M.max || 0,
            gt(M.b + (i ? i(b) : b) * M.v) + M.u
        }
    }, ae = function(t) {
        var e = Math.pow(10, ((t + "").split(".")[1] || "").length);
        return function(i) {
            var n = gt(Math.round(parseFloat(i) / t) * t * e);
            return (n - n % 1) / e + (R(i) ? 0 : $t(i))
        }
    }, oe = function(t, e) {
        var i, n, r = B(t);
        return !r && D(t) && (i = r = t.radius || w,
        t.values ? (t = ie(t.values),
        (n = !R(t[0])) && (i *= i)) : t = ae(t.increment)),
        Zt(e, r ? P(t) ? function(e) {
            return n = t(e),
            Math.abs(n - e) <= i ? n : e
        }
        : function(e) {
            for (var r, s, a = parseFloat(n ? e.x : e), o = parseFloat(n ? e.y : 0), l = w, c = 0, h = t.length; h--; )
                (r = n ? (r = t[h].x - a) * r + (s = t[h].y - o) * s : Math.abs(t[h] - a)) < l && (l = r,
                c = h);
            return c = !i || l <= i ? t[c] : e,
            n || c === e || R(e) ? c : c + $t(e)
        }
        : ae(t))
    }, le = function(t, e, i, n) {
        return Zt(B(t) ? !e : !0 === i ? !!(i = 0) : !n, (function() {
            return B(t) ? t[~~(Math.random() * t.length)] : (i = i || 1e-5) && (n = i < 1 ? Math.pow(10, (i + "").length - 2) : 1) && Math.floor(Math.round((t - i / 2 + Math.random() * (e - t + .99 * i)) / i) * i * n) / n
        }
        ))
    }, ce = function(t, e, i) {
        return Zt(i, (function(i) {
            return t[~~e(i)]
        }
        ))
    }, he = function(t) {
        for (var e, i, n, r, s = 0, a = ""; ~(e = t.indexOf("random(", s)); )
            n = t.indexOf(")", e),
            r = "[" === t.charAt(e + 7),
            i = t.substr(e + 7, n - e - 7).match(r ? W : F),
            a += t.substr(s, e - s) + le(r ? i : +i[0], r ? 0 : +i[1], +i[2] || 1e-5),
            s = n + 1;
        return a + t.substr(s, t.length - s)
    }, ue = function(t, e, i, n, r) {
        var s = e - t
          , a = n - i;
        return Zt(r, (function(e) {
            return i + ((e - t) / s * a || 0)
        }
        ))
    }, de = function(t, e, i) {
        var n, r, s, a = t.labels, o = w;
        for (n in a)
            (r = a[n] - e) < 0 == !!i && r && o > (r = Math.abs(r)) && (s = n,
            o = r);
        return s
    }, pe = function(t, e, i) {
        var n, s, a, o = t.vars, l = o[e], c = r, h = t._ctx;
        if (l)
            return n = o[e + "Params"],
            s = o.callbackScope || t,
            i && rt.length && xt(),
            h && (r = h),
            a = n ? l.apply(s, n) : l.call(s),
            r = c,
            a
    }, fe = function(t) {
        return Pt(t),
        t.scrollTrigger && t.scrollTrigger.kill(!!n),
        t.progress() < 1 && pe(t, "onInterrupt"),
        t
    }, me = [], ge = function(t) {
        if (t)
            if (t = !t.name && t.default || t,
            O() || t.headless) {
                var e = t.name
                  , i = P(t)
                  , n = e && !i && t.init ? function() {
                    this._props = []
                }
                : t
                  , r = {
                    init: K,
                    render: oi,
                    add: qe,
                    kill: ci,
                    modifier: li,
                    rawVars: 0
                }
                  , s = {
                    targetTest: 0,
                    get: 0,
                    getSetter: ni,
                    aliases: {},
                    register: 0
                };
                if (Le(),
                t !== n) {
                    if (at[e])
                        return;
                    Mt(n, Mt(Et(t, r), s)),
                    St(n.prototype, St(r, Et(t, s))),
                    at[n.prop = e] = n,
                    t.targetTest && (ct.push(n),
                    nt[e] = 1),
                    e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin"
                }
                Q(e, n),
                t.register && t.register(Ti, n, di)
            } else
                me.push(t)
    }, ve = 255, ye = {
        aqua: [0, ve, ve],
        lime: [0, ve, 0],
        silver: [192, 192, 192],
        black: [0, 0, 0],
        maroon: [128, 0, 0],
        teal: [0, 128, 128],
        blue: [0, 0, ve],
        navy: [0, 0, 128],
        white: [ve, ve, ve],
        olive: [128, 128, 0],
        yellow: [ve, ve, 0],
        orange: [ve, 165, 0],
        gray: [128, 128, 128],
        purple: [128, 0, 128],
        green: [0, 128, 0],
        red: [ve, 0, 0],
        pink: [ve, 192, 203],
        cyan: [0, ve, ve],
        transparent: [ve, ve, ve, 0]
    }, xe = function(t, e, i) {
        return (6 * (t += t < 0 ? 1 : t > 1 ? -1 : 0) < 1 ? e + (i - e) * t * 6 : t < .5 ? i : 3 * t < 2 ? e + (i - e) * (2 / 3 - t) * 6 : e) * ve + .5 | 0
    }, _e = function(t, e, i) {
        var n, r, s, a, o, l, c, h, u, d, p = t ? R(t) ? [t >> 16, t >> 8 & ve, t & ve] : 0 : ye.black;
        if (!p) {
            if ("," === t.substr(-1) && (t = t.substr(0, t.length - 1)),
            ye[t])
                p = ye[t];
            else if ("#" === t.charAt(0)) {
                if (t.length < 6 && (n = t.charAt(1),
                r = t.charAt(2),
                s = t.charAt(3),
                t = "#" + n + n + r + r + s + s + (5 === t.length ? t.charAt(4) + t.charAt(4) : "")),
                9 === t.length)
                    return [(p = parseInt(t.substr(1, 6), 16)) >> 16, p >> 8 & ve, p & ve, parseInt(t.substr(7), 16) / 255];
                p = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & ve, t & ve]
            } else if ("hsl" === t.substr(0, 3))
                if (p = d = t.match(F),
                e) {
                    if (~t.indexOf("="))
                        return p = t.match(H),
                        i && p.length < 4 && (p[3] = 1),
                        p
                } else
                    a = +p[0] % 360 / 360,
                    o = +p[1] / 100,
                    n = 2 * (l = +p[2] / 100) - (r = l <= .5 ? l * (o + 1) : l + o - l * o),
                    p.length > 3 && (p[3] *= 1),
                    p[0] = xe(a + 1 / 3, n, r),
                    p[1] = xe(a, n, r),
                    p[2] = xe(a - 1 / 3, n, r);
            else
                p = t.match(F) || ye.transparent;
            p = p.map(Number)
        }
        return e && !d && (n = p[0] / ve,
        r = p[1] / ve,
        s = p[2] / ve,
        l = ((c = Math.max(n, r, s)) + (h = Math.min(n, r, s))) / 2,
        c === h ? a = o = 0 : (u = c - h,
        o = l > .5 ? u / (2 - c - h) : u / (c + h),
        a = c === n ? (r - s) / u + (r < s ? 6 : 0) : c === r ? (s - n) / u + 2 : (n - r) / u + 4,
        a *= 60),
        p[0] = ~~(a + .5),
        p[1] = ~~(100 * o + .5),
        p[2] = ~~(100 * l + .5)),
        i && p.length < 4 && (p[3] = 1),
        p
    }, we = function(t) {
        var e = []
          , i = []
          , n = -1;
        return t.split(Me).forEach((function(t) {
            var r = t.match(U) || [];
            e.push.apply(e, r),
            i.push(n += r.length + 1)
        }
        )),
        e.c = i,
        e
    }, be = function(t, e, i) {
        var n, r, s, a, o = "", l = (t + o).match(Me), c = e ? "hsla(" : "rgba(", h = 0;
        if (!l)
            return t;
        if (l = l.map((function(t) {
            return (t = _e(t, e, 1)) && c + (e ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3] : t.join(",")) + ")"
        }
        )),
        i && (s = we(t),
        (n = i.c).join(o) !== s.c.join(o)))
            for (a = (r = t.replace(Me, "1").split(U)).length - 1; h < a; h++)
                o += r[h] + (~n.indexOf(h) ? l.shift() || c + "0,0,0,0)" : (s.length ? s : l.length ? l : i).shift());
        if (!r)
            for (a = (r = t.split(Me)).length - 1; h < a; h++)
                o += r[h] + l[h];
        return o + r[a]
    }, Me = function() {
        var t, e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
        for (t in ye)
            e += "|" + t + "\\b";
        return new RegExp(e + ")","gi")
    }(), Se = /hsl[a]?\(/, Te = function(t) {
        var e, i = t.join(" ");
        if (Me.lastIndex = 0,
        Me.test(i))
            return e = Se.test(i),
            t[1] = be(t[1], e),
            t[0] = be(t[0], e, we(t[1])),
            !0
    }, Ee = function() {
        var t, e, i, n, r, s, h = Date.now, u = 500, p = 33, f = h(), m = f, g = 1e3 / 240, v = g, y = [], x = function i(a) {
            var o, l, c, d, x = h() - m, _ = !0 === a;
            if ((x > u || x < 0) && (f += x - p),
            ((o = (c = (m += x) - f) - v) > 0 || _) && (d = ++n.frame,
            r = c - 1e3 * n.time,
            n.time = c /= 1e3,
            v += o + (o >= g ? 4 : g - o),
            l = 1),
            _ || (t = e(i)),
            l)
                for (s = 0; s < y.length; s++)
                    y[s](c, r, d, a)
        };
        return n = {
            time: 0,
            frame: 0,
            tick: function() {
                x(!0)
            },
            deltaRatio: function(t) {
                return r / (1e3 / (t || 60))
            },
            wake: function() {
                c && (!o && O() && (a = o = window,
                l = a.document || {},
                j.gsap = Ti,
                (a.gsapVersions || (a.gsapVersions = [])).push(Ti.version),
                X(Y || a.GreenSockGlobals || !a.gsap && a || {}),
                me.forEach(ge)),
                i = "undefined" != typeof requestAnimationFrame && requestAnimationFrame,
                t && n.sleep(),
                e = i || function(t) {
                    return setTimeout(t, v - 1e3 * n.time + 1 | 0)
                }
                ,
                d = 1,
                x(2))
            },
            sleep: function() {
                (i ? cancelAnimationFrame : clearTimeout)(t),
                d = 0,
                e = K
            },
            lagSmoothing: function(t, e) {
                u = t || 1 / 0,
                p = Math.min(e || 33, u)
            },
            fps: function(t) {
                g = 1e3 / (t || 240),
                v = 1e3 * n.time + g
            },
            add: function(t, e, i) {
                var r = e ? function(e, i, s, a) {
                    t(e, i, s, a),
                    n.remove(r)
                }
                : t;
                return n.remove(t),
                y[i ? "unshift" : "push"](r),
                Le(),
                r
            },
            remove: function(t, e) {
                ~(e = y.indexOf(t)) && y.splice(e, 1) && s >= e && s--
            },
            _listeners: y
        },
        n
    }(), Le = function() {
        return !d && Ee.wake()
    }, Ae = {}, Ce = /^[\d.\-M][\d.\-,\s]/, Pe = /["']/g, Re = function(t) {
        for (var e, i, n, r = {}, s = t.substr(1, t.length - 3).split(":"), a = s[0], o = 1, l = s.length; o < l; o++)
            i = s[o],
            e = o !== l - 1 ? i.lastIndexOf(",") : i.length,
            n = i.substr(0, e),
            r[a] = isNaN(n) ? n.replace(Pe, "").trim() : +n,
            a = i.substr(e + 1).trim();
        return r
    }, Ie = function(t) {
        return function(e) {
            return 1 - t(1 - e)
        }
    }, De = function t(e, i) {
        for (var n, r = e._first; r; )
            r instanceof Ue ? t(r, i) : !r.vars.yoyoEase || r._yoyo && r._repeat || r._yoyo === i || (r.timeline ? t(r.timeline, i) : (n = r._ease,
            r._ease = r._yEase,
            r._yEase = n,
            r._yoyo = i)),
            r = r._next
    }, Ne = function(t, e) {
        return t && (P(t) ? t : Ae[t] || function(t) {
            var e, i, n, r, s = (t + "").split("("), a = Ae[s[0]];
            return a && s.length > 1 && a.config ? a.config.apply(null, ~t.indexOf("{") ? [Re(s[1])] : (e = t,
            i = e.indexOf("(") + 1,
            n = e.indexOf(")"),
            r = e.indexOf("(", i),
            e.substring(i, ~r && r < n ? e.indexOf(")", n + 1) : n)).split(",").map(wt)) : Ae._CE && Ce.test(t) ? Ae._CE("", t) : a
        }(t)) || e
    }, Oe = function(t, e, i, n) {
        void 0 === i && (i = function(t) {
            return 1 - e(1 - t)
        }
        ),
        void 0 === n && (n = function(t) {
            return t < .5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2
        }
        );
        var r, s = {
            easeIn: e,
            easeOut: i,
            easeInOut: n
        };
        return ft(t, (function(t) {
            for (var e in Ae[t] = j[t] = s,
            Ae[r = t.toLowerCase()] = i,
            s)
                Ae[r + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")] = Ae[t + "." + e] = s[e]
        }
        )),
        s
    }, ze = function(t) {
        return function(e) {
            return e < .5 ? (1 - t(1 - 2 * e)) / 2 : .5 + t(2 * (e - .5)) / 2
        }
    }, ke = function t(e, i, n) {
        var r = i >= 1 ? i : 1
          , s = (n || (e ? .3 : .45)) / (i < 1 ? i : 1)
          , a = s / M * (Math.asin(1 / r) || 0)
          , o = function(t) {
            return 1 === t ? 1 : r * Math.pow(2, -10 * t) * A((t - a) * s) + 1
        }
          , l = "out" === e ? o : "in" === e ? function(t) {
            return 1 - o(1 - t)
        }
        : ze(o);
        return s = M / s,
        l.config = function(i, n) {
            return t(e, i, n)
        }
        ,
        l
    }, Be = function t(e, i) {
        void 0 === i && (i = 1.70158);
        var n = function(t) {
            return t ? --t * t * ((i + 1) * t + i) + 1 : 0
        }
          , r = "out" === e ? n : "in" === e ? function(t) {
            return 1 - n(1 - t)
        }
        : ze(n);
        return r.config = function(i) {
            return t(e, i)
        }
        ,
        r
    };
    ft("Linear,Quad,Cubic,Quart,Quint,Strong", (function(t, e) {
        var i = e < 5 ? e + 1 : e;
        Oe(t + ",Power" + (i - 1), e ? function(t) {
            return Math.pow(t, i)
        }
        : function(t) {
            return t
        }
        , (function(t) {
            return 1 - Math.pow(1 - t, i)
        }
        ), (function(t) {
            return t < .5 ? Math.pow(2 * t, i) / 2 : 1 - Math.pow(2 * (1 - t), i) / 2
        }
        ))
    }
    )),
    Ae.Linear.easeNone = Ae.none = Ae.Linear.easeIn,
    Oe("Elastic", ke("in"), ke("out"), ke()),
    p = 7.5625,
    g = 2 * (m = 1 / (f = 2.75)),
    v = 2.5 * m,
    Oe("Bounce", (function(t) {
        return 1 - y(1 - t)
    }
    ), y = function(t) {
        return t < m ? p * t * t : t < g ? p * Math.pow(t - 1.5 / f, 2) + .75 : t < v ? p * (t -= 2.25 / f) * t + .9375 : p * Math.pow(t - 2.625 / f, 2) + .984375
    }
    ),
    Oe("Expo", (function(t) {
        return t ? Math.pow(2, 10 * (t - 1)) : 0
    }
    )),
    Oe("Circ", (function(t) {
        return -(E(1 - t * t) - 1)
    }
    )),
    Oe("Sine", (function(t) {
        return 1 === t ? 1 : 1 - L(t * S)
    }
    )),
    Oe("Back", Be("in"), Be("out"), Be()),
    Ae.SteppedEase = Ae.steps = j.SteppedEase = {
        config: function(t, e) {
            void 0 === t && (t = 1);
            var i = 1 / t
              , n = t + (e ? 0 : 1)
              , r = e ? 1 : 0;
            return function(t) {
                return ((n * Qt(0, .99999999, t) | 0) + r) * i
            }
        }
    },
    _.ease = Ae["quad.out"],
    ft("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function(t) {
        return ht += t + "," + t + "Params,"
    }
    ));
    var Fe = function(t, e) {
        this.id = T++,
        t._gsap = this,
        this.target = t,
        this.harness = e,
        this.get = e ? e.get : pt,
        this.set = e ? e.getSetter : ni
    }
      , He = function() {
        function t(t) {
            this.vars = t,
            this._delay = +t.delay || 0,
            (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0,
            this._yoyo = !!t.yoyo || !!t.yoyoEase),
            this._ts = 1,
            qt(this, +t.duration, 1, 1),
            this.data = t.data,
            r && (this._ctx = r,
            r.data.push(this)),
            d || Ee.wake()
        }
        var e = t.prototype;
        return e.delay = function(t) {
            return t || 0 === t ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay),
            this._delay = t,
            this) : this._delay
        }
        ,
        e.duration = function(t) {
            return arguments.length ? this.totalDuration(this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur
        }
        ,
        e.totalDuration = function(t) {
            return arguments.length ? (this._dirty = 0,
            qt(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
        }
        ,
        e.totalTime = function(t, e) {
            if (Le(),
            !arguments.length)
                return this._tTime;
            var i = this._dp;
            if (i && i.smoothChildTiming && this._ts) {
                for (Bt(this, t),
                !i._dp || i.parent || Ft(i, this); i && i.parent; )
                    i.parent._time !== i._start + (i._ts >= 0 ? i._tTime / i._ts : (i.totalDuration() - i._tTime) / -i._ts) && i.totalTime(i._tTime, !0),
                    i = i.parent;
                !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && t < this._tDur || this._ts < 0 && t > 0 || !this._tDur && !t) && Ht(this._dp, this, this._start - this._delay)
            }
            return (this._tTime !== t || !this._dur && !e || this._initted && Math.abs(this._zTime) === b || !t && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t),
            _t(this, t, e)),
            this
        }
        ,
        e.time = function(t, e) {
            return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + Nt(this)) % (this._dur + this._rDelay) || (t ? this._dur : 0), e) : this._time
        }
        ,
        e.totalProgress = function(t, e) {
            return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0
        }
        ,
        e.progress = function(t, e) {
            return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + Nt(this), e) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0
        }
        ,
        e.iteration = function(t, e) {
            var i = this.duration() + this._rDelay;
            return arguments.length ? this.totalTime(this._time + (t - 1) * i, e) : this._repeat ? Ot(this._tTime, i) + 1 : 1
        }
        ,
        e.timeScale = function(t, e) {
            if (!arguments.length)
                return -1e-8 === this._rts ? 0 : this._rts;
            if (this._rts === t)
                return this;
            var i = this.parent && this._ts ? zt(this.parent._time, this) : this._tTime;
            return this._rts = +t || 0,
            this._ts = this._ps || -1e-8 === t ? 0 : this._rts,
            this.totalTime(Qt(-Math.abs(this._delay), this._tDur, i), !1 !== e),
            kt(this),
            function(t) {
                for (var e = t.parent; e && e.parent; )
                    e._dirty = 1,
                    e.totalDuration(),
                    e = e.parent;
                return t
            }(this)
        }
        ,
        e.paused = function(t) {
            return arguments.length ? (this._ps !== t && (this._ps = t,
            t ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()),
            this._ts = this._act = 0) : (Le(),
            this._ts = this._rts,
            this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && Math.abs(this._zTime) !== b && (this._tTime -= b)))),
            this) : this._ps
        }
        ,
        e.startTime = function(t) {
            if (arguments.length) {
                this._start = t;
                var e = this.parent || this._dp;
                return e && (e._sort || !this.parent) && Ht(e, this, t - this._delay),
                this
            }
            return this._start
        }
        ,
        e.endTime = function(t) {
            return this._start + (N(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
        }
        ,
        e.rawTime = function(t) {
            var e = this.parent || this._dp;
            return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? zt(e.rawTime(t), this) : this._tTime : this._tTime
        }
        ,
        e.revert = function(t) {
            void 0 === t && (t = it);
            var e = n;
            return n = t,
            (this._initted || this._startAt) && (this.timeline && this.timeline.revert(t),
            this.totalTime(-.01, t.suppressEvents)),
            "nested" !== this.data && !1 !== t.kill && this.kill(),
            n = e,
            this
        }
        ,
        e.globalTime = function(t) {
            for (var e = this, i = arguments.length ? t : e.rawTime(); e; )
                i = e._start + i / (Math.abs(e._ts) || 1),
                e = e._dp;
            return !this.parent && this._sat ? this._sat.globalTime(t) : i
        }
        ,
        e.repeat = function(t) {
            return arguments.length ? (this._repeat = t === 1 / 0 ? -2 : t,
            jt(this)) : -2 === this._repeat ? 1 / 0 : this._repeat
        }
        ,
        e.repeatDelay = function(t) {
            if (arguments.length) {
                var e = this._time;
                return this._rDelay = t,
                jt(this),
                e ? this.time(e) : this
            }
            return this._rDelay
        }
        ,
        e.yoyo = function(t) {
            return arguments.length ? (this._yoyo = t,
            this) : this._yoyo
        }
        ,
        e.seek = function(t, e) {
            return this.totalTime(Xt(this, t), N(e))
        }
        ,
        e.restart = function(t, e) {
            return this.play().totalTime(t ? -this._delay : 0, N(e))
        }
        ,
        e.play = function(t, e) {
            return null != t && this.seek(t, e),
            this.reversed(!1).paused(!1)
        }
        ,
        e.reverse = function(t, e) {
            return null != t && this.seek(t || this.totalDuration(), e),
            this.reversed(!0).paused(!1)
        }
        ,
        e.pause = function(t, e) {
            return null != t && this.seek(t, e),
            this.paused(!0)
        }
        ,
        e.resume = function() {
            return this.paused(!1)
        }
        ,
        e.reversed = function(t) {
            return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -1e-8 : 0)),
            this) : this._rts < 0
        }
        ,
        e.invalidate = function() {
            return this._initted = this._act = 0,
            this._zTime = -1e-8,
            this
        }
        ,
        e.isActive = function() {
            var t, e = this.parent || this._dp, i = this._start;
            return !(e && !(this._ts && this._initted && e.isActive() && (t = e.rawTime(!0)) >= i && t < this.endTime(!0) - b))
        }
        ,
        e.eventCallback = function(t, e, i) {
            var n = this.vars;
            return arguments.length > 1 ? (e ? (n[t] = e,
            i && (n[t + "Params"] = i),
            "onUpdate" === t && (this._onUpdate = e)) : delete n[t],
            this) : n[t]
        }
        ,
        e.then = function(t) {
            var e = this;
            return new Promise((function(i) {
                var n = P(t) ? t : bt
                  , r = function() {
                    var t = e.then;
                    e.then = null,
                    P(n) && (n = n(e)) && (n.then || n === e) && (e.then = t),
                    i(n),
                    e.then = t
                };
                e._initted && 1 === e.totalProgress() && e._ts >= 0 || !e._tTime && e._ts < 0 ? r() : e._prom = r
            }
            ))
        }
        ,
        e.kill = function() {
            fe(this)
        }
        ,
        t
    }();
    Mt(He.prototype, {
        _time: 0,
        _start: 0,
        _end: 0,
        _tTime: 0,
        _tDur: 0,
        _dirty: 0,
        _repeat: 0,
        _yoyo: !1,
        parent: null,
        _initted: !1,
        _rDelay: 0,
        _ts: 1,
        _dp: 0,
        ratio: 0,
        _zTime: -1e-8,
        _prom: 0,
        _ps: !1,
        _rts: 1
    });
    var Ue = function(i) {
        function r(e, n) {
            var r;
            return void 0 === e && (e = {}),
            (r = i.call(this, e) || this).labels = {},
            r.smoothChildTiming = !!e.smoothChildTiming,
            r.autoRemoveChildren = !!e.autoRemoveChildren,
            r._sort = N(e.sortChildren),
            s && Ht(e.parent || s, t(r), n),
            e.reversed && r.reverse(),
            e.paused && r.paused(!0),
            e.scrollTrigger && Ut(t(r), e.scrollTrigger),
            r
        }
        e(r, i);
        var a = r.prototype;
        return a.to = function(t, e, i) {
            return Jt(0, arguments, this),
            this
        }
        ,
        a.from = function(t, e, i) {
            return Jt(1, arguments, this),
            this
        }
        ,
        a.fromTo = function(t, e, i, n) {
            return Jt(2, arguments, this),
            this
        }
        ,
        a.set = function(t, e, i) {
            return e.duration = 0,
            e.parent = this,
            Lt(e).repeatDelay || (e.repeat = 0),
            e.immediateRender = !!e.immediateRender,
            new $e(t,e,Xt(this, i),1),
            this
        }
        ,
        a.call = function(t, e, i) {
            return Ht(this, $e.delayedCall(0, t, e), i)
        }
        ,
        a.staggerTo = function(t, e, i, n, r, s, a) {
            return i.duration = e,
            i.stagger = i.stagger || n,
            i.onComplete = s,
            i.onCompleteParams = a,
            i.parent = this,
            new $e(t,i,Xt(this, r)),
            this
        }
        ,
        a.staggerFrom = function(t, e, i, n, r, s, a) {
            return i.runBackwards = 1,
            Lt(i).immediateRender = N(i.immediateRender),
            this.staggerTo(t, e, i, n, r, s, a)
        }
        ,
        a.staggerFromTo = function(t, e, i, n, r, s, a, o) {
            return n.startAt = i,
            Lt(n).immediateRender = N(n.immediateRender),
            this.staggerTo(t, e, n, r, s, a, o)
        }
        ,
        a.render = function(t, e, i) {
            var r, a, o, l, c, h, u, d, p, f, m, g, v = this._time, y = this._dirty ? this.totalDuration() : this._tDur, x = this._dur, _ = t <= 0 ? 0 : gt(t), w = this._zTime < 0 != t < 0 && (this._initted || !x);
            if (this !== s && _ > y && t >= 0 && (_ = y),
            _ !== this._tTime || i || w) {
                if (v !== this._time && x && (_ += this._time - v,
                t += this._time - v),
                r = _,
                p = this._start,
                h = !(d = this._ts),
                w && (x || (v = this._zTime),
                (t || !e) && (this._zTime = t)),
                this._repeat) {
                    if (m = this._yoyo,
                    c = x + this._rDelay,
                    this._repeat < -1 && t < 0)
                        return this.totalTime(100 * c + t, e, i);
                    if (r = gt(_ % c),
                    _ === y ? (l = this._repeat,
                    r = x) : ((l = ~~(_ / c)) && l === _ / c && (r = x,
                    l--),
                    r > x && (r = x)),
                    f = Ot(this._tTime, c),
                    !v && this._tTime && f !== l && this._tTime - f * c - this._dur <= 0 && (f = l),
                    m && 1 & l && (r = x - r,
                    g = 1),
                    l !== f && !this._lock) {
                        var M = m && 1 & f
                          , S = M === (m && 1 & l);
                        if (l < f && (M = !M),
                        v = M ? 0 : _ % x ? x : _,
                        this._lock = 1,
                        this.render(v || (g ? 0 : gt(l * c)), e, !x)._lock = 0,
                        this._tTime = _,
                        !e && this.parent && pe(this, "onRepeat"),
                        this.vars.repeatRefresh && !g && (this.invalidate()._lock = 1),
                        v && v !== this._time || h !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
                            return this;
                        if (x = this._dur,
                        y = this._tDur,
                        S && (this._lock = 2,
                        v = M ? x : -1e-4,
                        this.render(v, !0),
                        this.vars.repeatRefresh && !g && this.invalidate()),
                        this._lock = 0,
                        !this._ts && !h)
                            return this;
                        De(this, g)
                    }
                }
                if (this._hasPause && !this._forcing && this._lock < 2 && (u = function(t, e, i) {
                    var n;
                    if (i > e)
                        for (n = t._first; n && n._start <= i; ) {
                            if ("isPause" === n.data && n._start > e)
                                return n;
                            n = n._next
                        }
                    else
                        for (n = t._last; n && n._start >= i; ) {
                            if ("isPause" === n.data && n._start < e)
                                return n;
                            n = n._prev
                        }
                }(this, gt(v), gt(r)),
                u && (_ -= r - (r = u._start))),
                this._tTime = _,
                this._time = r,
                this._act = !d,
                this._initted || (this._onUpdate = this.vars.onUpdate,
                this._initted = 1,
                this._zTime = t,
                v = 0),
                !v && r && !e && !l && (pe(this, "onStart"),
                this._tTime !== _))
                    return this;
                if (r >= v && t >= 0)
                    for (a = this._first; a; ) {
                        if (o = a._next,
                        (a._act || r >= a._start) && a._ts && u !== a) {
                            if (a.parent !== this)
                                return this.render(t, e, i);
                            if (a.render(a._ts > 0 ? (r - a._start) * a._ts : (a._dirty ? a.totalDuration() : a._tDur) + (r - a._start) * a._ts, e, i),
                            r !== this._time || !this._ts && !h) {
                                u = 0,
                                o && (_ += this._zTime = -1e-8);
                                break
                            }
                        }
                        a = o
                    }
                else {
                    a = this._last;
                    for (var T = t < 0 ? t : r; a; ) {
                        if (o = a._prev,
                        (a._act || T <= a._end) && a._ts && u !== a) {
                            if (a.parent !== this)
                                return this.render(t, e, i);
                            if (a.render(a._ts > 0 ? (T - a._start) * a._ts : (a._dirty ? a.totalDuration() : a._tDur) + (T - a._start) * a._ts, e, i || n && (a._initted || a._startAt)),
                            r !== this._time || !this._ts && !h) {
                                u = 0,
                                o && (_ += this._zTime = T ? -1e-8 : b);
                                break
                            }
                        }
                        a = o
                    }
                }
                if (u && !e && (this.pause(),
                u.render(r >= v ? 0 : -1e-8)._zTime = r >= v ? 1 : -1,
                this._ts))
                    return this._start = p,
                    kt(this),
                    this.render(t, e, i);
                this._onUpdate && !e && pe(this, "onUpdate", !0),
                (_ === y && this._tTime >= this.totalDuration() || !_ && v) && (p !== this._start && Math.abs(d) === Math.abs(this._ts) || this._lock || ((t || !x) && (_ === y && this._ts > 0 || !_ && this._ts < 0) && Pt(this, 1),
                e || t < 0 && !v || !_ && !v && y || (pe(this, _ === y && t >= 0 ? "onComplete" : "onReverseComplete", !0),
                this._prom && !(_ < y && this.timeScale() > 0) && this._prom())))
            }
            return this
        }
        ,
        a.add = function(t, e) {
            var i = this;
            if (R(e) || (e = Xt(this, e, t)),
            !(t instanceof He)) {
                if (B(t))
                    return t.forEach((function(t) {
                        return i.add(t, e)
                    }
                    )),
                    this;
                if (C(t))
                    return this.addLabel(t, e);
                if (!P(t))
                    return this;
                t = $e.delayedCall(0, t)
            }
            return this !== t ? Ht(this, t, e) : this
        }
        ,
        a.getChildren = function(t, e, i, n) {
            void 0 === t && (t = !0),
            void 0 === e && (e = !0),
            void 0 === i && (i = !0),
            void 0 === n && (n = -1e8);
            for (var r = [], s = this._first; s; )
                s._start >= n && (s instanceof $e ? e && r.push(s) : (i && r.push(s),
                t && r.push.apply(r, s.getChildren(!0, e, i)))),
                s = s._next;
            return r
        }
        ,
        a.getById = function(t) {
            for (var e = this.getChildren(1, 1, 1), i = e.length; i--; )
                if (e[i].vars.id === t)
                    return e[i]
        }
        ,
        a.remove = function(t) {
            return C(t) ? this.removeLabel(t) : P(t) ? this.killTweensOf(t) : (Ct(this, t),
            t === this._recent && (this._recent = this._last),
            Rt(this))
        }
        ,
        a.totalTime = function(t, e) {
            return arguments.length ? (this._forcing = 1,
            !this._dp && this._ts && (this._start = gt(Ee.time - (this._ts > 0 ? t / this._ts : (this.totalDuration() - t) / -this._ts))),
            i.prototype.totalTime.call(this, t, e),
            this._forcing = 0,
            this) : this._tTime
        }
        ,
        a.addLabel = function(t, e) {
            return this.labels[t] = Xt(this, e),
            this
        }
        ,
        a.removeLabel = function(t) {
            return delete this.labels[t],
            this
        }
        ,
        a.addPause = function(t, e, i) {
            var n = $e.delayedCall(0, e || K, i);
            return n.data = "isPause",
            this._hasPause = 1,
            Ht(this, n, Xt(this, t))
        }
        ,
        a.removePause = function(t) {
            var e = this._first;
            for (t = Xt(this, t); e; )
                e._start === t && "isPause" === e.data && Pt(e),
                e = e._next
        }
        ,
        a.killTweensOf = function(t, e, i) {
            for (var n = this.getTweensOf(t, i), r = n.length; r--; )
                Ge !== n[r] && n[r].kill(t, e);
            return this
        }
        ,
        a.getTweensOf = function(t, e) {
            for (var i, n = [], r = ie(t), s = this._first, a = R(e); s; )
                s instanceof $e ? yt(s._targets, r) && (a ? (!Ge || s._initted && s._ts) && s.globalTime(0) <= e && s.globalTime(s.totalDuration()) > e : !e || s.isActive()) && n.push(s) : (i = s.getTweensOf(r, e)).length && n.push.apply(n, i),
                s = s._next;
            return n
        }
        ,
        a.tweenTo = function(t, e) {
            e = e || {};
            var i, n = this, r = Xt(n, t), s = e, a = s.startAt, o = s.onStart, l = s.onStartParams, c = s.immediateRender, h = $e.to(n, Mt({
                ease: e.ease || "none",
                lazy: !1,
                immediateRender: !1,
                time: r,
                overwrite: "auto",
                duration: e.duration || Math.abs((r - (a && "time"in a ? a.time : n._time)) / n.timeScale()) || b,
                onStart: function() {
                    if (n.pause(),
                    !i) {
                        var t = e.duration || Math.abs((r - (a && "time"in a ? a.time : n._time)) / n.timeScale());
                        h._dur !== t && qt(h, t, 0, 1).render(h._time, !0, !0),
                        i = 1
                    }
                    o && o.apply(h, l || [])
                }
            }, e));
            return c ? h.render(0) : h
        }
        ,
        a.tweenFromTo = function(t, e, i) {
            return this.tweenTo(e, Mt({
                startAt: {
                    time: Xt(this, t)
                }
            }, i))
        }
        ,
        a.recent = function() {
            return this._recent
        }
        ,
        a.nextLabel = function(t) {
            return void 0 === t && (t = this._time),
            de(this, Xt(this, t))
        }
        ,
        a.previousLabel = function(t) {
            return void 0 === t && (t = this._time),
            de(this, Xt(this, t), 1)
        }
        ,
        a.currentLabel = function(t) {
            return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + b)
        }
        ,
        a.shiftChildren = function(t, e, i) {
            void 0 === i && (i = 0);
            for (var n, r = this._first, s = this.labels; r; )
                r._start >= i && (r._start += t,
                r._end += t),
                r = r._next;
            if (e)
                for (n in s)
                    s[n] >= i && (s[n] += t);
            return Rt(this)
        }
        ,
        a.invalidate = function(t) {
            var e = this._first;
            for (this._lock = 0; e; )
                e.invalidate(t),
                e = e._next;
            return i.prototype.invalidate.call(this, t)
        }
        ,
        a.clear = function(t) {
            void 0 === t && (t = !0);
            for (var e, i = this._first; i; )
                e = i._next,
                this.remove(i),
                i = e;
            return this._dp && (this._time = this._tTime = this._pTime = 0),
            t && (this.labels = {}),
            Rt(this)
        }
        ,
        a.totalDuration = function(t) {
            var e, i, n, r = 0, a = this, o = a._last, l = w;
            if (arguments.length)
                return a.timeScale((a._repeat < 0 ? a.duration() : a.totalDuration()) / (a.reversed() ? -t : t));
            if (a._dirty) {
                for (n = a.parent; o; )
                    e = o._prev,
                    o._dirty && o.totalDuration(),
                    (i = o._start) > l && a._sort && o._ts && !a._lock ? (a._lock = 1,
                    Ht(a, o, i - o._delay, 1)._lock = 0) : l = i,
                    i < 0 && o._ts && (r -= i,
                    (!n && !a._dp || n && n.smoothChildTiming) && (a._start += i / a._ts,
                    a._time -= i,
                    a._tTime -= i),
                    a.shiftChildren(-i, !1, -Infinity),
                    l = 0),
                    o._end > r && o._ts && (r = o._end),
                    o = e;
                qt(a, a === s && a._time > r ? a._time : r, 1, 1),
                a._dirty = 0
            }
            return a._tDur
        }
        ,
        r.updateRoot = function(t) {
            if (s._ts && (_t(s, zt(t, s)),
            h = Ee.frame),
            Ee.frame >= lt) {
                lt += x.autoSleep || 120;
                var e = s._first;
                if ((!e || !e._ts) && x.autoSleep && Ee._listeners.length < 2) {
                    for (; e && !e._ts; )
                        e = e._next;
                    e || Ee.sleep()
                }
            }
        }
        ,
        r
    }(He);
    Mt(Ue.prototype, {
        _lock: 0,
        _hasPause: 0,
        _forcing: 0
    });
    var Ge, Ve, We = function(t, e, i, n, r, s, a) {
        var o, l, c, h, u, d, p, f, m = new di(this._pt,t,e,0,1,ai,null,r), g = 0, v = 0;
        for (m.b = i,
        m.e = n,
        i += "",
        (p = ~(n += "").indexOf("random(")) && (n = he(n)),
        s && (s(f = [i, n], t, e),
        i = f[0],
        n = f[1]),
        l = i.match(G) || []; o = G.exec(n); )
            h = o[0],
            u = n.substring(g, o.index),
            c ? c = (c + 1) % 5 : "rgba(" === u.substr(-5) && (c = 1),
            h !== l[v++] && (d = parseFloat(l[v - 1]) || 0,
            m._pt = {
                _next: m._pt,
                p: u || 1 === v ? u : ",",
                s: d,
                c: "=" === h.charAt(1) ? vt(d, h) - d : parseFloat(h) - d,
                m: c && c < 4 ? Math.round : 0
            },
            g = G.lastIndex);
        return m.c = g < n.length ? n.substring(g, n.length) : "",
        m.fp = a,
        (V.test(n) || p) && (m.e = 0),
        this._pt = m,
        m
    }, qe = function(t, e, i, n, r, s, a, o, l, c) {
        P(n) && (n = n(r || 0, t, s));
        var h, u = t[e], d = "get" !== i ? i : P(u) ? l ? t[e.indexOf("set") || !P(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](l) : t[e]() : u, p = P(u) ? l ? ei : ti : Ke;
        if (C(n) && (~n.indexOf("random(") && (n = he(n)),
        "=" === n.charAt(1) && ((h = vt(d, n) + ($t(d) || 0)) || 0 === h) && (n = h)),
        !c || d !== n || Ve)
            return isNaN(d * n) || "" === n ? (!u && !(e in t) && J(e, n),
            We.call(this, t, e, d, n, p, o || x.stringFilter, l)) : (h = new di(this._pt,t,e,+d || 0,n - (d || 0),"boolean" == typeof u ? si : ri,0,p),
            l && (h.fp = l),
            a && h.modifier(a, this, t),
            this._pt = h)
    }, je = function(t, e, i, n, r, s) {
        var a, o, l, c;
        if (at[t] && !1 !== (a = new at[t]).init(r, a.rawVars ? e[t] : function(t, e, i, n, r) {
            if (P(t) && (t = Je(t, r, e, i, n)),
            !D(t) || t.style && t.nodeType || B(t) || k(t))
                return C(t) ? Je(t, r, e, i, n) : t;
            var s, a = {};
            for (s in t)
                a[s] = Je(t[s], r, e, i, n);
            return a
        }(e[t], n, r, s, i), i, n, s) && (i._pt = o = new di(i._pt,r,t,0,1,a.render,a,0,a.priority),
        i !== u))
            for (l = i._ptLookup[i._targets.indexOf(r)],
            c = a._props.length; c--; )
                l[a._props[c]] = o;
        return a
    }, Ye = function t(e, r, a) {
        var o, l, c, h, u, d, p, f, m, g, v, y, x, M = e.vars, S = M.ease, T = M.startAt, E = M.immediateRender, L = M.lazy, A = M.onUpdate, C = M.runBackwards, P = M.yoyoEase, R = M.keyframes, I = M.autoRevert, D = e._dur, O = e._startAt, z = e._targets, k = e.parent, B = k && "nested" === k.data ? k.vars.targets : z, F = "auto" === e._overwrite && !i, H = e.timeline;
        if (H && (!R || !S) && (S = "none"),
        e._ease = Ne(S, _.ease),
        e._yEase = P ? Ie(Ne(!0 === P ? S : P, _.ease)) : 0,
        P && e._yoyo && !e._repeat && (P = e._yEase,
        e._yEase = e._ease,
        e._ease = P),
        e._from = !H && !!M.runBackwards,
        !H || R && !M.stagger) {
            if (y = (f = z[0] ? dt(z[0]).harness : 0) && M[f.prop],
            o = Et(M, nt),
            O && (O._zTime < 0 && O.progress(1),
            r < 0 && C && E && !I ? O.render(-1, !0) : O.revert(C && D ? et : tt),
            O._lazy = 0),
            T) {
                if (Pt(e._startAt = $e.set(z, Mt({
                    data: "isStart",
                    overwrite: !1,
                    parent: k,
                    immediateRender: !0,
                    lazy: !O && N(L),
                    startAt: null,
                    delay: 0,
                    onUpdate: A && function() {
                        return pe(e, "onUpdate")
                    }
                    ,
                    stagger: 0
                }, T))),
                e._startAt._dp = 0,
                e._startAt._sat = e,
                r < 0 && (n || !E && !I) && e._startAt.revert(et),
                E && D && r <= 0 && a <= 0)
                    return void (r && (e._zTime = r))
            } else if (C && D && !O)
                if (r && (E = !1),
                c = Mt({
                    overwrite: !1,
                    data: "isFromStart",
                    lazy: E && !O && N(L),
                    immediateRender: E,
                    stagger: 0,
                    parent: k
                }, o),
                y && (c[f.prop] = y),
                Pt(e._startAt = $e.set(z, c)),
                e._startAt._dp = 0,
                e._startAt._sat = e,
                r < 0 && (n ? e._startAt.revert(et) : e._startAt.render(-1, !0)),
                e._zTime = r,
                E) {
                    if (!r)
                        return
                } else
                    t(e._startAt, b, b);
            for (e._pt = e._ptCache = 0,
            L = D && N(L) || L && !D,
            l = 0; l < z.length; l++) {
                if (p = (u = z[l])._gsap || ut(z)[l]._gsap,
                e._ptLookup[l] = g = {},
                st[p.id] && rt.length && xt(),
                v = B === z ? l : B.indexOf(u),
                f && !1 !== (m = new f).init(u, y || o, e, v, B) && (e._pt = h = new di(e._pt,u,m.name,0,1,m.render,m,0,m.priority),
                m._props.forEach((function(t) {
                    g[t] = h
                }
                )),
                m.priority && (d = 1)),
                !f || y)
                    for (c in o)
                        at[c] && (m = je(c, o, e, v, u, B)) ? m.priority && (d = 1) : g[c] = h = qe.call(e, u, c, "get", o[c], v, B, 0, M.stringFilter);
                e._op && e._op[l] && e.kill(u, e._op[l]),
                F && e._pt && (Ge = e,
                s.killTweensOf(u, g, e.globalTime(r)),
                x = !e.parent,
                Ge = 0),
                e._pt && L && (st[p.id] = 1)
            }
            d && ui(e),
            e._onInit && e._onInit(e)
        }
        e._onUpdate = A,
        e._initted = (!e._op || e._pt) && !x,
        R && r <= 0 && H.render(w, !0, !0)
    }, Xe = function(t, e, i, n) {
        var r, s, a = e.ease || n || "power1.inOut";
        if (B(e))
            s = i[t] || (i[t] = []),
            e.forEach((function(t, i) {
                return s.push({
                    t: i / (e.length - 1) * 100,
                    v: t,
                    e: a
                })
            }
            ));
        else
            for (r in e)
                s = i[r] || (i[r] = []),
                "ease" === r || s.push({
                    t: parseFloat(t),
                    v: e[r],
                    e: a
                })
    }, Je = function(t, e, i, n, r) {
        return P(t) ? t.call(e, i, n, r) : C(t) && ~t.indexOf("random(") ? he(t) : t
    }, Ze = ht + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", Qe = {};
    ft(Ze + ",id,stagger,delay,duration,paused,scrollTrigger", (function(t) {
        return Qe[t] = 1
    }
    ));
    var $e = function(r) {
        function a(e, n, a, o) {
            var l;
            "number" == typeof n && (a.duration = n,
            n = a,
            a = null);
            var c, h, u, d, p, f, m, g, v = (l = r.call(this, o ? n : Lt(n)) || this).vars, y = v.duration, _ = v.delay, w = v.immediateRender, b = v.stagger, M = v.overwrite, S = v.keyframes, T = v.defaults, E = v.scrollTrigger, L = v.yoyoEase, A = n.parent || s, C = (B(e) || k(e) ? R(e[0]) : "length"in n) ? [e] : ie(e);
            if (l._targets = C.length ? ut(C) : Z("GSAP target " + e + " not found. https://gsap.com", !x.nullTargetWarn) || [],
            l._ptLookup = [],
            l._overwrite = M,
            S || b || z(y) || z(_)) {
                if (n = l.vars,
                (c = l.timeline = new Ue({
                    data: "nested",
                    defaults: T || {},
                    targets: A && "nested" === A.data ? A.vars.targets : C
                })).kill(),
                c.parent = c._dp = t(l),
                c._start = 0,
                b || z(y) || z(_)) {
                    if (d = C.length,
                    m = b && se(b),
                    D(b))
                        for (p in b)
                            ~Ze.indexOf(p) && (g || (g = {}),
                            g[p] = b[p]);
                    for (h = 0; h < d; h++)
                        (u = Et(n, Qe)).stagger = 0,
                        L && (u.yoyoEase = L),
                        g && St(u, g),
                        f = C[h],
                        u.duration = +Je(y, t(l), h, f, C),
                        u.delay = (+Je(_, t(l), h, f, C) || 0) - l._delay,
                        !b && 1 === d && u.delay && (l._delay = _ = u.delay,
                        l._start += _,
                        u.delay = 0),
                        c.to(f, u, m ? m(h, f, C) : 0),
                        c._ease = Ae.none;
                    c.duration() ? y = _ = 0 : l.timeline = 0
                } else if (S) {
                    Lt(Mt(c.vars.defaults, {
                        ease: "none"
                    })),
                    c._ease = Ne(S.ease || n.ease || "none");
                    var P, I, O, F = 0;
                    if (B(S))
                        S.forEach((function(t) {
                            return c.to(C, t, ">")
                        }
                        )),
                        c.duration();
                    else {
                        for (p in u = {},
                        S)
                            "ease" === p || "easeEach" === p || Xe(p, S[p], u, S.easeEach);
                        for (p in u)
                            for (P = u[p].sort((function(t, e) {
                                return t.t - e.t
                            }
                            )),
                            F = 0,
                            h = 0; h < P.length; h++)
                                (O = {
                                    ease: (I = P[h]).e,
                                    duration: (I.t - (h ? P[h - 1].t : 0)) / 100 * y
                                })[p] = I.v,
                                c.to(C, O, F),
                                F += O.duration;
                        c.duration() < y && c.to({}, {
                            duration: y - c.duration()
                        })
                    }
                }
                y || l.duration(y = c.duration())
            } else
                l.timeline = 0;
            return !0 !== M || i || (Ge = t(l),
            s.killTweensOf(C),
            Ge = 0),
            Ht(A, t(l), a),
            n.reversed && l.reverse(),
            n.paused && l.paused(!0),
            (w || !y && !S && l._start === gt(A._time) && N(w) && Dt(t(l)) && "nested" !== A.data) && (l._tTime = -1e-8,
            l.render(Math.max(0, -_) || 0)),
            E && Ut(t(l), E),
            l
        }
        e(a, r);
        var o = a.prototype;
        return o.render = function(t, e, i) {
            var r, s, a, o, l, c, h, u, d, p = this._time, f = this._tDur, m = this._dur, g = t < 0, v = t > f - b && !g ? f : t < b ? 0 : t;
            if (m) {
                if (v !== this._tTime || !t || i || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== g) {
                    if (r = v,
                    u = this.timeline,
                    this._repeat) {
                        if (o = m + this._rDelay,
                        this._repeat < -1 && g)
                            return this.totalTime(100 * o + t, e, i);
                        if (r = gt(v % o),
                        v === f ? (a = this._repeat,
                        r = m) : ((a = ~~(v / o)) && a === gt(v / o) && (r = m,
                        a--),
                        r > m && (r = m)),
                        (c = this._yoyo && 1 & a) && (d = this._yEase,
                        r = m - r),
                        l = Ot(this._tTime, o),
                        r === p && !i && this._initted && a === l)
                            return this._tTime = v,
                            this;
                        a !== l && (u && this._yEase && De(u, c),
                        this.vars.repeatRefresh && !c && !this._lock && this._time !== o && this._initted && (this._lock = i = 1,
                        this.render(gt(o * a), !0).invalidate()._lock = 0))
                    }
                    if (!this._initted) {
                        if (Gt(this, g ? t : r, i, e, v))
                            return this._tTime = 0,
                            this;
                        if (!(p === this._time || i && this.vars.repeatRefresh && a !== l))
                            return this;
                        if (m !== this._dur)
                            return this.render(t, e, i)
                    }
                    if (this._tTime = v,
                    this._time = r,
                    !this._act && this._ts && (this._act = 1,
                    this._lazy = 0),
                    this.ratio = h = (d || this._ease)(r / m),
                    this._from && (this.ratio = h = 1 - h),
                    r && !p && !e && !a && (pe(this, "onStart"),
                    this._tTime !== v))
                        return this;
                    for (s = this._pt; s; )
                        s.r(h, s.d),
                        s = s._next;
                    u && u.render(t < 0 ? t : u._dur * u._ease(r / this._dur), e, i) || this._startAt && (this._zTime = t),
                    this._onUpdate && !e && (g && It(this, t, 0, i),
                    pe(this, "onUpdate")),
                    this._repeat && a !== l && this.vars.onRepeat && !e && this.parent && pe(this, "onRepeat"),
                    v !== this._tDur && v || this._tTime !== v || (g && !this._onUpdate && It(this, t, 0, !0),
                    (t || !m) && (v === this._tDur && this._ts > 0 || !v && this._ts < 0) && Pt(this, 1),
                    e || g && !p || !(v || p || c) || (pe(this, v === f ? "onComplete" : "onReverseComplete", !0),
                    this._prom && !(v < f && this.timeScale() > 0) && this._prom()))
                }
            } else
                !function(t, e, i, r) {
                    var s, a, o, l = t.ratio, c = e < 0 || !e && (!t._start && Vt(t) && (t._initted || !Wt(t)) || (t._ts < 0 || t._dp._ts < 0) && !Wt(t)) ? 0 : 1, h = t._rDelay, u = 0;
                    if (h && t._repeat && (u = Qt(0, t._tDur, e),
                    a = Ot(u, h),
                    t._yoyo && 1 & a && (c = 1 - c),
                    a !== Ot(t._tTime, h) && (l = 1 - c,
                    t.vars.repeatRefresh && t._initted && t.invalidate())),
                    c !== l || n || r || t._zTime === b || !e && t._zTime) {
                        if (!t._initted && Gt(t, e, r, i, u))
                            return;
                        for (o = t._zTime,
                        t._zTime = e || (i ? b : 0),
                        i || (i = e && !o),
                        t.ratio = c,
                        t._from && (c = 1 - c),
                        t._time = 0,
                        t._tTime = u,
                        s = t._pt; s; )
                            s.r(c, s.d),
                            s = s._next;
                        e < 0 && It(t, e, 0, !0),
                        t._onUpdate && !i && pe(t, "onUpdate"),
                        u && t._repeat && !i && t.parent && pe(t, "onRepeat"),
                        (e >= t._tDur || e < 0) && t.ratio === c && (c && Pt(t, 1),
                        i || n || (pe(t, c ? "onComplete" : "onReverseComplete", !0),
                        t._prom && t._prom()))
                    } else
                        t._zTime || (t._zTime = e)
                }(this, t, e, i);
            return this
        }
        ,
        o.targets = function() {
            return this._targets
        }
        ,
        o.invalidate = function(t) {
            return (!t || !this.vars.runBackwards) && (this._startAt = 0),
            this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0,
            this._ptLookup = [],
            this.timeline && this.timeline.invalidate(t),
            r.prototype.invalidate.call(this, t)
        }
        ,
        o.resetTo = function(t, e, i, n, r) {
            d || Ee.wake(),
            this._ts || this.play();
            var s = Math.min(this._dur, (this._dp._time - this._start) * this._ts);
            return this._initted || Ye(this, s),
            function(t, e, i, n, r, s, a, o) {
                var l, c, h, u, d = (t._pt && t._ptCache || (t._ptCache = {}))[e];
                if (!d)
                    for (d = t._ptCache[e] = [],
                    h = t._ptLookup,
                    u = t._targets.length; u--; ) {
                        if ((l = h[u][e]) && l.d && l.d._pt)
                            for (l = l.d._pt; l && l.p !== e && l.fp !== e; )
                                l = l._next;
                        if (!l)
                            return Ve = 1,
                            t.vars[e] = "+=0",
                            Ye(t, a),
                            Ve = 0,
                            o ? Z(e + " not eligible for reset") : 1;
                        d.push(l)
                    }
                for (u = d.length; u--; )
                    (l = (c = d[u])._pt || c).s = !n && 0 !== n || r ? l.s + (n || 0) + s * l.c : n,
                    l.c = i - l.s,
                    c.e && (c.e = mt(i) + $t(c.e)),
                    c.b && (c.b = l.s + $t(c.b))
            }(this, t, e, i, n, this._ease(s / this._dur), s, r) ? this.resetTo(t, e, i, n, 1) : (Bt(this, 0),
            this.parent || At(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0),
            this.render(0))
        }
        ,
        o.kill = function(t, e) {
            if (void 0 === e && (e = "all"),
            !(t || e && "all" !== e))
                return this._lazy = this._pt = 0,
                this.parent ? fe(this) : this;
            if (this.timeline) {
                var i = this.timeline.totalDuration();
                return this.timeline.killTweensOf(t, e, Ge && !0 !== Ge.vars.overwrite)._first || fe(this),
                this.parent && i !== this.timeline.totalDuration() && qt(this, this._dur * this.timeline._tDur / i, 0, 1),
                this
            }
            var n, r, s, a, o, l, c, h = this._targets, u = t ? ie(t) : h, d = this._ptLookup, p = this._pt;
            if ((!e || "all" === e) && function(t, e) {
                for (var i = t.length, n = i === e.length; n && i-- && t[i] === e[i]; )
                    ;
                return i < 0
            }(h, u))
                return "all" === e && (this._pt = 0),
                fe(this);
            for (n = this._op = this._op || [],
            "all" !== e && (C(e) && (o = {},
            ft(e, (function(t) {
                return o[t] = 1
            }
            )),
            e = o),
            e = function(t, e) {
                var i, n, r, s, a = t[0] ? dt(t[0]).harness : 0, o = a && a.aliases;
                if (!o)
                    return e;
                for (n in i = St({}, e),
                o)
                    if (n in i)
                        for (r = (s = o[n].split(",")).length; r--; )
                            i[s[r]] = i[n];
                return i
            }(h, e)),
            c = h.length; c--; )
                if (~u.indexOf(h[c]))
                    for (o in r = d[c],
                    "all" === e ? (n[c] = e,
                    a = r,
                    s = {}) : (s = n[c] = n[c] || {},
                    a = e),
                    a)
                        (l = r && r[o]) && ("kill"in l.d && !0 !== l.d.kill(o) || Ct(this, l, "_pt"),
                        delete r[o]),
                        "all" !== s && (s[o] = 1);
            return this._initted && !this._pt && p && fe(this),
            this
        }
        ,
        a.to = function(t, e) {
            return new a(t,e,arguments[2])
        }
        ,
        a.from = function(t, e) {
            return Jt(1, arguments)
        }
        ,
        a.delayedCall = function(t, e, i, n) {
            return new a(e,0,{
                immediateRender: !1,
                lazy: !1,
                overwrite: !1,
                delay: t,
                onComplete: e,
                onReverseComplete: e,
                onCompleteParams: i,
                onReverseCompleteParams: i,
                callbackScope: n
            })
        }
        ,
        a.fromTo = function(t, e, i) {
            return Jt(2, arguments)
        }
        ,
        a.set = function(t, e) {
            return e.duration = 0,
            e.repeatDelay || (e.repeat = 0),
            new a(t,e)
        }
        ,
        a.killTweensOf = function(t, e, i) {
            return s.killTweensOf(t, e, i)
        }
        ,
        a
    }(He);
    Mt($e.prototype, {
        _targets: [],
        _lazy: 0,
        _startAt: 0,
        _op: 0,
        _onInit: 0
    }),
    ft("staggerTo,staggerFrom,staggerFromTo", (function(t) {
        $e[t] = function() {
            var e = new Ue
              , i = Kt.call(arguments, 0);
            return i.splice("staggerFromTo" === t ? 5 : 4, 0, 0),
            e[t].apply(e, i)
        }
    }
    ));
    var Ke = function(t, e, i) {
        return t[e] = i
    }
      , ti = function(t, e, i) {
        return t[e](i)
    }
      , ei = function(t, e, i, n) {
        return t[e](n.fp, i)
    }
      , ii = function(t, e, i) {
        return t.setAttribute(e, i)
    }
      , ni = function(t, e) {
        return P(t[e]) ? ti : I(t[e]) && t.setAttribute ? ii : Ke
    }
      , ri = function(t, e) {
        return e.set(e.t, e.p, Math.round(1e6 * (e.s + e.c * t)) / 1e6, e)
    }
      , si = function(t, e) {
        return e.set(e.t, e.p, !!(e.s + e.c * t), e)
    }
      , ai = function(t, e) {
        var i = e._pt
          , n = "";
        if (!t && e.b)
            n = e.b;
        else if (1 === t && e.e)
            n = e.e;
        else {
            for (; i; )
                n = i.p + (i.m ? i.m(i.s + i.c * t) : Math.round(1e4 * (i.s + i.c * t)) / 1e4) + n,
                i = i._next;
            n += e.c
        }
        e.set(e.t, e.p, n, e)
    }
      , oi = function(t, e) {
        for (var i = e._pt; i; )
            i.r(t, i.d),
            i = i._next
    }
      , li = function(t, e, i, n) {
        for (var r, s = this._pt; s; )
            r = s._next,
            s.p === n && s.modifier(t, e, i),
            s = r
    }
      , ci = function(t) {
        for (var e, i, n = this._pt; n; )
            i = n._next,
            n.p === t && !n.op || n.op === t ? Ct(this, n, "_pt") : n.dep || (e = 1),
            n = i;
        return !e
    }
      , hi = function(t, e, i, n) {
        n.mSet(t, e, n.m.call(n.tween, i, n.mt), n)
    }
      , ui = function(t) {
        for (var e, i, n, r, s = t._pt; s; ) {
            for (e = s._next,
            i = n; i && i.pr > s.pr; )
                i = i._next;
            (s._prev = i ? i._prev : r) ? s._prev._next = s : n = s,
            (s._next = i) ? i._prev = s : r = s,
            s = e
        }
        t._pt = n
    }
      , di = function() {
        function t(t, e, i, n, r, s, a, o, l) {
            this.t = e,
            this.s = n,
            this.c = r,
            this.p = i,
            this.r = s || ri,
            this.d = a || this,
            this.set = o || Ke,
            this.pr = l || 0,
            this._next = t,
            t && (t._prev = this)
        }
        return t.prototype.modifier = function(t, e, i) {
            this.mSet = this.mSet || this.set,
            this.set = hi,
            this.m = t,
            this.mt = i,
            this.tween = e
        }
        ,
        t
    }();
    ft(ht + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function(t) {
        return nt[t] = 1
    }
    )),
    j.TweenMax = j.TweenLite = $e,
    j.TimelineLite = j.TimelineMax = Ue,
    s = new Ue({
        sortChildren: !1,
        defaults: _,
        autoRemoveChildren: !0,
        id: "root",
        smoothChildTiming: !0
    }),
    x.stringFilter = Te;
    var pi = []
      , fi = {}
      , mi = []
      , gi = 0
      , vi = 0
      , yi = function(t) {
        return (fi[t] || mi).map((function(t) {
            return t()
        }
        ))
    }
      , xi = function() {
        var t = Date.now()
          , e = [];
        t - gi > 2 && (yi("matchMediaInit"),
        pi.forEach((function(t) {
            var i, n, r, s, o = t.queries, l = t.conditions;
            for (n in o)
                (i = a.matchMedia(o[n]).matches) && (r = 1),
                i !== l[n] && (l[n] = i,
                s = 1);
            s && (t.revert(),
            r && e.push(t))
        }
        )),
        yi("matchMediaRevert"),
        e.forEach((function(t) {
            return t.onMatch(t, (function(e) {
                return t.add(null, e)
            }
            ))
        }
        )),
        gi = t,
        yi("matchMedia"))
    }
      , _i = function() {
        function t(t, e) {
            this.selector = e && ne(e),
            this.data = [],
            this._r = [],
            this.isReverted = !1,
            this.id = vi++,
            t && this.add(t)
        }
        var e = t.prototype;
        return e.add = function(t, e, i) {
            P(t) && (i = e,
            e = t,
            t = P);
            var n = this
              , s = function() {
                var t, s = r, a = n.selector;
                return s && s !== n && s.data.push(n),
                i && (n.selector = ne(i)),
                r = n,
                t = e.apply(n, arguments),
                P(t) && n._r.push(t),
                r = s,
                n.selector = a,
                n.isReverted = !1,
                t
            };
            return n.last = s,
            t === P ? s(n, (function(t) {
                return n.add(null, t)
            }
            )) : t ? n[t] = s : s
        }
        ,
        e.ignore = function(t) {
            var e = r;
            r = null,
            t(this),
            r = e
        }
        ,
        e.getTweens = function() {
            var e = [];
            return this.data.forEach((function(i) {
                return i instanceof t ? e.push.apply(e, i.getTweens()) : i instanceof $e && !(i.parent && "nested" === i.parent.data) && e.push(i)
            }
            )),
            e
        }
        ,
        e.clear = function() {
            this._r.length = this.data.length = 0
        }
        ,
        e.kill = function(t, e) {
            var i = this;
            if (t ? function() {
                for (var e, n = i.getTweens(), r = i.data.length; r--; )
                    "isFlip" === (e = i.data[r]).data && (e.revert(),
                    e.getChildren(!0, !0, !1).forEach((function(t) {
                        return n.splice(n.indexOf(t), 1)
                    }
                    )));
                for (n.map((function(t) {
                    return {
                        g: t._dur || t._delay || t._sat && !t._sat.vars.immediateRender ? t.globalTime(0) : -1 / 0,
                        t: t
                    }
                }
                )).sort((function(t, e) {
                    return e.g - t.g || -1 / 0
                }
                )).forEach((function(e) {
                    return e.t.revert(t)
                }
                )),
                r = i.data.length; r--; )
                    (e = i.data[r])instanceof Ue ? "nested" !== e.data && (e.scrollTrigger && e.scrollTrigger.revert(),
                    e.kill()) : !(e instanceof $e) && e.revert && e.revert(t);
                i._r.forEach((function(e) {
                    return e(t, i)
                }
                )),
                i.isReverted = !0
            }() : this.data.forEach((function(t) {
                return t.kill && t.kill()
            }
            )),
            this.clear(),
            e)
                for (var n = pi.length; n--; )
                    pi[n].id === this.id && pi.splice(n, 1)
        }
        ,
        e.revert = function(t) {
            this.kill(t || {})
        }
        ,
        t
    }()
      , wi = function() {
        function t(t) {
            this.contexts = [],
            this.scope = t,
            r && r.data.push(this)
        }
        var e = t.prototype;
        return e.add = function(t, e, i) {
            D(t) || (t = {
                matches: t
            });
            var n, s, o, l = new _i(0,i || this.scope), c = l.conditions = {};
            for (s in r && !l.selector && (l.selector = r.selector),
            this.contexts.push(l),
            e = l.add("onMatch", e),
            l.queries = t,
            t)
                "all" === s ? o = 1 : (n = a.matchMedia(t[s])) && (pi.indexOf(l) < 0 && pi.push(l),
                (c[s] = n.matches) && (o = 1),
                n.addListener ? n.addListener(xi) : n.addEventListener("change", xi));
            return o && e(l, (function(t) {
                return l.add(null, t)
            }
            )),
            this
        }
        ,
        e.revert = function(t) {
            this.kill(t || {})
        }
        ,
        e.kill = function(t) {
            this.contexts.forEach((function(e) {
                return e.kill(t, !0)
            }
            ))
        }
        ,
        t
    }()
      , bi = {
        registerPlugin: function() {
            for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++)
                e[i] = arguments[i];
            e.forEach((function(t) {
                return ge(t)
            }
            ))
        },
        timeline: function(t) {
            return new Ue(t)
        },
        getTweensOf: function(t, e) {
            return s.getTweensOf(t, e)
        },
        getProperty: function(t, e, i, n) {
            C(t) && (t = ie(t)[0]);
            var r = dt(t || {}).get
              , s = i ? bt : wt;
            return "native" === i && (i = ""),
            t ? e ? s((at[e] && at[e].get || r)(t, e, i, n)) : function(e, i, n) {
                return s((at[e] && at[e].get || r)(t, e, i, n))
            }
            : t
        },
        quickSetter: function(t, e, i) {
            if ((t = ie(t)).length > 1) {
                var n = t.map((function(t) {
                    return Ti.quickSetter(t, e, i)
                }
                ))
                  , r = n.length;
                return function(t) {
                    for (var e = r; e--; )
                        n[e](t)
                }
            }
            t = t[0] || {};
            var s = at[e]
              , a = dt(t)
              , o = a.harness && (a.harness.aliases || {})[e] || e
              , l = s ? function(e) {
                var n = new s;
                u._pt = 0,
                n.init(t, i ? e + i : e, u, 0, [t]),
                n.render(1, n),
                u._pt && oi(1, u)
            }
            : a.set(t, o);
            return s ? l : function(e) {
                return l(t, o, i ? e + i : e, a, 1)
            }
        },
        quickTo: function(t, e, i) {
            var n, r = Ti.to(t, St(((n = {})[e] = "+=0.1",
            n.paused = !0,
            n), i || {})), s = function(t, i, n) {
                return r.resetTo(e, t, i, n)
            };
            return s.tween = r,
            s
        },
        isTweening: function(t) {
            return s.getTweensOf(t, !0).length > 0
        },
        defaults: function(t) {
            return t && t.ease && (t.ease = Ne(t.ease, _.ease)),
            Tt(_, t || {})
        },
        config: function(t) {
            return Tt(x, t || {})
        },
        registerEffect: function(t) {
            var e = t.name
              , i = t.effect
              , n = t.plugins
              , r = t.defaults
              , s = t.extendTimeline;
            (n || "").split(",").forEach((function(t) {
                return t && !at[t] && !j[t] && Z(e + " effect requires " + t + " plugin.")
            }
            )),
            ot[e] = function(t, e, n) {
                return i(ie(t), Mt(e || {}, r), n)
            }
            ,
            s && (Ue.prototype[e] = function(t, i, n) {
                return this.add(ot[e](t, D(i) ? i : (n = i) && {}, this), n)
            }
            )
        },
        registerEase: function(t, e) {
            Ae[t] = Ne(e)
        },
        parseEase: function(t, e) {
            return arguments.length ? Ne(t, e) : Ae
        },
        getById: function(t) {
            return s.getById(t)
        },
        exportRoot: function(t, e) {
            void 0 === t && (t = {});
            var i, n, r = new Ue(t);
            for (r.smoothChildTiming = N(t.smoothChildTiming),
            s.remove(r),
            r._dp = 0,
            r._time = r._tTime = s._time,
            i = s._first; i; )
                n = i._next,
                !e && !i._dur && i instanceof $e && i.vars.onComplete === i._targets[0] || Ht(r, i, i._start - i._delay),
                i = n;
            return Ht(s, r, 0),
            r
        },
        context: function(t, e) {
            return t ? new _i(t,e) : r
        },
        matchMedia: function(t) {
            return new wi(t)
        },
        matchMediaRefresh: function() {
            return pi.forEach((function(t) {
                var e, i, n = t.conditions;
                for (i in n)
                    n[i] && (n[i] = !1,
                    e = 1);
                e && t.revert()
            }
            )) || xi()
        },
        addEventListener: function(t, e) {
            var i = fi[t] || (fi[t] = []);
            ~i.indexOf(e) || i.push(e)
        },
        removeEventListener: function(t, e) {
            var i = fi[t]
              , n = i && i.indexOf(e);
            n >= 0 && i.splice(n, 1)
        },
        utils: {
            wrap: function t(e, i, n) {
                var r = i - e;
                return B(e) ? ce(e, t(0, e.length), i) : Zt(n, (function(t) {
                    return (r + (t - e) % r) % r + e
                }
                ))
            },
            wrapYoyo: function t(e, i, n) {
                var r = i - e
                  , s = 2 * r;
                return B(e) ? ce(e, t(0, e.length - 1), i) : Zt(n, (function(t) {
                    return e + ((t = (s + (t - e) % s) % s || 0) > r ? s - t : t)
                }
                ))
            },
            distribute: se,
            random: le,
            snap: oe,
            normalize: function(t, e, i) {
                return ue(t, e, 0, 1, i)
            },
            getUnit: $t,
            clamp: function(t, e, i) {
                return Zt(i, (function(i) {
                    return Qt(t, e, i)
                }
                ))
            },
            splitColor: _e,
            toArray: ie,
            selector: ne,
            mapRange: ue,
            pipe: function() {
                for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++)
                    e[i] = arguments[i];
                return function(t) {
                    return e.reduce((function(t, e) {
                        return e(t)
                    }
                    ), t)
                }
            },
            unitize: function(t, e) {
                return function(i) {
                    return t(parseFloat(i)) + (e || $t(i))
                }
            },
            interpolate: function t(e, i, n, r) {
                var s = isNaN(e + i) ? 0 : function(t) {
                    return (1 - t) * e + t * i
                }
                ;
                if (!s) {
                    var a, o, l, c, h, u = C(e), d = {};
                    if (!0 === n && (r = 1) && (n = null),
                    u)
                        e = {
                            p: e
                        },
                        i = {
                            p: i
                        };
                    else if (B(e) && !B(i)) {
                        for (l = [],
                        c = e.length,
                        h = c - 2,
                        o = 1; o < c; o++)
                            l.push(t(e[o - 1], e[o]));
                        c--,
                        s = function(t) {
                            t *= c;
                            var e = Math.min(h, ~~t);
                            return l[e](t - e)
                        }
                        ,
                        n = i
                    } else
                        r || (e = St(B(e) ? [] : {}, e));
                    if (!l) {
                        for (a in i)
                            qe.call(d, e, a, "get", i[a]);
                        s = function(t) {
                            return oi(t, d) || (u ? e.p : e)
                        }
                    }
                }
                return Zt(n, s)
            },
            shuffle: re
        },
        install: X,
        effects: ot,
        ticker: Ee,
        updateRoot: Ue.updateRoot,
        plugins: at,
        globalTimeline: s,
        core: {
            PropTween: di,
            globals: Q,
            Tween: $e,
            Timeline: Ue,
            Animation: He,
            getCache: dt,
            _removeLinkedListItem: Ct,
            reverting: function() {
                return n
            },
            context: function(t) {
                return t && r && (r.data.push(t),
                t._ctx = r),
                r
            },
            suppressOverwrites: function(t) {
                return i = t
            }
        }
    };
    ft("to,from,fromTo,delayedCall,set,killTweensOf", (function(t) {
        return bi[t] = $e[t]
    }
    )),
    Ee.add(Ue.updateRoot),
    u = bi.to({}, {
        duration: 0
    });
    var Mi = function(t, e) {
        for (var i = t._pt; i && i.p !== e && i.op !== e && i.fp !== e; )
            i = i._next;
        return i
    }
      , Si = function(t, e) {
        return {
            name: t,
            rawVars: 1,
            init: function(t, i, n) {
                n._onInit = function(t) {
                    var n, r;
                    if (C(i) && (n = {},
                    ft(i, (function(t) {
                        return n[t] = 1
                    }
                    )),
                    i = n),
                    e) {
                        for (r in n = {},
                        i)
                            n[r] = e(i[r]);
                        i = n
                    }
                    !function(t, e) {
                        var i, n, r, s = t._targets;
                        for (i in e)
                            for (n = s.length; n--; )
                                (r = t._ptLookup[n][i]) && (r = r.d) && (r._pt && (r = Mi(r, i)),
                                r && r.modifier && r.modifier(e[i], t, s[n], i))
                    }(t, i)
                }
            }
        }
    }
      , Ti = bi.registerPlugin({
        name: "attr",
        init: function(t, e, i, n, r) {
            var s, a, o;
            for (s in this.tween = i,
            e)
                o = t.getAttribute(s) || "",
                (a = this.add(t, "setAttribute", (o || 0) + "", e[s], n, r, 0, 0, s)).op = s,
                a.b = o,
                this._props.push(s)
        },
        render: function(t, e) {
            for (var i = e._pt; i; )
                n ? i.set(i.t, i.p, i.b, i) : i.r(t, i.d),
                i = i._next
        }
    }, {
        name: "endArray",
        init: function(t, e) {
            for (var i = e.length; i--; )
                this.add(t, i, t[i] || 0, e[i], 0, 0, 0, 0, 0, 1)
        }
    }, Si("roundProps", ae), Si("modifiers"), Si("snap", oe)) || bi;
    $e.version = Ue.version = Ti.version = "3.12.5",
    c = 1,
    O() && Le(),
    Ae.Power0,
    Ae.Power1,
    Ae.Power2,
    Ae.Power3,
    Ae.Power4,
    Ae.Linear,
    Ae.Quad,
    Ae.Cubic,
    Ae.Quart,
    Ae.Quint,
    Ae.Strong,
    Ae.Elastic,
    Ae.Back,
    Ae.SteppedEase,
    Ae.Bounce,
    Ae.Sine,
    Ae.Expo,
    Ae.Circ;
    /*!
   * CSSPlugin 3.12.5
   * https://gsap.com
   *
   * Copyright 2008-2024, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license or for
   * Club GSAP members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */
    var Ei, Li, Ai, Ci, Pi, Ri, Ii, Di, Ni = {}, Oi = 180 / Math.PI, zi = Math.PI / 180, ki = Math.atan2, Bi = /([A-Z])/g, Fi = /(left|right|width|margin|padding|x)/i, Hi = /[\s,\(]\S/, Ui = {
        autoAlpha: "opacity,visibility",
        scale: "scaleX,scaleY",
        alpha: "opacity"
    }, Gi = function(t, e) {
        return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
    }, Vi = function(t, e) {
        return e.set(e.t, e.p, 1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
    }, Wi = function(t, e) {
        return e.set(e.t, e.p, t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b, e)
    }, qi = function(t, e) {
        var i = e.s + e.c * t;
        e.set(e.t, e.p, ~~(i + (i < 0 ? -.5 : .5)) + e.u, e)
    }, ji = function(t, e) {
        return e.set(e.t, e.p, t ? e.e : e.b, e)
    }, Yi = function(t, e) {
        return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e)
    }, Xi = function(t, e, i) {
        return t.style[e] = i
    }, Ji = function(t, e, i) {
        return t.style.setProperty(e, i)
    }, Zi = function(t, e, i) {
        return t._gsap[e] = i
    }, Qi = function(t, e, i) {
        return t._gsap.scaleX = t._gsap.scaleY = i
    }, $i = function(t, e, i, n, r) {
        var s = t._gsap;
        s.scaleX = s.scaleY = i,
        s.renderTransform(r, s)
    }, Ki = function(t, e, i, n, r) {
        var s = t._gsap;
        s[e] = i,
        s.renderTransform(r, s)
    }, tn = "transform", en = tn + "Origin", nn = function t(e, i) {
        var n = this
          , r = this.target
          , s = r.style
          , a = r._gsap;
        if (e in Ni && s) {
            if (this.tfm = this.tfm || {},
            "transform" === e)
                return Ui.transform.split(",").forEach((function(e) {
                    return t.call(n, e, i)
                }
                ));
            if (~(e = Ui[e] || e).indexOf(",") ? e.split(",").forEach((function(t) {
                return n.tfm[t] = wn(r, t)
            }
            )) : this.tfm[e] = a.x ? a[e] : wn(r, e),
            e === en && (this.tfm.zOrigin = a.zOrigin),
            this.props.indexOf(tn) >= 0)
                return;
            a.svg && (this.svgo = r.getAttribute("data-svg-origin"),
            this.props.push(en, i, "")),
            e = tn
        }
        (s || i) && this.props.push(e, i, s[e])
    }, rn = function(t) {
        t.translate && (t.removeProperty("translate"),
        t.removeProperty("scale"),
        t.removeProperty("rotate"))
    }, sn = function() {
        var t, e, i = this.props, n = this.target, r = n.style, s = n._gsap;
        for (t = 0; t < i.length; t += 3)
            i[t + 1] ? n[i[t]] = i[t + 2] : i[t + 2] ? r[i[t]] = i[t + 2] : r.removeProperty("--" === i[t].substr(0, 2) ? i[t] : i[t].replace(Bi, "-$1").toLowerCase());
        if (this.tfm) {
            for (e in this.tfm)
                s[e] = this.tfm[e];
            s.svg && (s.renderTransform(),
            n.setAttribute("data-svg-origin", this.svgo || "")),
            (t = Ii()) && t.isStart || r[tn] || (rn(r),
            s.zOrigin && r[en] && (r[en] += " " + s.zOrigin + "px",
            s.zOrigin = 0,
            s.renderTransform()),
            s.uncache = 1)
        }
    }, an = function(t, e) {
        var i = {
            target: t,
            props: [],
            revert: sn,
            save: nn
        };
        return t._gsap || Ti.core.getCache(t),
        e && e.split(",").forEach((function(t) {
            return i.save(t)
        }
        )),
        i
    }, on = function(t, e) {
        var i = Li.createElementNS ? Li.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : Li.createElement(t);
        return i && i.style ? i : Li.createElement(t)
    }, ln = function t(e, i, n) {
        var r = getComputedStyle(e);
        return r[i] || r.getPropertyValue(i.replace(Bi, "-$1").toLowerCase()) || r.getPropertyValue(i) || !n && t(e, hn(i) || i, 1) || ""
    }, cn = "O,Moz,ms,Ms,Webkit".split(","), hn = function(t, e, i) {
        var n = (e || Pi).style
          , r = 5;
        if (t in n && !i)
            return t;
        for (t = t.charAt(0).toUpperCase() + t.substr(1); r-- && !(cn[r] + t in n); )
            ;
        return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? cn[r] : "") + t
    }, un = function() {
        "undefined" != typeof window && window.document && (Ei = window,
        Li = Ei.document,
        Ai = Li.documentElement,
        Pi = on("div") || {
            style: {}
        },
        on("div"),
        tn = hn(tn),
        en = tn + "Origin",
        Pi.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0",
        Di = !!hn("perspective"),
        Ii = Ti.core.reverting,
        Ci = 1)
    }, dn = function t(e) {
        var i, n = on("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), r = this.parentNode, s = this.nextSibling, a = this.style.cssText;
        if (Ai.appendChild(n),
        n.appendChild(this),
        this.style.display = "block",
        e)
            try {
                i = this.getBBox(),
                this._gsapBBox = this.getBBox,
                this.getBBox = t
            } catch (t) {}
        else
            this._gsapBBox && (i = this._gsapBBox());
        return r && (s ? r.insertBefore(this, s) : r.appendChild(this)),
        Ai.removeChild(n),
        this.style.cssText = a,
        i
    }, pn = function(t, e) {
        for (var i = e.length; i--; )
            if (t.hasAttribute(e[i]))
                return t.getAttribute(e[i])
    }, fn = function(t) {
        var e;
        try {
            e = t.getBBox()
        } catch (i) {
            e = dn.call(t, !0)
        }
        return e && (e.width || e.height) || t.getBBox === dn || (e = dn.call(t, !0)),
        !e || e.width || e.x || e.y ? e : {
            x: +pn(t, ["x", "cx", "x1"]) || 0,
            y: +pn(t, ["y", "cy", "y1"]) || 0,
            width: 0,
            height: 0
        }
    }, mn = function(t) {
        return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !fn(t))
    }, gn = function(t, e) {
        if (e) {
            var i, n = t.style;
            e in Ni && e !== en && (e = tn),
            n.removeProperty ? ("ms" !== (i = e.substr(0, 2)) && "webkit" !== e.substr(0, 6) || (e = "-" + e),
            n.removeProperty("--" === i ? e : e.replace(Bi, "-$1").toLowerCase())) : n.removeAttribute(e)
        }
    }, vn = function(t, e, i, n, r, s) {
        var a = new di(t._pt,e,i,0,1,s ? Yi : ji);
        return t._pt = a,
        a.b = n,
        a.e = r,
        t._props.push(i),
        a
    }, yn = {
        deg: 1,
        rad: 1,
        turn: 1
    }, xn = {
        grid: 1,
        flex: 1
    }, _n = function t(e, i, n, r) {
        var s, a, o, l, c = parseFloat(n) || 0, h = (n + "").trim().substr((c + "").length) || "px", u = Pi.style, d = Fi.test(i), p = "svg" === e.tagName.toLowerCase(), f = (p ? "client" : "offset") + (d ? "Width" : "Height"), m = 100, g = "px" === r, v = "%" === r;
        if (r === h || !c || yn[r] || yn[h])
            return c;
        if ("px" !== h && !g && (c = t(e, i, n, "px")),
        l = e.getCTM && mn(e),
        (v || "%" === h) && (Ni[i] || ~i.indexOf("adius")))
            return s = l ? e.getBBox()[d ? "width" : "height"] : e[f],
            mt(v ? c / s * m : c / 100 * s);
        if (u[d ? "width" : "height"] = m + (g ? h : r),
        a = ~i.indexOf("adius") || "em" === r && e.appendChild && !p ? e : e.parentNode,
        l && (a = (e.ownerSVGElement || {}).parentNode),
        a && a !== Li && a.appendChild || (a = Li.body),
        (o = a._gsap) && v && o.width && d && o.time === Ee.time && !o.uncache)
            return mt(c / o.width * m);
        if (!v || "height" !== i && "width" !== i)
            (v || "%" === h) && !xn[ln(a, "display")] && (u.position = ln(e, "position")),
            a === e && (u.position = "static"),
            a.appendChild(Pi),
            s = Pi[f],
            a.removeChild(Pi),
            u.position = "absolute";
        else {
            var y = e.style[i];
            e.style[i] = m + r,
            s = e[f],
            y ? e.style[i] = y : gn(e, i)
        }
        return d && v && ((o = dt(a)).time = Ee.time,
        o.width = a[f]),
        mt(g ? s * c / m : s && c ? m / s * c : 0)
    }, wn = function(t, e, i, n) {
        var r;
        return Ci || un(),
        e in Ui && "transform" !== e && ~(e = Ui[e]).indexOf(",") && (e = e.split(",")[0]),
        Ni[e] && "transform" !== e ? (r = In(t, n),
        r = "transformOrigin" !== e ? r[e] : r.svg ? r.origin : Dn(ln(t, en)) + " " + r.zOrigin + "px") : (!(r = t.style[e]) || "auto" === r || n || ~(r + "").indexOf("calc(")) && (r = Tn[e] && Tn[e](t, e, i) || ln(t, e) || pt(t, e) || ("opacity" === e ? 1 : 0)),
        i && !~(r + "").trim().indexOf(" ") ? _n(t, e, r, i) + i : r
    }, bn = function(t, e, i, n) {
        if (!i || "none" === i) {
            var r = hn(e, t, 1)
              , s = r && ln(t, r, 1);
            s && s !== i ? (e = r,
            i = s) : "borderColor" === e && (i = ln(t, "borderTopColor"))
        }
        var a, o, l, c, h, u, d, p, f, m, g, v = new di(this._pt,t.style,e,0,1,ai), y = 0, _ = 0;
        if (v.b = i,
        v.e = n,
        i += "",
        "auto" === (n += "") && (u = t.style[e],
        t.style[e] = n,
        n = ln(t, e) || n,
        u ? t.style[e] = u : gn(t, e)),
        Te(a = [i, n]),
        i = a[0],
        n = a[1],
        l = i.match(U) || [],
        (n.match(U) || []).length) {
            for (; o = U.exec(n); )
                d = o[0],
                f = n.substring(y, o.index),
                h ? h = (h + 1) % 5 : "rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5) || (h = 1),
                d !== (u = l[_++] || "") && (c = parseFloat(u) || 0,
                g = u.substr((c + "").length),
                "=" === d.charAt(1) && (d = vt(c, d) + g),
                p = parseFloat(d),
                m = d.substr((p + "").length),
                y = U.lastIndex - m.length,
                m || (m = m || x.units[e] || g,
                y === n.length && (n += m,
                v.e += m)),
                g !== m && (c = _n(t, e, u, m) || 0),
                v._pt = {
                    _next: v._pt,
                    p: f || 1 === _ ? f : ",",
                    s: c,
                    c: p - c,
                    m: h && h < 4 || "zIndex" === e ? Math.round : 0
                });
            v.c = y < n.length ? n.substring(y, n.length) : ""
        } else
            v.r = "display" === e && "none" === n ? Yi : ji;
        return V.test(n) && (v.e = 0),
        this._pt = v,
        v
    }, Mn = {
        top: "0%",
        bottom: "100%",
        left: "0%",
        right: "100%",
        center: "50%"
    }, Sn = function(t, e) {
        if (e.tween && e.tween._time === e.tween._dur) {
            var i, n, r, s = e.t, a = s.style, o = e.u, l = s._gsap;
            if ("all" === o || !0 === o)
                a.cssText = "",
                n = 1;
            else
                for (r = (o = o.split(",")).length; --r > -1; )
                    i = o[r],
                    Ni[i] && (n = 1,
                    i = "transformOrigin" === i ? en : tn),
                    gn(s, i);
            n && (gn(s, tn),
            l && (l.svg && s.removeAttribute("transform"),
            In(s, 1),
            l.uncache = 1,
            rn(a)))
        }
    }, Tn = {
        clearProps: function(t, e, i, n, r) {
            if ("isFromStart" !== r.data) {
                var s = t._pt = new di(t._pt,e,i,0,0,Sn);
                return s.u = n,
                s.pr = -10,
                s.tween = r,
                t._props.push(i),
                1
            }
        }
    }, En = [1, 0, 0, 1, 0, 0], Ln = {}, An = function(t) {
        return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t
    }, Cn = function(t) {
        var e = ln(t, tn);
        return An(e) ? En : e.substr(7).match(H).map(mt)
    }, Pn = function(t, e) {
        var i, n, r, s, a = t._gsap || dt(t), o = t.style, l = Cn(t);
        return a.svg && t.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(r = t.transform.baseVal.consolidate().matrix).a, r.b, r.c, r.d, r.e, r.f]).join(",") ? En : l : (l !== En || t.offsetParent || t === Ai || a.svg || (r = o.display,
        o.display = "block",
        (i = t.parentNode) && t.offsetParent || (s = 1,
        n = t.nextElementSibling,
        Ai.appendChild(t)),
        l = Cn(t),
        r ? o.display = r : gn(t, "display"),
        s && (n ? i.insertBefore(t, n) : i ? i.appendChild(t) : Ai.removeChild(t))),
        e && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l)
    }, Rn = function(t, e, i, n, r, s) {
        var a, o, l, c = t._gsap, h = r || Pn(t, !0), u = c.xOrigin || 0, d = c.yOrigin || 0, p = c.xOffset || 0, f = c.yOffset || 0, m = h[0], g = h[1], v = h[2], y = h[3], x = h[4], _ = h[5], w = e.split(" "), b = parseFloat(w[0]) || 0, M = parseFloat(w[1]) || 0;
        i ? h !== En && (o = m * y - g * v) && (l = b * (-g / o) + M * (m / o) - (m * _ - g * x) / o,
        b = b * (y / o) + M * (-v / o) + (v * _ - y * x) / o,
        M = l) : (b = (a = fn(t)).x + (~w[0].indexOf("%") ? b / 100 * a.width : b),
        M = a.y + (~(w[1] || w[0]).indexOf("%") ? M / 100 * a.height : M)),
        n || !1 !== n && c.smooth ? (x = b - u,
        _ = M - d,
        c.xOffset = p + (x * m + _ * v) - x,
        c.yOffset = f + (x * g + _ * y) - _) : c.xOffset = c.yOffset = 0,
        c.xOrigin = b,
        c.yOrigin = M,
        c.smooth = !!n,
        c.origin = e,
        c.originIsAbsolute = !!i,
        t.style[en] = "0px 0px",
        s && (vn(s, c, "xOrigin", u, b),
        vn(s, c, "yOrigin", d, M),
        vn(s, c, "xOffset", p, c.xOffset),
        vn(s, c, "yOffset", f, c.yOffset)),
        t.setAttribute("data-svg-origin", b + " " + M)
    }, In = function(t, e) {
        var i = t._gsap || new Fe(t);
        if ("x"in i && !e && !i.uncache)
            return i;
        var n, r, s, a, o, l, c, h, u, d, p, f, m, g, v, y, _, w, b, M, S, T, E, L, A, C, P, R, I, D, N, O, z = t.style, k = i.scaleX < 0, B = "px", F = "deg", H = getComputedStyle(t), U = ln(t, en) || "0";
        return n = r = s = l = c = h = u = d = p = 0,
        a = o = 1,
        i.svg = !(!t.getCTM || !mn(t)),
        H.translate && ("none" === H.translate && "none" === H.scale && "none" === H.rotate || (z[tn] = ("none" !== H.translate ? "translate3d(" + (H.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + ("none" !== H.rotate ? "rotate(" + H.rotate + ") " : "") + ("none" !== H.scale ? "scale(" + H.scale.split(" ").join(",") + ") " : "") + ("none" !== H[tn] ? H[tn] : "")),
        z.scale = z.rotate = z.translate = "none"),
        g = Pn(t, i.svg),
        i.svg && (i.uncache ? (A = t.getBBox(),
        U = i.xOrigin - A.x + "px " + (i.yOrigin - A.y) + "px",
        L = "") : L = !e && t.getAttribute("data-svg-origin"),
        Rn(t, L || U, !!L || i.originIsAbsolute, !1 !== i.smooth, g)),
        f = i.xOrigin || 0,
        m = i.yOrigin || 0,
        g !== En && (w = g[0],
        b = g[1],
        M = g[2],
        S = g[3],
        n = T = g[4],
        r = E = g[5],
        6 === g.length ? (a = Math.sqrt(w * w + b * b),
        o = Math.sqrt(S * S + M * M),
        l = w || b ? ki(b, w) * Oi : 0,
        (u = M || S ? ki(M, S) * Oi + l : 0) && (o *= Math.abs(Math.cos(u * zi))),
        i.svg && (n -= f - (f * w + m * M),
        r -= m - (f * b + m * S))) : (O = g[6],
        D = g[7],
        P = g[8],
        R = g[9],
        I = g[10],
        N = g[11],
        n = g[12],
        r = g[13],
        s = g[14],
        c = (v = ki(O, I)) * Oi,
        v && (L = T * (y = Math.cos(-v)) + P * (_ = Math.sin(-v)),
        A = E * y + R * _,
        C = O * y + I * _,
        P = T * -_ + P * y,
        R = E * -_ + R * y,
        I = O * -_ + I * y,
        N = D * -_ + N * y,
        T = L,
        E = A,
        O = C),
        h = (v = ki(-M, I)) * Oi,
        v && (y = Math.cos(-v),
        N = S * (_ = Math.sin(-v)) + N * y,
        w = L = w * y - P * _,
        b = A = b * y - R * _,
        M = C = M * y - I * _),
        l = (v = ki(b, w)) * Oi,
        v && (L = w * (y = Math.cos(v)) + b * (_ = Math.sin(v)),
        A = T * y + E * _,
        b = b * y - w * _,
        E = E * y - T * _,
        w = L,
        T = A),
        c && Math.abs(c) + Math.abs(l) > 359.9 && (c = l = 0,
        h = 180 - h),
        a = mt(Math.sqrt(w * w + b * b + M * M)),
        o = mt(Math.sqrt(E * E + O * O)),
        v = ki(T, E),
        u = Math.abs(v) > 2e-4 ? v * Oi : 0,
        p = N ? 1 / (N < 0 ? -N : N) : 0),
        i.svg && (L = t.getAttribute("transform"),
        i.forceCSS = t.setAttribute("transform", "") || !An(ln(t, tn)),
        L && t.setAttribute("transform", L))),
        Math.abs(u) > 90 && Math.abs(u) < 270 && (k ? (a *= -1,
        u += l <= 0 ? 180 : -180,
        l += l <= 0 ? 180 : -180) : (o *= -1,
        u += u <= 0 ? 180 : -180)),
        e = e || i.uncache,
        i.x = n - ((i.xPercent = n && (!e && i.xPercent || (Math.round(t.offsetWidth / 2) === Math.round(-n) ? -50 : 0))) ? t.offsetWidth * i.xPercent / 100 : 0) + B,
        i.y = r - ((i.yPercent = r && (!e && i.yPercent || (Math.round(t.offsetHeight / 2) === Math.round(-r) ? -50 : 0))) ? t.offsetHeight * i.yPercent / 100 : 0) + B,
        i.z = s + B,
        i.scaleX = mt(a),
        i.scaleY = mt(o),
        i.rotation = mt(l) + F,
        i.rotationX = mt(c) + F,
        i.rotationY = mt(h) + F,
        i.skewX = u + F,
        i.skewY = d + F,
        i.transformPerspective = p + B,
        (i.zOrigin = parseFloat(U.split(" ")[2]) || !e && i.zOrigin || 0) && (z[en] = Dn(U)),
        i.xOffset = i.yOffset = 0,
        i.force3D = x.force3D,
        i.renderTransform = i.svg ? Hn : Di ? Fn : On,
        i.uncache = 0,
        i
    }, Dn = function(t) {
        return (t = t.split(" "))[0] + " " + t[1]
    }, Nn = function(t, e, i) {
        var n = $t(e);
        return mt(parseFloat(e) + parseFloat(_n(t, "x", i + "px", n))) + n
    }, On = function(t, e) {
        e.z = "0px",
        e.rotationY = e.rotationX = "0deg",
        e.force3D = 0,
        Fn(t, e)
    }, zn = "0deg", kn = "0px", Bn = ") ", Fn = function(t, e) {
        var i = e || this
          , n = i.xPercent
          , r = i.yPercent
          , s = i.x
          , a = i.y
          , o = i.z
          , l = i.rotation
          , c = i.rotationY
          , h = i.rotationX
          , u = i.skewX
          , d = i.skewY
          , p = i.scaleX
          , f = i.scaleY
          , m = i.transformPerspective
          , g = i.force3D
          , v = i.target
          , y = i.zOrigin
          , x = ""
          , _ = "auto" === g && t && 1 !== t || !0 === g;
        if (y && (h !== zn || c !== zn)) {
            var w, b = parseFloat(c) * zi, M = Math.sin(b), S = Math.cos(b);
            b = parseFloat(h) * zi,
            w = Math.cos(b),
            s = Nn(v, s, M * w * -y),
            a = Nn(v, a, -Math.sin(b) * -y),
            o = Nn(v, o, S * w * -y + y)
        }
        m !== kn && (x += "perspective(" + m + Bn),
        (n || r) && (x += "translate(" + n + "%, " + r + "%) "),
        (_ || s !== kn || a !== kn || o !== kn) && (x += o !== kn || _ ? "translate3d(" + s + ", " + a + ", " + o + ") " : "translate(" + s + ", " + a + Bn),
        l !== zn && (x += "rotate(" + l + Bn),
        c !== zn && (x += "rotateY(" + c + Bn),
        h !== zn && (x += "rotateX(" + h + Bn),
        u === zn && d === zn || (x += "skew(" + u + ", " + d + Bn),
        1 === p && 1 === f || (x += "scale(" + p + ", " + f + Bn),
        v.style[tn] = x || "translate(0, 0)"
    }, Hn = function(t, e) {
        var i, n, r, s, a, o = e || this, l = o.xPercent, c = o.yPercent, h = o.x, u = o.y, d = o.rotation, p = o.skewX, f = o.skewY, m = o.scaleX, g = o.scaleY, v = o.target, y = o.xOrigin, x = o.yOrigin, _ = o.xOffset, w = o.yOffset, b = o.forceCSS, M = parseFloat(h), S = parseFloat(u);
        d = parseFloat(d),
        p = parseFloat(p),
        (f = parseFloat(f)) && (p += f = parseFloat(f),
        d += f),
        d || p ? (d *= zi,
        p *= zi,
        i = Math.cos(d) * m,
        n = Math.sin(d) * m,
        r = Math.sin(d - p) * -g,
        s = Math.cos(d - p) * g,
        p && (f *= zi,
        a = Math.tan(p - f),
        r *= a = Math.sqrt(1 + a * a),
        s *= a,
        f && (a = Math.tan(f),
        i *= a = Math.sqrt(1 + a * a),
        n *= a)),
        i = mt(i),
        n = mt(n),
        r = mt(r),
        s = mt(s)) : (i = m,
        s = g,
        n = r = 0),
        (M && !~(h + "").indexOf("px") || S && !~(u + "").indexOf("px")) && (M = _n(v, "x", h, "px"),
        S = _n(v, "y", u, "px")),
        (y || x || _ || w) && (M = mt(M + y - (y * i + x * r) + _),
        S = mt(S + x - (y * n + x * s) + w)),
        (l || c) && (a = v.getBBox(),
        M = mt(M + l / 100 * a.width),
        S = mt(S + c / 100 * a.height)),
        a = "matrix(" + i + "," + n + "," + r + "," + s + "," + M + "," + S + ")",
        v.setAttribute("transform", a),
        b && (v.style[tn] = a)
    }, Un = function(t, e, i, n, r) {
        var s, a, o = 360, l = C(r), c = parseFloat(r) * (l && ~r.indexOf("rad") ? Oi : 1) - n, h = n + c + "deg";
        return l && ("short" === (s = r.split("_")[1]) && (c %= o) !== c % 180 && (c += c < 0 ? o : -360),
        "cw" === s && c < 0 ? c = (c + 36e9) % o - ~~(c / o) * o : "ccw" === s && c > 0 && (c = (c - 36e9) % o - ~~(c / o) * o)),
        t._pt = a = new di(t._pt,e,i,n,c,Vi),
        a.e = h,
        a.u = "deg",
        t._props.push(i),
        a
    }, Gn = function(t, e) {
        for (var i in e)
            t[i] = e[i];
        return t
    }, Vn = function(t, e, i) {
        var n, r, s, a, o, l, c, h = Gn({}, i._gsap), u = i.style;
        for (r in h.svg ? (s = i.getAttribute("transform"),
        i.setAttribute("transform", ""),
        u[tn] = e,
        n = In(i, 1),
        gn(i, tn),
        i.setAttribute("transform", s)) : (s = getComputedStyle(i)[tn],
        u[tn] = e,
        n = In(i, 1),
        u[tn] = s),
        Ni)
            (s = h[r]) !== (a = n[r]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 && (o = $t(s) !== (c = $t(a)) ? _n(i, r, s, c) : parseFloat(s),
            l = parseFloat(a),
            t._pt = new di(t._pt,n,r,o,l - o,Gi),
            t._pt.u = c || 0,
            t._props.push(r));
        Gn(n, h)
    };
    ft("padding,margin,Width,Radius", (function(t, e) {
        var i = "Top"
          , n = "Right"
          , r = "Bottom"
          , s = "Left"
          , a = (e < 3 ? [i, n, r, s] : [i + s, i + n, r + n, r + s]).map((function(i) {
            return e < 2 ? t + i : "border" + i + t
        }
        ));
        Tn[e > 1 ? "border" + t : t] = function(t, e, i, n, r) {
            var s, o;
            if (arguments.length < 4)
                return s = a.map((function(e) {
                    return wn(t, e, i)
                }
                )),
                5 === (o = s.join(" ")).split(s[0]).length ? s[0] : o;
            s = (n + "").split(" "),
            o = {},
            a.forEach((function(t, e) {
                return o[t] = s[e] = s[e] || s[(e - 1) / 2 | 0]
            }
            )),
            t.init(e, o, r)
        }
    }
    ));
    var Wn, qn, jn, Yn = {
        name: "css",
        register: un,
        targetTest: function(t) {
            return t.style && t.nodeType
        },
        init: function(t, e, i, n, r) {
            var s, a, o, l, c, h, u, d, p, f, m, g, v, y, _, w, b, M, S, T, E = this._props, L = t.style, A = i.vars.startAt;
            for (u in Ci || un(),
            this.styles = this.styles || an(t),
            w = this.styles.props,
            this.tween = i,
            e)
                if ("autoRound" !== u && (a = e[u],
                !at[u] || !je(u, e, i, n, t, r)))
                    if (c = typeof a,
                    h = Tn[u],
                    "function" === c && (c = typeof (a = a.call(i, n, t, r))),
                    "string" === c && ~a.indexOf("random(") && (a = he(a)),
                    h)
                        h(this, t, u, a, i) && (_ = 1);
                    else if ("--" === u.substr(0, 2))
                        s = (getComputedStyle(t).getPropertyValue(u) + "").trim(),
                        a += "",
                        Me.lastIndex = 0,
                        Me.test(s) || (d = $t(s),
                        p = $t(a)),
                        p ? d !== p && (s = _n(t, u, s, p) + p) : d && (a += d),
                        this.add(L, "setProperty", s, a, n, r, 0, 0, u),
                        E.push(u),
                        w.push(u, 0, L[u]);
                    else if ("undefined" !== c) {
                        if (A && u in A ? (s = "function" == typeof A[u] ? A[u].call(i, n, t, r) : A[u],
                        C(s) && ~s.indexOf("random(") && (s = he(s)),
                        $t(s + "") || "auto" === s || (s += x.units[u] || $t(wn(t, u)) || ""),
                        "=" === (s + "").charAt(1) && (s = wn(t, u))) : s = wn(t, u),
                        l = parseFloat(s),
                        (f = "string" === c && "=" === a.charAt(1) && a.substr(0, 2)) && (a = a.substr(2)),
                        o = parseFloat(a),
                        u in Ui && ("autoAlpha" === u && (1 === l && "hidden" === wn(t, "visibility") && o && (l = 0),
                        w.push("visibility", 0, L.visibility),
                        vn(this, L, "visibility", l ? "inherit" : "hidden", o ? "inherit" : "hidden", !o)),
                        "scale" !== u && "transform" !== u && ~(u = Ui[u]).indexOf(",") && (u = u.split(",")[0])),
                        m = u in Ni)
                            if (this.styles.save(u),
                            g || ((v = t._gsap).renderTransform && !e.parseTransform || In(t, e.parseTransform),
                            y = !1 !== e.smoothOrigin && v.smooth,
                            (g = this._pt = new di(this._pt,L,tn,0,1,v.renderTransform,v,0,-1)).dep = 1),
                            "scale" === u)
                                this._pt = new di(this._pt,v,"scaleY",v.scaleY,(f ? vt(v.scaleY, f + o) : o) - v.scaleY || 0,Gi),
                                this._pt.u = 0,
                                E.push("scaleY", u),
                                u += "X";
                            else {
                                if ("transformOrigin" === u) {
                                    w.push(en, 0, L[en]),
                                    M = void 0,
                                    S = void 0,
                                    T = void 0,
                                    M = (b = a).split(" "),
                                    S = M[0],
                                    T = M[1] || "50%",
                                    "top" !== S && "bottom" !== S && "left" !== T && "right" !== T || (b = S,
                                    S = T,
                                    T = b),
                                    M[0] = Mn[S] || S,
                                    M[1] = Mn[T] || T,
                                    a = M.join(" "),
                                    v.svg ? Rn(t, a, 0, y, 0, this) : ((p = parseFloat(a.split(" ")[2]) || 0) !== v.zOrigin && vn(this, v, "zOrigin", v.zOrigin, p),
                                    vn(this, L, u, Dn(s), Dn(a)));
                                    continue
                                }
                                if ("svgOrigin" === u) {
                                    Rn(t, a, 1, y, 0, this);
                                    continue
                                }
                                if (u in Ln) {
                                    Un(this, v, u, l, f ? vt(l, f + a) : a);
                                    continue
                                }
                                if ("smoothOrigin" === u) {
                                    vn(this, v, "smooth", v.smooth, a);
                                    continue
                                }
                                if ("force3D" === u) {
                                    v[u] = a;
                                    continue
                                }
                                if ("transform" === u) {
                                    Vn(this, a, t);
                                    continue
                                }
                            }
                        else
                            u in L || (u = hn(u) || u);
                        if (m || (o || 0 === o) && (l || 0 === l) && !Hi.test(a) && u in L)
                            o || (o = 0),
                            (d = (s + "").substr((l + "").length)) !== (p = $t(a) || (u in x.units ? x.units[u] : d)) && (l = _n(t, u, s, p)),
                            this._pt = new di(this._pt,m ? v : L,u,l,(f ? vt(l, f + o) : o) - l,m || "px" !== p && "zIndex" !== u || !1 === e.autoRound ? Gi : qi),
                            this._pt.u = p || 0,
                            d !== p && "%" !== p && (this._pt.b = s,
                            this._pt.r = Wi);
                        else if (u in L)
                            bn.call(this, t, u, s, f ? f + a : a);
                        else if (u in t)
                            this.add(t, u, s || t[u], f ? f + a : a, n, r);
                        else if ("parseTransform" !== u) {
                            J(u, a);
                            continue
                        }
                        m || (u in L ? w.push(u, 0, L[u]) : w.push(u, 1, s || t[u])),
                        E.push(u)
                    }
            _ && ui(this)
        },
        render: function(t, e) {
            if (e.tween._time || !Ii())
                for (var i = e._pt; i; )
                    i.r(t, i.d),
                    i = i._next;
            else
                e.styles.revert()
        },
        get: wn,
        aliases: Ui,
        getSetter: function(t, e, i) {
            var n = Ui[e];
            return n && n.indexOf(",") < 0 && (e = n),
            e in Ni && e !== en && (t._gsap.x || wn(t, "x")) ? i && Ri === i ? "scale" === e ? Qi : Zi : (Ri = i || {}) && ("scale" === e ? $i : Ki) : t.style && !I(t.style[e]) ? Xi : ~e.indexOf("-") ? Ji : ni(t, e)
        },
        core: {
            _removeProperty: gn,
            _getMatrix: Pn
        }
    };
    Ti.utils.checkPrefix = hn,
    Ti.core.getStyleSaver = an,
    jn = ft((Wn = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent") + "," + (qn = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function(t) {
        Ni[t] = 1
    }
    )),
    ft(qn, (function(t) {
        x.units[t] = "deg",
        Ln[t] = 1
    }
    )),
    Ui[jn[13]] = Wn + "," + qn,
    ft("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function(t) {
        var e = t.split(":");
        Ui[e[1]] = jn[e[0]]
    }
    )),
    ft("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function(t) {
        x.units[t] = "px"
    }
    )),
    Ti.registerPlugin(Yn);
    var Xn = Ti.registerPlugin(Yn) || Ti;
    function Jn(t, e) {
        for (var i = 0; i < e.length; i++) {
            var n = e[i];
            n.enumerable = n.enumerable || !1,
            n.configurable = !0,
            "value"in n && (n.writable = !0),
            Object.defineProperty(t, n.key, n)
        }
    }
    Xn.core.Tween;
    /*!
   * Observer 3.12.5
   * https://gsap.com
   *
   * @license Copyright 2008-2024, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license or for
   * Club GSAP members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */
    var Zn, Qn, $n, Kn, tr, er, ir, nr, rr, sr, ar, or, lr, cr = function() {
        return Zn || "undefined" != typeof window && (Zn = window.gsap) && Zn.registerPlugin && Zn
    }, hr = 1, ur = [], dr = [], pr = [], fr = Date.now, mr = function(t, e) {
        return e
    }, gr = function(t, e) {
        return ~pr.indexOf(t) && pr[pr.indexOf(t) + 1][e]
    }, vr = function(t) {
        return !!~sr.indexOf(t)
    }, yr = function(t, e, i, n, r) {
        return t.addEventListener(e, i, {
            passive: !1 !== n,
            capture: !!r
        })
    }, xr = function(t, e, i, n) {
        return t.removeEventListener(e, i, !!n)
    }, _r = "scrollLeft", wr = "scrollTop", br = function() {
        return ar && ar.isPressed || dr.cache++
    }, Mr = function(t, e) {
        var i = function i(n) {
            if (n || 0 === n) {
                hr && ($n.history.scrollRestoration = "manual");
                var r = ar && ar.isPressed;
                n = i.v = Math.round(n) || (ar && ar.iOS ? 1 : 0),
                t(n),
                i.cacheID = dr.cache,
                r && mr("ss", n)
            } else
                (e || dr.cache !== i.cacheID || mr("ref")) && (i.cacheID = dr.cache,
                i.v = t());
            return i.v + i.offset
        };
        return i.offset = 0,
        t && i
    }, Sr = {
        s: _r,
        p: "left",
        p2: "Left",
        os: "right",
        os2: "Right",
        d: "width",
        d2: "Width",
        a: "x",
        sc: Mr((function(t) {
            return arguments.length ? $n.scrollTo(t, Tr.sc()) : $n.pageXOffset || Kn[_r] || tr[_r] || er[_r] || 0
        }
        ))
    }, Tr = {
        s: wr,
        p: "top",
        p2: "Top",
        os: "bottom",
        os2: "Bottom",
        d: "height",
        d2: "Height",
        a: "y",
        op: Sr,
        sc: Mr((function(t) {
            return arguments.length ? $n.scrollTo(Sr.sc(), t) : $n.pageYOffset || Kn[wr] || tr[wr] || er[wr] || 0
        }
        ))
    }, Er = function(t, e) {
        return (e && e._ctx && e._ctx.selector || Zn.utils.toArray)(t)[0] || ("string" == typeof t && !1 !== Zn.config().nullTargetWarn ? console.warn("Element not found:", t) : null)
    }, Lr = function(t, e) {
        var i = e.s
          , n = e.sc;
        vr(t) && (t = Kn.scrollingElement || tr);
        var r = dr.indexOf(t)
          , s = n === Tr.sc ? 1 : 2;
        !~r && (r = dr.push(t) - 1),
        dr[r + s] || yr(t, "scroll", br);
        var a = dr[r + s]
          , o = a || (dr[r + s] = Mr(gr(t, i), !0) || (vr(t) ? n : Mr((function(e) {
            return arguments.length ? t[i] = e : t[i]
        }
        ))));
        return o.target = t,
        a || (o.smooth = "smooth" === Zn.getProperty(t, "scrollBehavior")),
        o
    }, Ar = function(t, e, i) {
        var n = t
          , r = t
          , s = fr()
          , a = s
          , o = e || 50
          , l = Math.max(500, 3 * o)
          , c = function(t, e) {
            var l = fr();
            e || l - s > o ? (r = n,
            n = t,
            a = s,
            s = l) : i ? n += t : n = r + (t - r) / (l - a) * (s - a)
        };
        return {
            update: c,
            reset: function() {
                r = n = i ? 0 : n,
                a = s = 0
            },
            getVelocity: function(t) {
                var e = a
                  , o = r
                  , h = fr();
                return (t || 0 === t) && t !== n && c(t),
                s === a || h - a > l ? 0 : (n + (i ? o : -o)) / ((i ? h : s) - e) * 1e3
            }
        }
    }, Cr = function(t, e) {
        return e && !t._gsapAllow && t.preventDefault(),
        t.changedTouches ? t.changedTouches[0] : t
    }, Pr = function(t) {
        var e = Math.max.apply(Math, t)
          , i = Math.min.apply(Math, t);
        return Math.abs(e) >= Math.abs(i) ? e : i
    }, Rr = function() {
        var t, e, i, n;
        (rr = Zn.core.globals().ScrollTrigger) && rr.core && (t = rr.core,
        e = t.bridge || {},
        i = t._scrollers,
        n = t._proxies,
        i.push.apply(i, dr),
        n.push.apply(n, pr),
        dr = i,
        pr = n,
        mr = function(t, i) {
            return e[t](i)
        }
        )
    }, Ir = function(t) {
        return Zn = t || cr(),
        !Qn && Zn && "undefined" != typeof document && document.body && ($n = window,
        Kn = document,
        tr = Kn.documentElement,
        er = Kn.body,
        sr = [$n, Kn, tr, er],
        Zn.utils.clamp,
        lr = Zn.core.context || function() {}
        ,
        nr = "onpointerenter"in er ? "pointer" : "mouse",
        ir = Dr.isTouch = $n.matchMedia && $n.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart"in $n || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0,
        or = Dr.eventTypes = ("ontouchstart"in tr ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown"in tr ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","),
        setTimeout((function() {
            return hr = 0
        }
        ), 500),
        Rr(),
        Qn = 1),
        Qn
    };
    Sr.op = Tr,
    dr.cache = 0;
    var Dr = function() {
        function t(t) {
            this.init(t)
        }
        var e, i, n;
        return t.prototype.init = function(t) {
            Qn || Ir(Zn) || console.warn("Please gsap.registerPlugin(Observer)"),
            rr || Rr();
            var e = t.tolerance
              , i = t.dragMinimum
              , n = t.type
              , r = t.target
              , s = t.lineHeight
              , a = t.debounce
              , o = t.preventDefault
              , l = t.onStop
              , c = t.onStopDelay
              , h = t.ignore
              , u = t.wheelSpeed
              , d = t.event
              , p = t.onDragStart
              , f = t.onDragEnd
              , m = t.onDrag
              , g = t.onPress
              , v = t.onRelease
              , y = t.onRight
              , x = t.onLeft
              , _ = t.onUp
              , w = t.onDown
              , b = t.onChangeX
              , M = t.onChangeY
              , S = t.onChange
              , T = t.onToggleX
              , E = t.onToggleY
              , L = t.onHover
              , A = t.onHoverEnd
              , C = t.onMove
              , P = t.ignoreCheck
              , R = t.isNormalizer
              , I = t.onGestureStart
              , D = t.onGestureEnd
              , N = t.onWheel
              , O = t.onEnable
              , z = t.onDisable
              , k = t.onClick
              , B = t.scrollSpeed
              , F = t.capture
              , H = t.allowClicks
              , U = t.lockAxis
              , G = t.onLockAxis;
            this.target = r = Er(r) || tr,
            this.vars = t,
            h && (h = Zn.utils.toArray(h)),
            e = e || 1e-9,
            i = i || 0,
            u = u || 1,
            B = B || 1,
            n = n || "wheel,touch,pointer",
            a = !1 !== a,
            s || (s = parseFloat($n.getComputedStyle(er).lineHeight) || 22);
            var V, W, q, j, Y, X, J, Z = this, Q = 0, K = 0, tt = t.passive || !o, et = Lr(r, Sr), it = Lr(r, Tr), nt = et(), rt = it(), st = ~n.indexOf("touch") && !~n.indexOf("pointer") && "pointerdown" === or[0], at = vr(r), ot = r.ownerDocument || Kn, lt = [0, 0, 0], ct = [0, 0, 0], ht = 0, ut = function() {
                return ht = fr()
            }, dt = function(t, e) {
                return (Z.event = t) && h && ~h.indexOf(t.target) || e && st && "touch" !== t.pointerType || P && P(t, e)
            }, pt = function() {
                var t = Z.deltaX = Pr(lt)
                  , i = Z.deltaY = Pr(ct)
                  , n = Math.abs(t) >= e
                  , r = Math.abs(i) >= e;
                S && (n || r) && S(Z, t, i, lt, ct),
                n && (y && Z.deltaX > 0 && y(Z),
                x && Z.deltaX < 0 && x(Z),
                b && b(Z),
                T && Z.deltaX < 0 != Q < 0 && T(Z),
                Q = Z.deltaX,
                lt[0] = lt[1] = lt[2] = 0),
                r && (w && Z.deltaY > 0 && w(Z),
                _ && Z.deltaY < 0 && _(Z),
                M && M(Z),
                E && Z.deltaY < 0 != K < 0 && E(Z),
                K = Z.deltaY,
                ct[0] = ct[1] = ct[2] = 0),
                (j || q) && (C && C(Z),
                q && (m(Z),
                q = !1),
                j = !1),
                X && !(X = !1) && G && G(Z),
                Y && (N(Z),
                Y = !1),
                V = 0
            }, ft = function(t, e, i) {
                lt[i] += t,
                ct[i] += e,
                Z._vx.update(t),
                Z._vy.update(e),
                a ? V || (V = requestAnimationFrame(pt)) : pt()
            }, mt = function(t, e) {
                U && !J && (Z.axis = J = Math.abs(t) > Math.abs(e) ? "x" : "y",
                X = !0),
                "y" !== J && (lt[2] += t,
                Z._vx.update(t, !0)),
                "x" !== J && (ct[2] += e,
                Z._vy.update(e, !0)),
                a ? V || (V = requestAnimationFrame(pt)) : pt()
            }, gt = function(t) {
                if (!dt(t, 1)) {
                    var e = (t = Cr(t, o)).clientX
                      , n = t.clientY
                      , r = e - Z.x
                      , s = n - Z.y
                      , a = Z.isDragging;
                    Z.x = e,
                    Z.y = n,
                    (a || Math.abs(Z.startX - e) >= i || Math.abs(Z.startY - n) >= i) && (m && (q = !0),
                    a || (Z.isDragging = !0),
                    mt(r, s),
                    a || p && p(Z))
                }
            }, vt = Z.onPress = function(t) {
                dt(t, 1) || t && t.button || (Z.axis = J = null,
                W.pause(),
                Z.isPressed = !0,
                t = Cr(t),
                Q = K = 0,
                Z.startX = Z.x = t.clientX,
                Z.startY = Z.y = t.clientY,
                Z._vx.reset(),
                Z._vy.reset(),
                yr(R ? r : ot, or[1], gt, tt, !0),
                Z.deltaX = Z.deltaY = 0,
                g && g(Z))
            }
            , yt = Z.onRelease = function(t) {
                if (!dt(t, 1)) {
                    xr(R ? r : ot, or[1], gt, !0);
                    var e = !isNaN(Z.y - Z.startY)
                      , i = Z.isDragging
                      , n = i && (Math.abs(Z.x - Z.startX) > 3 || Math.abs(Z.y - Z.startY) > 3)
                      , s = Cr(t);
                    !n && e && (Z._vx.reset(),
                    Z._vy.reset(),
                    o && H && Zn.delayedCall(.08, (function() {
                        if (fr() - ht > 300 && !t.defaultPrevented)
                            if (t.target.click)
                                t.target.click();
                            else if (ot.createEvent) {
                                var e = ot.createEvent("MouseEvents");
                                e.initMouseEvent("click", !0, !0, $n, 1, s.screenX, s.screenY, s.clientX, s.clientY, !1, !1, !1, !1, 0, null),
                                t.target.dispatchEvent(e)
                            }
                    }
                    ))),
                    Z.isDragging = Z.isGesturing = Z.isPressed = !1,
                    l && i && !R && W.restart(!0),
                    f && i && f(Z),
                    v && v(Z, n)
                }
            }
            , xt = function(t) {
                return t.touches && t.touches.length > 1 && (Z.isGesturing = !0) && I(t, Z.isDragging)
            }, _t = function() {
                return (Z.isGesturing = !1) || D(Z)
            }, wt = function(t) {
                if (!dt(t)) {
                    var e = et()
                      , i = it();
                    ft((e - nt) * B, (i - rt) * B, 1),
                    nt = e,
                    rt = i,
                    l && W.restart(!0)
                }
            }, bt = function(t) {
                if (!dt(t)) {
                    t = Cr(t, o),
                    N && (Y = !0);
                    var e = (1 === t.deltaMode ? s : 2 === t.deltaMode ? $n.innerHeight : 1) * u;
                    ft(t.deltaX * e, t.deltaY * e, 0),
                    l && !R && W.restart(!0)
                }
            }, Mt = function(t) {
                if (!dt(t)) {
                    var e = t.clientX
                      , i = t.clientY
                      , n = e - Z.x
                      , r = i - Z.y;
                    Z.x = e,
                    Z.y = i,
                    j = !0,
                    l && W.restart(!0),
                    (n || r) && mt(n, r)
                }
            }, St = function(t) {
                Z.event = t,
                L(Z)
            }, Tt = function(t) {
                Z.event = t,
                A(Z)
            }, Et = function(t) {
                return dt(t) || Cr(t, o) && k(Z)
            };
            W = Z._dc = Zn.delayedCall(c || .25, (function() {
                Z._vx.reset(),
                Z._vy.reset(),
                W.pause(),
                l && l(Z)
            }
            )).pause(),
            Z.deltaX = Z.deltaY = 0,
            Z._vx = Ar(0, 50, !0),
            Z._vy = Ar(0, 50, !0),
            Z.scrollX = et,
            Z.scrollY = it,
            Z.isDragging = Z.isGesturing = Z.isPressed = !1,
            lr(this),
            Z.enable = function(t) {
                return Z.isEnabled || (yr(at ? ot : r, "scroll", br),
                n.indexOf("scroll") >= 0 && yr(at ? ot : r, "scroll", wt, tt, F),
                n.indexOf("wheel") >= 0 && yr(r, "wheel", bt, tt, F),
                (n.indexOf("touch") >= 0 && ir || n.indexOf("pointer") >= 0) && (yr(r, or[0], vt, tt, F),
                yr(ot, or[2], yt),
                yr(ot, or[3], yt),
                H && yr(r, "click", ut, !0, !0),
                k && yr(r, "click", Et),
                I && yr(ot, "gesturestart", xt),
                D && yr(ot, "gestureend", _t),
                L && yr(r, nr + "enter", St),
                A && yr(r, nr + "leave", Tt),
                C && yr(r, nr + "move", Mt)),
                Z.isEnabled = !0,
                t && t.type && vt(t),
                O && O(Z)),
                Z
            }
            ,
            Z.disable = function() {
                Z.isEnabled && (ur.filter((function(t) {
                    return t !== Z && vr(t.target)
                }
                )).length || xr(at ? ot : r, "scroll", br),
                Z.isPressed && (Z._vx.reset(),
                Z._vy.reset(),
                xr(R ? r : ot, or[1], gt, !0)),
                xr(at ? ot : r, "scroll", wt, F),
                xr(r, "wheel", bt, F),
                xr(r, or[0], vt, F),
                xr(ot, or[2], yt),
                xr(ot, or[3], yt),
                xr(r, "click", ut, !0),
                xr(r, "click", Et),
                xr(ot, "gesturestart", xt),
                xr(ot, "gestureend", _t),
                xr(r, nr + "enter", St),
                xr(r, nr + "leave", Tt),
                xr(r, nr + "move", Mt),
                Z.isEnabled = Z.isPressed = Z.isDragging = !1,
                z && z(Z))
            }
            ,
            Z.kill = Z.revert = function() {
                Z.disable();
                var t = ur.indexOf(Z);
                t >= 0 && ur.splice(t, 1),
                ar === Z && (ar = 0)
            }
            ,
            ur.push(Z),
            R && vr(r) && (ar = Z),
            Z.enable(d)
        }
        ,
        e = t,
        (i = [{
            key: "velocityX",
            get: function() {
                return this._vx.getVelocity()
            }
        }, {
            key: "velocityY",
            get: function() {
                return this._vy.getVelocity()
            }
        }]) && Jn(e.prototype, i),
        n && Jn(e, n),
        t
    }();
    Dr.version = "3.12.5",
    Dr.create = function(t) {
        return new Dr(t)
    }
    ,
    Dr.register = Ir,
    Dr.getAll = function() {
        return ur.slice()
    }
    ,
    Dr.getById = function(t) {
        return ur.filter((function(e) {
            return e.vars.id === t
        }
        ))[0]
    }
    ,
    cr() && Zn.registerPlugin(Dr);
    /*!
   * ScrollTrigger 3.12.5
   * https://gsap.com
   *
   * @license Copyright 2008-2024, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license or for
   * Club GSAP members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */
    var Nr, Or, zr, kr, Br, Fr, Hr, Ur, Gr, Vr, Wr, qr, jr, Yr, Xr, Jr, Zr, Qr, $r, Kr, ts, es, is, ns, rs, ss, as, os, ls, cs, hs, us, ds, ps, fs, ms, gs, vs, ys = 1, xs = Date.now, _s = xs(), ws = 0, bs = 0, Ms = function(t, e, i) {
        var n = ks(t) && ("clamp(" === t.substr(0, 6) || t.indexOf("max") > -1);
        return i["_" + e + "Clamp"] = n,
        n ? t.substr(6, t.length - 7) : t
    }, Ss = function(t, e) {
        return !e || ks(t) && "clamp(" === t.substr(0, 6) ? t : "clamp(" + t + ")"
    }, Ts = function t() {
        return bs && requestAnimationFrame(t)
    }, Es = function() {
        return Yr = 1
    }, Ls = function() {
        return Yr = 0
    }, As = function(t) {
        return t
    }, Cs = function(t) {
        return Math.round(1e5 * t) / 1e5 || 0
    }, Ps = function() {
        return "undefined" != typeof window
    }, Rs = function() {
        return Nr || Ps() && (Nr = window.gsap) && Nr.registerPlugin && Nr
    }, Is = function(t) {
        return !!~Hr.indexOf(t)
    }, Ds = function(t) {
        return ("Height" === t ? hs : zr["inner" + t]) || Br["client" + t] || Fr["client" + t]
    }, Ns = function(t) {
        return gr(t, "getBoundingClientRect") || (Is(t) ? function() {
            return Ya.width = zr.innerWidth,
            Ya.height = hs,
            Ya
        }
        : function() {
            return aa(t)
        }
        )
    }, Os = function(t, e) {
        var i = e.s
          , n = e.d2
          , r = e.d
          , s = e.a;
        return Math.max(0, (i = "scroll" + n) && (s = gr(t, i)) ? s() - Ns(t)()[r] : Is(t) ? (Br[i] || Fr[i]) - Ds(n) : t[i] - t["offset" + n])
    }, zs = function(t, e) {
        for (var i = 0; i < $r.length; i += 3)
            (!e || ~e.indexOf($r[i + 1])) && t($r[i], $r[i + 1], $r[i + 2])
    }, ks = function(t) {
        return "string" == typeof t
    }, Bs = function(t) {
        return "function" == typeof t
    }, Fs = function(t) {
        return "number" == typeof t
    }, Hs = function(t) {
        return "object" == typeof t
    }, Us = function(t, e, i) {
        return t && t.progress(e ? 0 : 1) && i && t.pause()
    }, Gs = function(t, e) {
        if (t.enabled) {
            var i = t._ctx ? t._ctx.add((function() {
                return e(t)
            }
            )) : e(t);
            i && i.totalTime && (t.callbackAnimation = i)
        }
    }, Vs = Math.abs, Ws = "left", qs = "right", js = "bottom", Ys = "width", Xs = "height", Js = "Right", Zs = "Left", Qs = "Top", $s = "Bottom", Ks = "padding", ta = "margin", ea = "Width", ia = "Height", na = "px", ra = function(t) {
        return zr.getComputedStyle(t)
    }, sa = function(t, e) {
        for (var i in e)
            i in t || (t[i] = e[i]);
        return t
    }, aa = function(t, e) {
        var i = e && "matrix(1, 0, 0, 1, 0, 0)" !== ra(t)[Xr] && Nr.to(t, {
            x: 0,
            y: 0,
            xPercent: 0,
            yPercent: 0,
            rotation: 0,
            rotationX: 0,
            rotationY: 0,
            scale: 1,
            skewX: 0,
            skewY: 0
        }).progress(1)
          , n = t.getBoundingClientRect();
        return i && i.progress(0).kill(),
        n
    }, oa = function(t, e) {
        var i = e.d2;
        return t["offset" + i] || t["client" + i] || 0
    }, la = function(t) {
        var e, i = [], n = t.labels, r = t.duration();
        for (e in n)
            i.push(n[e] / r);
        return i
    }, ca = function(t) {
        var e = Nr.utils.snap(t)
          , i = Array.isArray(t) && t.slice(0).sort((function(t, e) {
            return t - e
        }
        ));
        return i ? function(t, n, r) {
            var s;
            if (void 0 === r && (r = .001),
            !n)
                return e(t);
            if (n > 0) {
                for (t -= r,
                s = 0; s < i.length; s++)
                    if (i[s] >= t)
                        return i[s];
                return i[s - 1]
            }
            for (s = i.length,
            t += r; s--; )
                if (i[s] <= t)
                    return i[s];
            return i[0]
        }
        : function(i, n, r) {
            void 0 === r && (r = .001);
            var s = e(i);
            return !n || Math.abs(s - i) < r || s - i < 0 == n < 0 ? s : e(n < 0 ? i - t : i + t)
        }
    }, ha = function(t, e, i, n) {
        return i.split(",").forEach((function(i) {
            return t(e, i, n)
        }
        ))
    }, ua = function(t, e, i, n, r) {
        return t.addEventListener(e, i, {
            passive: !n,
            capture: !!r
        })
    }, da = function(t, e, i, n) {
        return t.removeEventListener(e, i, !!n)
    }, pa = function(t, e, i) {
        (i = i && i.wheelHandler) && (t(e, "wheel", i),
        t(e, "touchmove", i))
    }, fa = {
        startColor: "green",
        endColor: "red",
        indent: 0,
        fontSize: "16px",
        fontWeight: "normal"
    }, ma = {
        toggleActions: "play",
        anticipatePin: 0
    }, ga = {
        top: 0,
        left: 0,
        center: .5,
        bottom: 1,
        right: 1
    }, va = function(t, e) {
        if (ks(t)) {
            var i = t.indexOf("=")
              , n = ~i ? +(t.charAt(i - 1) + 1) * parseFloat(t.substr(i + 1)) : 0;
            ~i && (t.indexOf("%") > i && (n *= e / 100),
            t = t.substr(0, i - 1)),
            t = n + (t in ga ? ga[t] * e : ~t.indexOf("%") ? parseFloat(t) * e / 100 : parseFloat(t) || 0)
        }
        return t
    }, ya = function(t, e, i, n, r, s, a, o) {
        var l = r.startColor
          , c = r.endColor
          , h = r.fontSize
          , u = r.indent
          , d = r.fontWeight
          , p = kr.createElement("div")
          , f = Is(i) || "fixed" === gr(i, "pinType")
          , m = -1 !== t.indexOf("scroller")
          , g = f ? Fr : i
          , v = -1 !== t.indexOf("start")
          , y = v ? l : c
          , x = "border-color:" + y + ";font-size:" + h + ";color:" + y + ";font-weight:" + d + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
        return x += "position:" + ((m || o) && f ? "fixed;" : "absolute;"),
        (m || o || !f) && (x += (n === Tr ? qs : js) + ":" + (s + parseFloat(u)) + "px;"),
        a && (x += "box-sizing:border-box;text-align:left;width:" + a.offsetWidth + "px;"),
        p._isStart = v,
        p.setAttribute("class", "gsap-marker-" + t + (e ? " marker-" + e : "")),
        p.style.cssText = x,
        p.innerText = e || 0 === e ? t + "-" + e : t,
        g.children[0] ? g.insertBefore(p, g.children[0]) : g.appendChild(p),
        p._offset = p["offset" + n.op.d2],
        xa(p, 0, n, v),
        p
    }, xa = function(t, e, i, n) {
        var r = {
            display: "block"
        }
          , s = i[n ? "os2" : "p2"]
          , a = i[n ? "p2" : "os2"];
        t._isFlipped = n,
        r[i.a + "Percent"] = n ? -100 : 0,
        r[i.a] = n ? "1px" : 0,
        r["border" + s + ea] = 1,
        r["border" + a + ea] = 0,
        r[i.p] = e + "px",
        Nr.set(t, r)
    }, _a = [], wa = {}, ba = function() {
        return xs() - ws > 34 && (fs || (fs = requestAnimationFrame(Ha)))
    }, Ma = function() {
        (!is || !is.isPressed || is.startX > Fr.clientWidth) && (dr.cache++,
        is ? fs || (fs = requestAnimationFrame(Ha)) : Ha(),
        ws || Ca("scrollStart"),
        ws = xs())
    }, Sa = function() {
        ss = zr.innerWidth,
        rs = zr.innerHeight
    }, Ta = function() {
        dr.cache++,
        !jr && !es && !kr.fullscreenElement && !kr.webkitFullscreenElement && (!ns || ss !== zr.innerWidth || Math.abs(zr.innerHeight - rs) > .25 * zr.innerHeight) && Ur.restart(!0)
    }, Ea = {}, La = [], Aa = function t() {
        return da(to, "scrollEnd", t) || ka(!0)
    }, Ca = function(t) {
        return Ea[t] && Ea[t].map((function(t) {
            return t()
        }
        )) || La
    }, Pa = [], Ra = function(t) {
        for (var e = 0; e < Pa.length; e += 5)
            (!t || Pa[e + 4] && Pa[e + 4].query === t) && (Pa[e].style.cssText = Pa[e + 1],
            Pa[e].getBBox && Pa[e].setAttribute("transform", Pa[e + 2] || ""),
            Pa[e + 3].uncache = 1)
    }, Ia = function(t, e) {
        var i;
        for (Jr = 0; Jr < _a.length; Jr++)
            !(i = _a[Jr]) || e && i._ctx !== e || (t ? i.kill(1) : i.revert(!0, !0));
        us = !0,
        e && Ra(e),
        e || Ca("revert")
    }, Da = function(t, e) {
        dr.cache++,
        (e || !ms) && dr.forEach((function(t) {
            return Bs(t) && t.cacheID++ && (t.rec = 0)
        }
        )),
        ks(t) && (zr.history.scrollRestoration = ls = t)
    }, Na = 0, Oa = function() {
        Fr.appendChild(cs),
        hs = !is && cs.offsetHeight || zr.innerHeight,
        Fr.removeChild(cs)
    }, za = function(t) {
        return Gr(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach((function(e) {
            return e.style.display = t ? "none" : "block"
        }
        ))
    }, ka = function(t, e) {
        if (!ws || t || us) {
            Oa(),
            ms = to.isRefreshing = !0,
            dr.forEach((function(t) {
                return Bs(t) && ++t.cacheID && (t.rec = t())
            }
            ));
            var i = Ca("refreshInit");
            Kr && to.sort(),
            e || Ia(),
            dr.forEach((function(t) {
                Bs(t) && (t.smooth && (t.target.style.scrollBehavior = "auto"),
                t(0))
            }
            )),
            _a.slice(0).forEach((function(t) {
                return t.refresh()
            }
            )),
            us = !1,
            _a.forEach((function(t) {
                if (t._subPinOffset && t.pin) {
                    var e = t.vars.horizontal ? "offsetWidth" : "offsetHeight"
                      , i = t.pin[e];
                    t.revert(!0, 1),
                    t.adjustPinSpacing(t.pin[e] - i),
                    t.refresh()
                }
            }
            )),
            ds = 1,
            za(!0),
            _a.forEach((function(t) {
                var e = Os(t.scroller, t._dir)
                  , i = "max" === t.vars.end || t._endClamp && t.end > e
                  , n = t._startClamp && t.start >= e;
                (i || n) && t.setPositions(n ? e - 1 : t.start, i ? Math.max(n ? e : t.start + 1, e) : t.end, !0)
            }
            )),
            za(!1),
            ds = 0,
            i.forEach((function(t) {
                return t && t.render && t.render(-1)
            }
            )),
            dr.forEach((function(t) {
                Bs(t) && (t.smooth && requestAnimationFrame((function() {
                    return t.target.style.scrollBehavior = "smooth"
                }
                )),
                t.rec && t(t.rec))
            }
            )),
            Da(ls, 1),
            Ur.pause(),
            Na++,
            ms = 2,
            Ha(2),
            _a.forEach((function(t) {
                return Bs(t.vars.onRefresh) && t.vars.onRefresh(t)
            }
            )),
            ms = to.isRefreshing = !1,
            Ca("refresh")
        } else
            ua(to, "scrollEnd", Aa)
    }, Ba = 0, Fa = 1, Ha = function(t) {
        if (2 === t || !ms && !us) {
            to.isUpdating = !0,
            vs && vs.update(0);
            var e = _a.length
              , i = xs()
              , n = i - _s >= 50
              , r = e && _a[0].scroll();
            if (Fa = Ba > r ? -1 : 1,
            ms || (Ba = r),
            n && (ws && !Yr && i - ws > 200 && (ws = 0,
            Ca("scrollEnd")),
            Wr = _s,
            _s = i),
            Fa < 0) {
                for (Jr = e; Jr-- > 0; )
                    _a[Jr] && _a[Jr].update(0, n);
                Fa = 1
            } else
                for (Jr = 0; Jr < e; Jr++)
                    _a[Jr] && _a[Jr].update(0, n);
            to.isUpdating = !1
        }
        fs = 0
    }, Ua = [Ws, "top", js, qs, ta + $s, ta + Js, ta + Qs, ta + Zs, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"], Ga = Ua.concat([Ys, Xs, "boxSizing", "max" + ea, "max" + ia, "position", ta, Ks, Ks + Qs, Ks + Js, Ks + $s, Ks + Zs]), Va = function(t, e, i, n) {
        if (!t._gsap.swappedIn) {
            for (var r, s = Ua.length, a = e.style, o = t.style; s--; )
                a[r = Ua[s]] = i[r];
            a.position = "absolute" === i.position ? "absolute" : "relative",
            "inline" === i.display && (a.display = "inline-block"),
            o[js] = o[qs] = "auto",
            a.flexBasis = i.flexBasis || "auto",
            a.overflow = "visible",
            a.boxSizing = "border-box",
            a[Ys] = oa(t, Sr) + na,
            a[Xs] = oa(t, Tr) + na,
            a[Ks] = o[ta] = o.top = o[Ws] = "0",
            qa(n),
            o[Ys] = o["max" + ea] = i[Ys],
            o[Xs] = o["max" + ia] = i[Xs],
            o[Ks] = i[Ks],
            t.parentNode !== e && (t.parentNode.insertBefore(e, t),
            e.appendChild(t)),
            t._gsap.swappedIn = !0
        }
    }, Wa = /([A-Z])/g, qa = function(t) {
        if (t) {
            var e, i, n = t.t.style, r = t.length, s = 0;
            for ((t.t._gsap || Nr.core.getCache(t.t)).uncache = 1; s < r; s += 2)
                i = t[s + 1],
                e = t[s],
                i ? n[e] = i : n[e] && n.removeProperty(e.replace(Wa, "-$1").toLowerCase())
        }
    }, ja = function(t) {
        for (var e = Ga.length, i = t.style, n = [], r = 0; r < e; r++)
            n.push(Ga[r], i[Ga[r]]);
        return n.t = t,
        n
    }, Ya = {
        left: 0,
        top: 0
    }, Xa = function(t, e, i, n, r, s, a, o, l, c, h, u, d, p) {
        Bs(t) && (t = t(o)),
        ks(t) && "max" === t.substr(0, 3) && (t = u + ("=" === t.charAt(4) ? va("0" + t.substr(3), i) : 0));
        var f, m, g, v = d ? d.time() : 0;
        if (d && d.seek(0),
        isNaN(t) || (t = +t),
        Fs(t))
            d && (t = Nr.utils.mapRange(d.scrollTrigger.start, d.scrollTrigger.end, 0, u, t)),
            a && xa(a, i, n, !0);
        else {
            Bs(e) && (e = e(o));
            var y, x, _, w, b = (t || "0").split(" ");
            g = Er(e, o) || Fr,
            (y = aa(g) || {}) && (y.left || y.top) || "none" !== ra(g).display || (w = g.style.display,
            g.style.display = "block",
            y = aa(g),
            w ? g.style.display = w : g.style.removeProperty("display")),
            x = va(b[0], y[n.d]),
            _ = va(b[1] || "0", i),
            t = y[n.p] - l[n.p] - c + x + r - _,
            a && xa(a, _, n, i - _ < 20 || a._isStart && _ > 20),
            i -= i - _
        }
        if (p && (o[p] = t || -.001,
        t < 0 && (t = 0)),
        s) {
            var M = t + i
              , S = s._isStart;
            f = "scroll" + n.d2,
            xa(s, M, n, S && M > 20 || !S && (h ? Math.max(Fr[f], Br[f]) : s.parentNode[f]) <= M + 1),
            h && (l = aa(a),
            h && (s.style[n.op.p] = l[n.op.p] - n.op.m - s._offset + na))
        }
        return d && g && (f = aa(g),
        d.seek(u),
        m = aa(g),
        d._caScrollDist = f[n.p] - m[n.p],
        t = t / d._caScrollDist * u),
        d && d.seek(v),
        d ? t : Math.round(t)
    }, Ja = /(webkit|moz|length|cssText|inset)/i, Za = function(t, e, i, n) {
        if (t.parentNode !== e) {
            var r, s, a = t.style;
            if (e === Fr) {
                for (r in t._stOrig = a.cssText,
                s = ra(t))
                    +r || Ja.test(r) || !s[r] || "string" != typeof a[r] || "0" === r || (a[r] = s[r]);
                a.top = i,
                a.left = n
            } else
                a.cssText = t._stOrig;
            Nr.core.getCache(t).uncache = 1,
            e.appendChild(t)
        }
    }, Qa = function(t, e, i) {
        var n = e
          , r = n;
        return function(e) {
            var s = Math.round(t());
            return s !== n && s !== r && Math.abs(s - n) > 3 && Math.abs(s - r) > 3 && (e = s,
            i && i()),
            r = n,
            n = e,
            e
        }
    }, $a = function(t, e, i) {
        var n = {};
        n[e.p] = "+=" + i,
        Nr.set(t, n)
    }, Ka = function(t, e) {
        var i = Lr(t, e)
          , n = "_scroll" + e.p2
          , r = function e(r, s, a, o, l) {
            var c = e.tween
              , h = s.onComplete
              , u = {};
            a = a || i();
            var d = Qa(i, a, (function() {
                c.kill(),
                e.tween = 0
            }
            ));
            return l = o && l || 0,
            o = o || r - a,
            c && c.kill(),
            s[n] = r,
            s.inherit = !1,
            s.modifiers = u,
            u[n] = function() {
                return d(a + o * c.ratio + l * c.ratio * c.ratio)
            }
            ,
            s.onUpdate = function() {
                dr.cache++,
                e.tween && Ha()
            }
            ,
            s.onComplete = function() {
                e.tween = 0,
                h && h.call(c)
            }
            ,
            c = e.tween = Nr.to(t, s)
        };
        return t[n] = i,
        i.wheelHandler = function() {
            return r.tween && r.tween.kill() && (r.tween = 0)
        }
        ,
        ua(t, "wheel", i.wheelHandler),
        to.isTouch && ua(t, "touchmove", i.wheelHandler),
        r
    }, to = function() {
        function t(e, i) {
            Or || t.register(Nr) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"),
            os(this),
            this.init(e, i)
        }
        return t.prototype.init = function(e, i) {
            if (this.progress = this.start = 0,
            this.vars && this.kill(!0, !0),
            bs) {
                var n, r, s, a, o, l, c, h, u, d, p, f, m, g, v, y, x, _, w, b, M, S, T, E, L, A, C, P, R, I, D, N, O, z, k, B, F, H, U, G, V, W, q = e = sa(ks(e) || Fs(e) || e.nodeType ? {
                    trigger: e
                } : e, ma), j = q.onUpdate, Y = q.toggleClass, X = q.id, J = q.onToggle, Z = q.onRefresh, Q = q.scrub, K = q.trigger, tt = q.pin, et = q.pinSpacing, it = q.invalidateOnRefresh, nt = q.anticipatePin, rt = q.onScrubComplete, st = q.onSnapComplete, at = q.once, ot = q.snap, lt = q.pinReparent, ct = q.pinSpacer, ht = q.containerAnimation, ut = q.fastScrollEnd, dt = q.preventOverlaps, pt = e.horizontal || e.containerAnimation && !1 !== e.horizontal ? Sr : Tr, ft = !Q && 0 !== Q, mt = Er(e.scroller || zr), gt = Nr.core.getCache(mt), vt = Is(mt), yt = "fixed" === ("pinType"in e ? e.pinType : gr(mt, "pinType") || vt && "fixed"), xt = [e.onEnter, e.onLeave, e.onEnterBack, e.onLeaveBack], _t = ft && e.toggleActions.split(" "), wt = "markers"in e ? e.markers : ma.markers, bt = vt ? 0 : parseFloat(ra(mt)["border" + pt.p2 + ea]) || 0, Mt = this, St = e.onRefreshInit && function() {
                    return e.onRefreshInit(Mt)
                }
                , Tt = function(t, e, i) {
                    var n = i.d
                      , r = i.d2
                      , s = i.a;
                    return (s = gr(t, "getBoundingClientRect")) ? function() {
                        return s()[n]
                    }
                    : function() {
                        return (e ? Ds(r) : t["client" + r]) || 0
                    }
                }(mt, vt, pt), Et = function(t, e) {
                    return !e || ~pr.indexOf(t) ? Ns(t) : function() {
                        return Ya
                    }
                }(mt, vt), Lt = 0, At = 0, Ct = 0, Pt = Lr(mt, pt);
                if (Mt._startClamp = Mt._endClamp = !1,
                Mt._dir = pt,
                nt *= 45,
                Mt.scroller = mt,
                Mt.scroll = ht ? ht.time.bind(ht) : Pt,
                a = Pt(),
                Mt.vars = e,
                i = i || e.animation,
                "refreshPriority"in e && (Kr = 1,
                -9999 === e.refreshPriority && (vs = Mt)),
                gt.tweenScroll = gt.tweenScroll || {
                    top: Ka(mt, Tr),
                    left: Ka(mt, Sr)
                },
                Mt.tweenTo = n = gt.tweenScroll[pt.p],
                Mt.scrubDuration = function(t) {
                    (O = Fs(t) && t) ? N ? N.duration(t) : N = Nr.to(i, {
                        ease: "expo",
                        totalProgress: "+=0",
                        inherit: !1,
                        duration: O,
                        paused: !0,
                        onComplete: function() {
                            return rt && rt(Mt)
                        }
                    }) : (N && N.progress(1).kill(),
                    N = 0)
                }
                ,
                i && (i.vars.lazy = !1,
                i._initted && !Mt.isReverted || !1 !== i.vars.immediateRender && !1 !== e.immediateRender && i.duration() && i.render(0, !0, !0),
                Mt.animation = i.pause(),
                i.scrollTrigger = Mt,
                Mt.scrubDuration(Q),
                I = 0,
                X || (X = i.vars.id)),
                ot && (Hs(ot) && !ot.push || (ot = {
                    snapTo: ot
                }),
                "scrollBehavior"in Fr.style && Nr.set(vt ? [Fr, Br] : mt, {
                    scrollBehavior: "auto"
                }),
                dr.forEach((function(t) {
                    return Bs(t) && t.target === (vt ? kr.scrollingElement || Br : mt) && (t.smooth = !1)
                }
                )),
                s = Bs(ot.snapTo) ? ot.snapTo : "labels" === ot.snapTo ? function(t) {
                    return function(e) {
                        return Nr.utils.snap(la(t), e)
                    }
                }(i) : "labelsDirectional" === ot.snapTo ? (G = i,
                function(t, e) {
                    return ca(la(G))(t, e.direction)
                }
                ) : !1 !== ot.directional ? function(t, e) {
                    return ca(ot.snapTo)(t, xs() - At < 500 ? 0 : e.direction)
                }
                : Nr.utils.snap(ot.snapTo),
                z = ot.duration || {
                    min: .1,
                    max: 2
                },
                z = Hs(z) ? Vr(z.min, z.max) : Vr(z, z),
                k = Nr.delayedCall(ot.delay || O / 2 || .1, (function() {
                    var t = Pt()
                      , e = xs() - At < 500
                      , r = n.tween;
                    if (!(e || Math.abs(Mt.getVelocity()) < 10) || r || Yr || Lt === t)
                        Mt.isActive && Lt !== t && k.restart(!0);
                    else {
                        var a, o, h = (t - l) / g, u = i && !ft ? i.totalProgress() : h, d = e ? 0 : (u - D) / (xs() - Wr) * 1e3 || 0, p = Nr.utils.clamp(-h, 1 - h, Vs(d / 2) * d / .185), f = h + (!1 === ot.inertia ? 0 : p), m = ot, v = m.onStart, y = m.onInterrupt, x = m.onComplete;
                        if (a = s(f, Mt),
                        Fs(a) || (a = f),
                        o = Math.round(l + a * g),
                        t <= c && t >= l && o !== t) {
                            if (r && !r._initted && r.data <= Vs(o - t))
                                return;
                            !1 === ot.inertia && (p = a - h),
                            n(o, {
                                duration: z(Vs(.185 * Math.max(Vs(f - u), Vs(a - u)) / d / .05 || 0)),
                                ease: ot.ease || "power3",
                                data: Vs(o - t),
                                onInterrupt: function() {
                                    return k.restart(!0) && y && y(Mt)
                                },
                                onComplete: function() {
                                    Mt.update(),
                                    Lt = Pt(),
                                    i && (N ? N.resetTo("totalProgress", a, i._tTime / i._tDur) : i.progress(a)),
                                    I = D = i && !ft ? i.totalProgress() : Mt.progress,
                                    st && st(Mt),
                                    x && x(Mt)
                                }
                            }, t, p * g, o - t - p * g),
                            v && v(Mt, n.tween)
                        }
                    }
                }
                )).pause()),
                X && (wa[X] = Mt),
                (U = (K = Mt.trigger = Er(K || !0 !== tt && tt)) && K._gsap && K._gsap.stRevert) && (U = U(Mt)),
                tt = !0 === tt ? K : Er(tt),
                ks(Y) && (Y = {
                    targets: K,
                    className: Y
                }),
                tt && (!1 === et || et === ta || (et = !(!et && tt.parentNode && tt.parentNode.style && "flex" === ra(tt.parentNode).display) && Ks),
                Mt.pin = tt,
                (r = Nr.core.getCache(tt)).spacer ? v = r.pinState : (ct && ((ct = Er(ct)) && !ct.nodeType && (ct = ct.current || ct.nativeElement),
                r.spacerIsNative = !!ct,
                ct && (r.spacerState = ja(ct))),
                r.spacer = _ = ct || kr.createElement("div"),
                _.classList.add("pin-spacer"),
                X && _.classList.add("pin-spacer-" + X),
                r.pinState = v = ja(tt)),
                !1 !== e.force3D && Nr.set(tt, {
                    force3D: !0
                }),
                Mt.spacer = _ = r.spacer,
                R = ra(tt),
                E = R[et + pt.os2],
                b = Nr.getProperty(tt),
                M = Nr.quickSetter(tt, pt.a, na),
                Va(tt, _, R),
                x = ja(tt)),
                wt) {
                    f = Hs(wt) ? sa(wt, fa) : fa,
                    d = ya("scroller-start", X, mt, pt, f, 0),
                    p = ya("scroller-end", X, mt, pt, f, 0, d),
                    w = d["offset" + pt.op.d2];
                    var Rt = Er(gr(mt, "content") || mt);
                    h = this.markerStart = ya("start", X, Rt, pt, f, w, 0, ht),
                    u = this.markerEnd = ya("end", X, Rt, pt, f, w, 0, ht),
                    ht && (H = Nr.quickSetter([h, u], pt.a, na)),
                    yt || pr.length && !0 === gr(mt, "fixedMarkers") || (W = ra(V = vt ? Fr : mt).position,
                    V.style.position = "absolute" === W || "fixed" === W ? W : "relative",
                    Nr.set([d, p], {
                        force3D: !0
                    }),
                    A = Nr.quickSetter(d, pt.a, na),
                    P = Nr.quickSetter(p, pt.a, na))
                }
                if (ht) {
                    var It = ht.vars.onUpdate
                      , Dt = ht.vars.onUpdateParams;
                    ht.eventCallback("onUpdate", (function() {
                        Mt.update(0, 0, 1),
                        It && It.apply(ht, Dt || [])
                    }
                    ))
                }
                if (Mt.previous = function() {
                    return _a[_a.indexOf(Mt) - 1]
                }
                ,
                Mt.next = function() {
                    return _a[_a.indexOf(Mt) + 1]
                }
                ,
                Mt.revert = function(t, e) {
                    if (!e)
                        return Mt.kill(!0);
                    var n = !1 !== t || !Mt.enabled
                      , r = jr;
                    n !== Mt.isReverted && (n && (B = Math.max(Pt(), Mt.scroll.rec || 0),
                    Ct = Mt.progress,
                    F = i && i.progress()),
                    h && [h, u, d, p].forEach((function(t) {
                        return t.style.display = n ? "none" : "block"
                    }
                    )),
                    n && (jr = Mt,
                    Mt.update(n)),
                    !tt || lt && Mt.isActive || (n ? function(t, e, i) {
                        qa(i);
                        var n = t._gsap;
                        if (n.spacerIsNative)
                            qa(n.spacerState);
                        else if (t._gsap.swappedIn) {
                            var r = e.parentNode;
                            r && (r.insertBefore(t, e),
                            r.removeChild(e))
                        }
                        t._gsap.swappedIn = !1
                    }(tt, _, v) : Va(tt, _, ra(tt), L)),
                    n || Mt.update(n),
                    jr = r,
                    Mt.isReverted = n)
                }
                ,
                Mt.refresh = function(r, s, f, w) {
                    if (!jr && Mt.enabled || s)
                        if (tt && r && ws)
                            ua(t, "scrollEnd", Aa);
                        else {
                            !ms && St && St(Mt),
                            jr = Mt,
                            n.tween && !f && (n.tween.kill(),
                            n.tween = 0),
                            N && N.pause(),
                            it && i && i.revert({
                                kill: !1
                            }).invalidate(),
                            Mt.isReverted || Mt.revert(!0, !0),
                            Mt._subPinOffset = !1;
                            var M, E, A, P, R, I, D, O, z, H, U, G, V, W = Tt(), q = Et(), j = ht ? ht.duration() : Os(mt, pt), Y = g <= .01, X = 0, J = w || 0, Q = Hs(f) ? f.end : e.end, nt = e.endTrigger || K, rt = Hs(f) ? f.start : e.start || (0 !== e.start && K ? tt ? "0 0" : "0 100%" : 0), st = Mt.pinnedContainer = e.pinnedContainer && Er(e.pinnedContainer, Mt), at = K && Math.max(0, _a.indexOf(Mt)) || 0, ot = at;
                            for (wt && Hs(f) && (G = Nr.getProperty(d, pt.p),
                            V = Nr.getProperty(p, pt.p)); ot--; )
                                (I = _a[ot]).end || I.refresh(0, 1) || (jr = Mt),
                                !(D = I.pin) || D !== K && D !== tt && D !== st || I.isReverted || (H || (H = []),
                                H.unshift(I),
                                I.revert(!0, !0)),
                                I !== _a[ot] && (at--,
                                ot--);
                            for (Bs(rt) && (rt = rt(Mt)),
                            rt = Ms(rt, "start", Mt),
                            l = Xa(rt, K, W, pt, Pt(), h, d, Mt, q, bt, yt, j, ht, Mt._startClamp && "_startClamp") || (tt ? -.001 : 0),
                            Bs(Q) && (Q = Q(Mt)),
                            ks(Q) && !Q.indexOf("+=") && (~Q.indexOf(" ") ? Q = (ks(rt) ? rt.split(" ")[0] : "") + Q : (X = va(Q.substr(2), W),
                            Q = ks(rt) ? rt : (ht ? Nr.utils.mapRange(0, ht.duration(), ht.scrollTrigger.start, ht.scrollTrigger.end, l) : l) + X,
                            nt = K)),
                            Q = Ms(Q, "end", Mt),
                            c = Math.max(l, Xa(Q || (nt ? "100% 0" : j), nt, W, pt, Pt() + X, u, p, Mt, q, bt, yt, j, ht, Mt._endClamp && "_endClamp")) || -.001,
                            X = 0,
                            ot = at; ot--; )
                                (D = (I = _a[ot]).pin) && I.start - I._pinPush <= l && !ht && I.end > 0 && (M = I.end - (Mt._startClamp ? Math.max(0, I.start) : I.start),
                                (D === K && I.start - I._pinPush < l || D === st) && isNaN(rt) && (X += M * (1 - I.progress)),
                                D === tt && (J += M));
                            if (l += X,
                            c += X,
                            Mt._startClamp && (Mt._startClamp += X),
                            Mt._endClamp && !ms && (Mt._endClamp = c || -.001,
                            c = Math.min(c, Os(mt, pt))),
                            g = c - l || (l -= .01) && .001,
                            Y && (Ct = Nr.utils.clamp(0, 1, Nr.utils.normalize(l, c, B))),
                            Mt._pinPush = J,
                            h && X && ((M = {})[pt.a] = "+=" + X,
                            st && (M[pt.p] = "-=" + Pt()),
                            Nr.set([h, u], M)),
                            !tt || ds && Mt.end >= Os(mt, pt)) {
                                if (K && Pt() && !ht)
                                    for (E = K.parentNode; E && E !== Fr; )
                                        E._pinOffset && (l -= E._pinOffset,
                                        c -= E._pinOffset),
                                        E = E.parentNode
                            } else
                                M = ra(tt),
                                P = pt === Tr,
                                A = Pt(),
                                S = parseFloat(b(pt.a)) + J,
                                !j && c > 1 && (U = {
                                    style: U = (vt ? kr.scrollingElement || Br : mt).style,
                                    value: U["overflow" + pt.a.toUpperCase()]
                                },
                                vt && "scroll" !== ra(Fr)["overflow" + pt.a.toUpperCase()] && (U.style["overflow" + pt.a.toUpperCase()] = "scroll")),
                                Va(tt, _, M),
                                x = ja(tt),
                                E = aa(tt, !0),
                                O = yt && Lr(mt, P ? Sr : Tr)(),
                                et ? ((L = [et + pt.os2, g + J + na]).t = _,
                                (ot = et === Ks ? oa(tt, pt) + g + J : 0) && (L.push(pt.d, ot + na),
                                "auto" !== _.style.flexBasis && (_.style.flexBasis = ot + na)),
                                qa(L),
                                st && _a.forEach((function(t) {
                                    t.pin === st && !1 !== t.vars.pinSpacing && (t._subPinOffset = !0)
                                }
                                )),
                                yt && Pt(B)) : (ot = oa(tt, pt)) && "auto" !== _.style.flexBasis && (_.style.flexBasis = ot + na),
                                yt && ((R = {
                                    top: E.top + (P ? A - l : O) + na,
                                    left: E.left + (P ? O : A - l) + na,
                                    boxSizing: "border-box",
                                    position: "fixed"
                                })[Ys] = R["max" + ea] = Math.ceil(E.width) + na,
                                R[Xs] = R["max" + ia] = Math.ceil(E.height) + na,
                                R[ta] = R[ta + Qs] = R[ta + Js] = R[ta + $s] = R[ta + Zs] = "0",
                                R[Ks] = M[Ks],
                                R[Ks + Qs] = M[Ks + Qs],
                                R[Ks + Js] = M[Ks + Js],
                                R[Ks + $s] = M[Ks + $s],
                                R[Ks + Zs] = M[Ks + Zs],
                                y = function(t, e, i) {
                                    for (var n, r = [], s = t.length, a = i ? 8 : 0; a < s; a += 2)
                                        n = t[a],
                                        r.push(n, n in e ? e[n] : t[a + 1]);
                                    return r.t = t.t,
                                    r
                                }(v, R, lt),
                                ms && Pt(0)),
                                i ? (z = i._initted,
                                ts(1),
                                i.render(i.duration(), !0, !0),
                                T = b(pt.a) - S + g + J,
                                C = Math.abs(g - T) > 1,
                                yt && C && y.splice(y.length - 2, 2),
                                i.render(0, !0, !0),
                                z || i.invalidate(!0),
                                i.parent || i.totalTime(i.totalTime()),
                                ts(0)) : T = g,
                                U && (U.value ? U.style["overflow" + pt.a.toUpperCase()] = U.value : U.style.removeProperty("overflow-" + pt.a));
                            H && H.forEach((function(t) {
                                return t.revert(!1, !0)
                            }
                            )),
                            Mt.start = l,
                            Mt.end = c,
                            a = o = ms ? B : Pt(),
                            ht || ms || (a < B && Pt(B),
                            Mt.scroll.rec = 0),
                            Mt.revert(!1, !0),
                            At = xs(),
                            k && (Lt = -1,
                            k.restart(!0)),
                            jr = 0,
                            i && ft && (i._initted || F) && i.progress() !== F && i.progress(F || 0, !0).render(i.time(), !0, !0),
                            (Y || Ct !== Mt.progress || ht || it) && (i && !ft && i.totalProgress(ht && l < -.001 && !Ct ? Nr.utils.normalize(l, c, 0) : Ct, !0),
                            Mt.progress = Y || (a - l) / g === Ct ? 0 : Ct),
                            tt && et && (_._pinOffset = Math.round(Mt.progress * T)),
                            N && N.invalidate(),
                            isNaN(G) || (G -= Nr.getProperty(d, pt.p),
                            V -= Nr.getProperty(p, pt.p),
                            $a(d, pt, G),
                            $a(h, pt, G - (w || 0)),
                            $a(p, pt, V),
                            $a(u, pt, V - (w || 0))),
                            Y && !ms && Mt.update(),
                            !Z || ms || m || (m = !0,
                            Z(Mt),
                            m = !1)
                        }
                }
                ,
                Mt.getVelocity = function() {
                    return (Pt() - o) / (xs() - Wr) * 1e3 || 0
                }
                ,
                Mt.endAnimation = function() {
                    Us(Mt.callbackAnimation),
                    i && (N ? N.progress(1) : i.paused() ? ft || Us(i, Mt.direction < 0, 1) : Us(i, i.reversed()))
                }
                ,
                Mt.labelToScroll = function(t) {
                    return i && i.labels && (l || Mt.refresh() || l) + i.labels[t] / i.duration() * g || 0
                }
                ,
                Mt.getTrailing = function(t) {
                    var e = _a.indexOf(Mt)
                      , i = Mt.direction > 0 ? _a.slice(0, e).reverse() : _a.slice(e + 1);
                    return (ks(t) ? i.filter((function(e) {
                        return e.vars.preventOverlaps === t
                    }
                    )) : i).filter((function(t) {
                        return Mt.direction > 0 ? t.end <= l : t.start >= c
                    }
                    ))
                }
                ,
                Mt.update = function(t, e, r) {
                    if (!ht || r || t) {
                        var s, h, u, p, f, m, v, w = !0 === ms ? B : Mt.scroll(), b = t ? 0 : (w - l) / g, L = b < 0 ? 0 : b > 1 ? 1 : b || 0, R = Mt.progress;
                        if (e && (o = a,
                        a = ht ? Pt() : w,
                        ot && (D = I,
                        I = i && !ft ? i.totalProgress() : L)),
                        nt && tt && !jr && !ys && ws && (!L && l < w + (w - o) / (xs() - Wr) * nt ? L = 1e-4 : 1 === L && c > w + (w - o) / (xs() - Wr) * nt && (L = .9999)),
                        L !== R && Mt.enabled) {
                            if (p = (f = (s = Mt.isActive = !!L && L < 1) !== (!!R && R < 1)) || !!L != !!R,
                            Mt.direction = L > R ? 1 : -1,
                            Mt.progress = L,
                            p && !jr && (h = L && !R ? 0 : 1 === L ? 1 : 1 === R ? 2 : 3,
                            ft && (u = !f && "none" !== _t[h + 1] && _t[h + 1] || _t[h],
                            v = i && ("complete" === u || "reset" === u || u in i))),
                            dt && (f || v) && (v || Q || !i) && (Bs(dt) ? dt(Mt) : Mt.getTrailing(dt).forEach((function(t) {
                                return t.endAnimation()
                            }
                            ))),
                            ft || (!N || jr || ys ? i && i.totalProgress(L, !(!jr || !At && !t)) : (N._dp._time - N._start !== N._time && N.render(N._dp._time - N._start),
                            N.resetTo ? N.resetTo("totalProgress", L, i._tTime / i._tDur) : (N.vars.totalProgress = L,
                            N.invalidate().restart()))),
                            tt)
                                if (t && et && (_.style[et + pt.os2] = E),
                                yt) {
                                    if (p) {
                                        if (m = !t && L > R && c + 1 > w && w + 1 >= Os(mt, pt),
                                        lt)
                                            if (t || !s && !m)
                                                Za(tt, _);
                                            else {
                                                var O = aa(tt, !0)
                                                  , z = w - l;
                                                Za(tt, Fr, O.top + (pt === Tr ? z : 0) + na, O.left + (pt === Tr ? 0 : z) + na)
                                            }
                                        qa(s || m ? y : x),
                                        C && L < 1 && s || M(S + (1 !== L || m ? 0 : T))
                                    }
                                } else
                                    M(Cs(S + T * L));
                            ot && !n.tween && !jr && !ys && k.restart(!0),
                            Y && (f || at && L && (L < 1 || !ps)) && Gr(Y.targets).forEach((function(t) {
                                return t.classList[s || at ? "add" : "remove"](Y.className)
                            }
                            )),
                            j && !ft && !t && j(Mt),
                            p && !jr ? (ft && (v && ("complete" === u ? i.pause().totalProgress(1) : "reset" === u ? i.restart(!0).pause() : "restart" === u ? i.restart(!0) : i[u]()),
                            j && j(Mt)),
                            !f && ps || (J && f && Gs(Mt, J),
                            xt[h] && Gs(Mt, xt[h]),
                            at && (1 === L ? Mt.kill(!1, 1) : xt[h] = 0),
                            f || xt[h = 1 === L ? 1 : 3] && Gs(Mt, xt[h])),
                            ut && !s && Math.abs(Mt.getVelocity()) > (Fs(ut) ? ut : 2500) && (Us(Mt.callbackAnimation),
                            N ? N.progress(1) : Us(i, "reverse" === u ? 1 : !L, 1))) : ft && j && !jr && j(Mt)
                        }
                        if (P) {
                            var F = ht ? w / ht.duration() * (ht._caScrollDist || 0) : w;
                            A(F + (d._isFlipped ? 1 : 0)),
                            P(F)
                        }
                        H && H(-w / ht.duration() * (ht._caScrollDist || 0))
                    }
                }
                ,
                Mt.enable = function(e, i) {
                    Mt.enabled || (Mt.enabled = !0,
                    ua(mt, "resize", Ta),
                    vt || ua(mt, "scroll", Ma),
                    St && ua(t, "refreshInit", St),
                    !1 !== e && (Mt.progress = Ct = 0,
                    a = o = Lt = Pt()),
                    !1 !== i && Mt.refresh())
                }
                ,
                Mt.getTween = function(t) {
                    return t && n ? n.tween : N
                }
                ,
                Mt.setPositions = function(t, e, i, n) {
                    if (ht) {
                        var r = ht.scrollTrigger
                          , s = ht.duration()
                          , a = r.end - r.start;
                        t = r.start + a * t / s,
                        e = r.start + a * e / s
                    }
                    Mt.refresh(!1, !1, {
                        start: Ss(t, i && !!Mt._startClamp),
                        end: Ss(e, i && !!Mt._endClamp)
                    }, n),
                    Mt.update()
                }
                ,
                Mt.adjustPinSpacing = function(t) {
                    if (L && t) {
                        var e = L.indexOf(pt.d) + 1;
                        L[e] = parseFloat(L[e]) + t + na,
                        L[1] = parseFloat(L[1]) + t + na,
                        qa(L)
                    }
                }
                ,
                Mt.disable = function(e, i) {
                    if (Mt.enabled && (!1 !== e && Mt.revert(!0, !0),
                    Mt.enabled = Mt.isActive = !1,
                    i || N && N.pause(),
                    B = 0,
                    r && (r.uncache = 1),
                    St && da(t, "refreshInit", St),
                    k && (k.pause(),
                    n.tween && n.tween.kill() && (n.tween = 0)),
                    !vt)) {
                        for (var s = _a.length; s--; )
                            if (_a[s].scroller === mt && _a[s] !== Mt)
                                return;
                        da(mt, "resize", Ta),
                        vt || da(mt, "scroll", Ma)
                    }
                }
                ,
                Mt.kill = function(t, n) {
                    Mt.disable(t, n),
                    N && !n && N.kill(),
                    X && delete wa[X];
                    var s = _a.indexOf(Mt);
                    s >= 0 && _a.splice(s, 1),
                    s === Jr && Fa > 0 && Jr--,
                    s = 0,
                    _a.forEach((function(t) {
                        return t.scroller === Mt.scroller && (s = 1)
                    }
                    )),
                    s || ms || (Mt.scroll.rec = 0),
                    i && (i.scrollTrigger = null,
                    t && i.revert({
                        kill: !1
                    }),
                    n || i.kill()),
                    h && [h, u, d, p].forEach((function(t) {
                        return t.parentNode && t.parentNode.removeChild(t)
                    }
                    )),
                    vs === Mt && (vs = 0),
                    tt && (r && (r.uncache = 1),
                    s = 0,
                    _a.forEach((function(t) {
                        return t.pin === tt && s++
                    }
                    )),
                    s || (r.spacer = 0)),
                    e.onKill && e.onKill(Mt)
                }
                ,
                _a.push(Mt),
                Mt.enable(!1, !1),
                U && U(Mt),
                i && i.add && !g) {
                    var Nt = Mt.update;
                    Mt.update = function() {
                        Mt.update = Nt,
                        l || c || Mt.refresh()
                    }
                    ,
                    Nr.delayedCall(.01, Mt.update),
                    g = .01,
                    l = c = 0
                } else
                    Mt.refresh();
                tt && function() {
                    if (gs !== Na) {
                        var t = gs = Na;
                        requestAnimationFrame((function() {
                            return t === Na && ka(!0)
                        }
                        ))
                    }
                }()
            } else
                this.update = this.refresh = this.kill = As
        }
        ,
        t.register = function(e) {
            return Or || (Nr = e || Rs(),
            Ps() && window.document && t.enable(),
            Or = bs),
            Or
        }
        ,
        t.defaults = function(t) {
            if (t)
                for (var e in t)
                    ma[e] = t[e];
            return ma
        }
        ,
        t.disable = function(t, e) {
            bs = 0,
            _a.forEach((function(i) {
                return i[e ? "kill" : "disable"](t)
            }
            )),
            da(zr, "wheel", Ma),
            da(kr, "scroll", Ma),
            clearInterval(qr),
            da(kr, "touchcancel", As),
            da(Fr, "touchstart", As),
            ha(da, kr, "pointerdown,touchstart,mousedown", Es),
            ha(da, kr, "pointerup,touchend,mouseup", Ls),
            Ur.kill(),
            zs(da);
            for (var i = 0; i < dr.length; i += 3)
                pa(da, dr[i], dr[i + 1]),
                pa(da, dr[i], dr[i + 2])
        }
        ,
        t.enable = function() {
            if (zr = window,
            kr = document,
            Br = kr.documentElement,
            Fr = kr.body,
            Nr && (Gr = Nr.utils.toArray,
            Vr = Nr.utils.clamp,
            os = Nr.core.context || As,
            ts = Nr.core.suppressOverwrites || As,
            ls = zr.history.scrollRestoration || "auto",
            Ba = zr.pageYOffset,
            Nr.core.globals("ScrollTrigger", t),
            Fr)) {
                bs = 1,
                (cs = document.createElement("div")).style.height = "100vh",
                cs.style.position = "absolute",
                Oa(),
                Ts(),
                Dr.register(Nr),
                t.isTouch = Dr.isTouch,
                as = Dr.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent),
                ns = 1 === Dr.isTouch,
                ua(zr, "wheel", Ma),
                Hr = [zr, kr, Br, Fr],
                Nr.matchMedia ? (t.matchMedia = function(t) {
                    var e, i = Nr.matchMedia();
                    for (e in t)
                        i.add(e, t[e]);
                    return i
                }
                ,
                Nr.addEventListener("matchMediaInit", (function() {
                    return Ia()
                }
                )),
                Nr.addEventListener("matchMediaRevert", (function() {
                    return Ra()
                }
                )),
                Nr.addEventListener("matchMedia", (function() {
                    ka(0, 1),
                    Ca("matchMedia")
                }
                )),
                Nr.matchMedia("(orientation: portrait)", (function() {
                    return Sa(),
                    Sa
                }
                ))) : console.warn("Requires GSAP 3.11.0 or later"),
                Sa(),
                ua(kr, "scroll", Ma);
                var e, i, n = Fr.style, r = n.borderTopStyle, s = Nr.core.Animation.prototype;
                for (s.revert || Object.defineProperty(s, "revert", {
                    value: function() {
                        return this.time(-.01, !0)
                    }
                }),
                n.borderTopStyle = "solid",
                e = aa(Fr),
                Tr.m = Math.round(e.top + Tr.sc()) || 0,
                Sr.m = Math.round(e.left + Sr.sc()) || 0,
                r ? n.borderTopStyle = r : n.removeProperty("border-top-style"),
                qr = setInterval(ba, 250),
                Nr.delayedCall(.5, (function() {
                    return ys = 0
                }
                )),
                ua(kr, "touchcancel", As),
                ua(Fr, "touchstart", As),
                ha(ua, kr, "pointerdown,touchstart,mousedown", Es),
                ha(ua, kr, "pointerup,touchend,mouseup", Ls),
                Xr = Nr.utils.checkPrefix("transform"),
                Ga.push(Xr),
                Or = xs(),
                Ur = Nr.delayedCall(.2, ka).pause(),
                $r = [kr, "visibilitychange", function() {
                    var t = zr.innerWidth
                      , e = zr.innerHeight;
                    kr.hidden ? (Zr = t,
                    Qr = e) : Zr === t && Qr === e || Ta()
                }
                , kr, "DOMContentLoaded", ka, zr, "load", ka, zr, "resize", Ta],
                zs(ua),
                _a.forEach((function(t) {
                    return t.enable(0, 1)
                }
                )),
                i = 0; i < dr.length; i += 3)
                    pa(da, dr[i], dr[i + 1]),
                    pa(da, dr[i], dr[i + 2])
            }
        }
        ,
        t.config = function(e) {
            "limitCallbacks"in e && (ps = !!e.limitCallbacks);
            var i = e.syncInterval;
            i && clearInterval(qr) || (qr = i) && setInterval(ba, i),
            "ignoreMobileResize"in e && (ns = 1 === t.isTouch && e.ignoreMobileResize),
            "autoRefreshEvents"in e && (zs(da) || zs(ua, e.autoRefreshEvents || "none"),
            es = -1 === (e.autoRefreshEvents + "").indexOf("resize"))
        }
        ,
        t.scrollerProxy = function(t, e) {
            var i = Er(t)
              , n = dr.indexOf(i)
              , r = Is(i);
            ~n && dr.splice(n, r ? 6 : 2),
            e && (r ? pr.unshift(zr, e, Fr, e, Br, e) : pr.unshift(i, e))
        }
        ,
        t.clearMatchMedia = function(t) {
            _a.forEach((function(e) {
                return e._ctx && e._ctx.query === t && e._ctx.kill(!0, !0)
            }
            ))
        }
        ,
        t.isInViewport = function(t, e, i) {
            var n = (ks(t) ? Er(t) : t).getBoundingClientRect()
              , r = n[i ? Ys : Xs] * e || 0;
            return i ? n.right - r > 0 && n.left + r < zr.innerWidth : n.bottom - r > 0 && n.top + r < zr.innerHeight
        }
        ,
        t.positionInViewport = function(t, e, i) {
            ks(t) && (t = Er(t));
            var n = t.getBoundingClientRect()
              , r = n[i ? Ys : Xs]
              , s = null == e ? r / 2 : e in ga ? ga[e] * r : ~e.indexOf("%") ? parseFloat(e) * r / 100 : parseFloat(e) || 0;
            return i ? (n.left + s) / zr.innerWidth : (n.top + s) / zr.innerHeight
        }
        ,
        t.killAll = function(t) {
            if (_a.slice(0).forEach((function(t) {
                return "ScrollSmoother" !== t.vars.id && t.kill()
            }
            )),
            !0 !== t) {
                var e = Ea.killAll || [];
                Ea = {},
                e.forEach((function(t) {
                    return t()
                }
                ))
            }
        }
        ,
        t
    }();
    to.version = "3.12.5",
    to.saveStyles = function(t) {
        return t ? Gr(t).forEach((function(t) {
            if (t && t.style) {
                var e = Pa.indexOf(t);
                e >= 0 && Pa.splice(e, 5),
                Pa.push(t, t.style.cssText, t.getBBox && t.getAttribute("transform"), Nr.core.getCache(t), os())
            }
        }
        )) : Pa
    }
    ,
    to.revert = function(t, e) {
        return Ia(!t, e)
    }
    ,
    to.create = function(t, e) {
        return new to(t,e)
    }
    ,
    to.refresh = function(t) {
        return t ? Ta() : (Or || to.register()) && ka(!0)
    }
    ,
    to.update = function(t) {
        return ++dr.cache && Ha(!0 === t ? 2 : 0)
    }
    ,
    to.clearScrollMemory = Da,
    to.maxScroll = function(t, e) {
        return Os(t, e ? Sr : Tr)
    }
    ,
    to.getScrollFunc = function(t, e) {
        return Lr(Er(t), e ? Sr : Tr)
    }
    ,
    to.getById = function(t) {
        return wa[t]
    }
    ,
    to.getAll = function() {
        return _a.filter((function(t) {
            return "ScrollSmoother" !== t.vars.id
        }
        ))
    }
    ,
    to.isScrolling = function() {
        return !!ws
    }
    ,
    to.snapDirectional = ca,
    to.addEventListener = function(t, e) {
        var i = Ea[t] || (Ea[t] = []);
        ~i.indexOf(e) || i.push(e)
    }
    ,
    to.removeEventListener = function(t, e) {
        var i = Ea[t]
          , n = i && i.indexOf(e);
        n >= 0 && i.splice(n, 1)
    }
    ,
    to.batch = function(t, e) {
        var i, n = [], r = {}, s = e.interval || .016, a = e.batchMax || 1e9, o = function(t, e) {
            var i = []
              , n = []
              , r = Nr.delayedCall(s, (function() {
                e(i, n),
                i = [],
                n = []
            }
            )).pause();
            return function(t) {
                i.length || r.restart(!0),
                i.push(t.trigger),
                n.push(t),
                a <= i.length && r.progress(1)
            }
        };
        for (i in e)
            r[i] = "on" === i.substr(0, 2) && Bs(e[i]) && "onRefreshInit" !== i ? o(0, e[i]) : e[i];
        return Bs(a) && (a = a(),
        ua(to, "refresh", (function() {
            return a = e.batchMax()
        }
        ))),
        Gr(t).forEach((function(t) {
            var e = {};
            for (i in r)
                e[i] = r[i];
            e.trigger = t,
            n.push(to.create(e))
        }
        )),
        n
    }
    ;
    var eo, io = function(t, e, i, n) {
        return e > n ? t(n) : e < 0 && t(0),
        i > n ? (n - e) / (i - e) : i < 0 ? e / (e - i) : 1
    }, no = function t(e, i) {
        !0 === i ? e.style.removeProperty("touch-action") : e.style.touchAction = !0 === i ? "auto" : i ? "pan-" + i + (Dr.isTouch ? " pinch-zoom" : "") : "none",
        e === Br && t(Fr, i)
    }, ro = {
        auto: 1,
        scroll: 1
    }, so = function(t) {
        var e, i = t.event, n = t.target, r = t.axis, s = (i.changedTouches ? i.changedTouches[0] : i).target, a = s._gsap || Nr.core.getCache(s), o = xs();
        if (!a._isScrollT || o - a._isScrollT > 2e3) {
            for (; s && s !== Fr && (s.scrollHeight <= s.clientHeight && s.scrollWidth <= s.clientWidth || !ro[(e = ra(s)).overflowY] && !ro[e.overflowX]); )
                s = s.parentNode;
            a._isScroll = s && s !== n && !Is(s) && (ro[(e = ra(s)).overflowY] || ro[e.overflowX]),
            a._isScrollT = o
        }
        (a._isScroll || "x" === r) && (i.stopPropagation(),
        i._gsapAllow = !0)
    }, ao = function(t, e, i, n) {
        return Dr.create({
            target: t,
            capture: !0,
            debounce: !1,
            lockAxis: !0,
            type: e,
            onWheel: n = n && so,
            onPress: n,
            onDrag: n,
            onScroll: n,
            onEnable: function() {
                return i && ua(kr, Dr.eventTypes[0], lo, !1, !0)
            },
            onDisable: function() {
                return da(kr, Dr.eventTypes[0], lo, !0)
            }
        })
    }, oo = /(input|label|select|textarea)/i, lo = function(t) {
        var e = oo.test(t.target.tagName);
        (e || eo) && (t._gsapAllow = !0,
        eo = e)
    }, co = function(t) {
        Hs(t) || (t = {}),
        t.preventDefault = t.isNormalizer = t.allowClicks = !0,
        t.type || (t.type = "wheel,touch"),
        t.debounce = !!t.debounce,
        t.id = t.id || "normalizer";
        var e, i, n, r, s, a, o, l, c = t, h = c.normalizeScrollX, u = c.momentum, d = c.allowNestedScroll, p = c.onRelease, f = Er(t.target) || Br, m = Nr.core.globals().ScrollSmoother, g = m && m.get(), v = as && (t.content && Er(t.content) || g && !1 !== t.content && !g.smooth() && g.content()), y = Lr(f, Tr), x = Lr(f, Sr), _ = 1, w = (Dr.isTouch && zr.visualViewport ? zr.visualViewport.scale * zr.visualViewport.width : zr.outerWidth) / zr.innerWidth, b = 0, M = Bs(u) ? function() {
            return u(e)
        }
        : function() {
            return u || 2.8
        }
        , S = ao(f, t.type, !0, d), T = function() {
            return r = !1
        }, E = As, L = As, A = function() {
            i = Os(f, Tr),
            L = Vr(as ? 1 : 0, i),
            h && (E = Vr(0, Os(f, Sr))),
            n = Na
        }, C = function() {
            v._gsap.y = Cs(parseFloat(v._gsap.y) + y.offset) + "px",
            v.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(v._gsap.y) + ", 0, 1)",
            y.offset = y.cacheID = 0
        }, P = function() {
            A(),
            s.isActive() && s.vars.scrollY > i && (y() > i ? s.progress(1) && y(i) : s.resetTo("scrollY", i))
        };
        return v && Nr.set(v, {
            y: "+=0"
        }),
        t.ignoreCheck = function(t) {
            return as && "touchmove" === t.type && function() {
                if (r) {
                    requestAnimationFrame(T);
                    var t = Cs(e.deltaY / 2)
                      , i = L(y.v - t);
                    if (v && i !== y.v + y.offset) {
                        y.offset = i - y.v;
                        var n = Cs((parseFloat(v && v._gsap.y) || 0) - y.offset);
                        v.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + n + ", 0, 1)",
                        v._gsap.y = n + "px",
                        y.cacheID = dr.cache,
                        Ha()
                    }
                    return !0
                }
                y.offset && C(),
                r = !0
            }() || _ > 1.05 && "touchstart" !== t.type || e.isGesturing || t.touches && t.touches.length > 1
        }
        ,
        t.onPress = function() {
            r = !1;
            var t = _;
            _ = Cs((zr.visualViewport && zr.visualViewport.scale || 1) / w),
            s.pause(),
            t !== _ && no(f, _ > 1.01 || !h && "x"),
            a = x(),
            o = y(),
            A(),
            n = Na
        }
        ,
        t.onRelease = t.onGestureStart = function(t, e) {
            if (y.offset && C(),
            e) {
                dr.cache++;
                var n, r, a = M();
                h && (r = (n = x()) + .05 * a * -t.velocityX / .227,
                a *= io(x, n, r, Os(f, Sr)),
                s.vars.scrollX = E(r)),
                r = (n = y()) + .05 * a * -t.velocityY / .227,
                a *= io(y, n, r, Os(f, Tr)),
                s.vars.scrollY = L(r),
                s.invalidate().duration(a).play(.01),
                (as && s.vars.scrollY >= i || n >= i - 1) && Nr.to({}, {
                    onUpdate: P,
                    duration: a
                })
            } else
                l.restart(!0);
            p && p(t)
        }
        ,
        t.onWheel = function() {
            s._ts && s.pause(),
            xs() - b > 1e3 && (n = 0,
            b = xs())
        }
        ,
        t.onChange = function(t, e, i, r, s) {
            if (Na !== n && A(),
            e && h && x(E(r[2] === e ? a + (t.startX - t.x) : x() + e - r[1])),
            i) {
                y.offset && C();
                var l = s[2] === i
                  , c = l ? o + t.startY - t.y : y() + i - s[1]
                  , u = L(c);
                l && c !== u && (o += u - c),
                y(u)
            }
            (i || e) && Ha()
        }
        ,
        t.onEnable = function() {
            no(f, !h && "x"),
            to.addEventListener("refresh", P),
            ua(zr, "resize", P),
            y.smooth && (y.target.style.scrollBehavior = "auto",
            y.smooth = x.smooth = !1),
            S.enable()
        }
        ,
        t.onDisable = function() {
            no(f, !0),
            da(zr, "resize", P),
            to.removeEventListener("refresh", P),
            S.kill()
        }
        ,
        t.lockAxis = !1 !== t.lockAxis,
        (e = new Dr(t)).iOS = as,
        as && !y() && y(1),
        as && Nr.ticker.add(As),
        l = e._dc,
        s = Nr.to(e, {
            ease: "power4",
            paused: !0,
            inherit: !1,
            scrollX: h ? "+=0.1" : "+=0",
            scrollY: "+=0.1",
            modifiers: {
                scrollY: Qa(y, y(), (function() {
                    return s.pause()
                }
                ))
            },
            onUpdate: Ha,
            onComplete: l.vars.onComplete
        }),
        e
    };
    function ho(t) {
        for (var e = t.parentNode.childNodes, i = 0, n = 0; n < e.length; n++) {
            if (e[n] == t)
                return i;
            1 == e[n].nodeType && i++
        }
        return -1
    }
    function uo() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
    }
    function po(t, e, i) {
        return Math.max(t, Math.min(e, i))
    }
    to.sort = function(t) {
        return _a.sort(t || function(t, e) {
            return -1e6 * (t.vars.refreshPriority || 0) + t.start - (e.start + -1e6 * (e.vars.refreshPriority || 0))
        }
        )
    }
    ,
    to.observe = function(t) {
        return new Dr(t)
    }
    ,
    to.normalizeScroll = function(t) {
        if (void 0 === t)
            return is;
        if (!0 === t && is)
            return is.enable();
        if (!1 === t)
            return is && is.kill(),
            void (is = t);
        var e = t instanceof Dr ? t : co(t);
        return is && is.target === e.target && is.kill(),
        Is(e.target) && (is = e),
        e
    }
    ,
    to.core = {
        _getVelocityProp: Ar,
        _inputObserver: ao,
        _scrollers: dr,
        _proxies: pr,
        bridge: {
            ss: function() {
                ws || Ca("scrollStart"),
                ws = xs()
            },
            ref: function() {
                return jr
            }
        }
    },
    Rs() && Nr.registerPlugin(to);
    class fo {
        advance(t) {
            if (!this.isRunning)
                return;
            let e = !1;
            if (this.lerp)
                this.value = (i = this.value,
                n = this.to,
                r = 60 * this.lerp,
                s = t,
                function(t, e, i) {
                    return (1 - i) * t + i * e
                }(i, n, 1 - Math.exp(-r * s))),
                Math.round(this.value) === this.to && (this.value = this.to,
                e = !0);
            else {
                this.currentTime += t;
                const i = po(0, this.currentTime / this.duration, 1);
                e = i >= 1;
                const n = e ? 1 : this.easing(i);
                this.value = this.from + (this.to - this.from) * n
            }
            var i, n, r, s;
            this.onUpdate?.(this.value, e),
            e && this.stop()
        }
        stop() {
            this.isRunning = !1
        }
        fromTo(t, e, {lerp: i=.1, duration: n=1, easing: r=(t => t), onStart: s, onUpdate: a}) {
            this.from = this.value = t,
            this.to = e,
            this.lerp = i,
            this.duration = n,
            this.easing = r,
            this.currentTime = 0,
            this.isRunning = !0,
            s?.(),
            this.onUpdate = a
        }
    }
    class mo {
        constructor({wrapper: t, content: e, autoResize: i=!0, debounce: n=250}={}) {
            this.wrapper = t,
            this.content = e,
            i && (this.debouncedResize = function(t, e) {
                let i;
                return function() {
                    let n = arguments
                      , r = this;
                    clearTimeout(i),
                    i = setTimeout((function() {
                        t.apply(r, n)
                    }
                    ), e)
                }
            }(this.resize, n),
            this.wrapper === window ? window.addEventListener("resize", this.debouncedResize, !1) : (this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize),
            this.wrapperResizeObserver.observe(this.wrapper)),
            this.contentResizeObserver = new ResizeObserver(this.debouncedResize),
            this.contentResizeObserver.observe(this.content)),
            this.resize()
        }
        destroy() {
            this.wrapperResizeObserver?.disconnect(),
            this.contentResizeObserver?.disconnect(),
            window.removeEventListener("resize", this.debouncedResize, !1)
        }
        resize = () => {
            this.onWrapperResize(),
            this.onContentResize()
        }
        ;
        onWrapperResize = () => {
            this.wrapper === window ? (this.width = window.innerWidth,
            this.height = window.innerHeight) : (this.width = this.wrapper.clientWidth,
            this.height = this.wrapper.clientHeight)
        }
        ;
        onContentResize = () => {
            this.wrapper === window ? (this.scrollHeight = this.content.scrollHeight,
            this.scrollWidth = this.content.scrollWidth) : (this.scrollHeight = this.wrapper.scrollHeight,
            this.scrollWidth = this.wrapper.scrollWidth)
        }
        ;
        get limit() {
            return {
                x: this.scrollWidth - this.width,
                y: this.scrollHeight - this.height
            }
        }
    }
    class go {
        constructor() {
            this.events = {}
        }
        emit(t, ...e) {
            let i = this.events[t] || [];
            for (let t = 0, n = i.length; t < n; t++)
                i[t](...e)
        }
        on(t, e) {
            return this.events[t]?.push(e) || (this.events[t] = [e]),
            () => {
                this.events[t] = this.events[t]?.filter((t => e !== t))
            }
        }
        off(t, e) {
            this.events[t] = this.events[t]?.filter((t => e !== t))
        }
        destroy() {
            this.events = {}
        }
    }
    const vo = 100 / 6;
    class yo {
        constructor(t, {wheelMultiplier: e=1, touchMultiplier: i=1}) {
            this.element = t,
            this.wheelMultiplier = e,
            this.touchMultiplier = i,
            this.touchStart = {
                x: null,
                y: null
            },
            this.emitter = new go,
            window.addEventListener("resize", this.onWindowResize, !1),
            this.onWindowResize(),
            this.element.addEventListener("wheel", this.onWheel, {
                passive: !1
            }),
            this.element.addEventListener("touchstart", this.onTouchStart, {
                passive: !1
            }),
            this.element.addEventListener("touchmove", this.onTouchMove, {
                passive: !1
            }),
            this.element.addEventListener("touchend", this.onTouchEnd, {
                passive: !1
            })
        }
        on(t, e) {
            return this.emitter.on(t, e)
        }
        destroy() {
            this.emitter.destroy(),
            window.removeEventListener("resize", this.onWindowResize, !1),
            this.element.removeEventListener("wheel", this.onWheel, {
                passive: !1
            }),
            this.element.removeEventListener("touchstart", this.onTouchStart, {
                passive: !1
            }),
            this.element.removeEventListener("touchmove", this.onTouchMove, {
                passive: !1
            }),
            this.element.removeEventListener("touchend", this.onTouchEnd, {
                passive: !1
            })
        }
        onTouchStart = t => {
            const {clientX: e, clientY: i} = t.targetTouches ? t.targetTouches[0] : t;
            this.touchStart.x = e,
            this.touchStart.y = i,
            this.lastDelta = {
                x: 0,
                y: 0
            },
            this.emitter.emit("scroll", {
                deltaX: 0,
                deltaY: 0,
                event: t
            })
        }
        ;
        onTouchMove = t => {
            const {clientX: e, clientY: i} = t.targetTouches ? t.targetTouches[0] : t
              , n = -(e - this.touchStart.x) * this.touchMultiplier
              , r = -(i - this.touchStart.y) * this.touchMultiplier;
            this.touchStart.x = e,
            this.touchStart.y = i,
            this.lastDelta = {
                x: n,
                y: r
            },
            this.emitter.emit("scroll", {
                deltaX: n,
                deltaY: r,
                event: t
            })
        }
        ;
        onTouchEnd = t => {
            this.emitter.emit("scroll", {
                deltaX: this.lastDelta.x,
                deltaY: this.lastDelta.y,
                event: t
            })
        }
        ;
        onWheel = t => {
            let {deltaX: e, deltaY: i, deltaMode: n} = t;
            e *= 1 === n ? vo : 2 === n ? this.windowWidth : 1,
            i *= 1 === n ? vo : 2 === n ? this.windowHeight : 1,
            e *= this.wheelMultiplier,
            i *= this.wheelMultiplier,
            this.emitter.emit("scroll", {
                deltaX: e,
                deltaY: i,
                event: t
            })
        }
        ;
        onWindowResize = () => {
            this.windowWidth = window.innerWidth,
            this.windowHeight = window.innerHeight
        }
    }
    /**
   * @license
   * Copyright 2010-2021 Three.js Authors
   * SPDX-License-Identifier: MIT
   */
    const xo = 0
      , _o = 1
      , wo = 2
      , bo = 1
      , Mo = 2
      , So = 3
      , To = 0
      , Eo = 1
      , Lo = 2
      , Ao = 0
      , Co = 1
      , Po = 2
      , Ro = 3
      , Io = 4
      , Do = 5
      , No = 100
      , Oo = 101
      , zo = 102
      , ko = 103
      , Bo = 104
      , Fo = 200
      , Ho = 201
      , Uo = 202
      , Go = 203
      , Vo = 204
      , Wo = 205
      , qo = 206
      , jo = 207
      , Yo = 208
      , Xo = 209
      , Jo = 210
      , Zo = 0
      , Qo = 1
      , $o = 2
      , Ko = 3
      , tl = 4
      , el = 5
      , il = 6
      , nl = 7
      , rl = 0
      , sl = 1
      , al = 2
      , ol = 0
      , ll = 1
      , cl = 2
      , hl = 3
      , ul = 4
      , dl = 5
      , pl = 301
      , fl = 302
      , ml = 303
      , gl = 304
      , vl = 306
      , yl = 307
      , xl = 1e3
      , _l = 1001
      , wl = 1002
      , bl = 1003
      , Ml = 1004
      , Sl = 1005
      , Tl = 1006
      , El = 1007
      , Ll = 1008
      , Al = 1009
      , Cl = 1010
      , Pl = 1011
      , Rl = 1012
      , Il = 1013
      , Dl = 1014
      , Nl = 1015
      , Ol = 1016
      , zl = 1017
      , kl = 1018
      , Bl = 1019
      , Fl = 1020
      , Hl = 1021
      , Ul = 1022
      , Gl = 1023
      , Vl = 1024
      , Wl = 1025
      , ql = 1026
      , jl = 1027
      , Yl = 1028
      , Xl = 1029
      , Jl = 1030
      , Zl = 1031
      , Ql = 1032
      , $l = 1033
      , Kl = 33776
      , tc = 33777
      , ec = 33778
      , ic = 33779
      , nc = 35840
      , rc = 35841
      , sc = 35842
      , ac = 35843
      , oc = 36196
      , lc = 37492
      , cc = 37496
      , hc = 37808
      , uc = 37809
      , dc = 37810
      , pc = 37811
      , fc = 37812
      , mc = 37813
      , gc = 37814
      , vc = 37815
      , yc = 37816
      , xc = 37817
      , _c = 37818
      , wc = 37819
      , bc = 37820
      , Mc = 37821
      , Sc = 36492
      , Tc = 37840
      , Ec = 37841
      , Lc = 37842
      , Ac = 37843
      , Cc = 37844
      , Pc = 37845
      , Rc = 37846
      , Ic = 37847
      , Dc = 37848
      , Nc = 37849
      , Oc = 37850
      , zc = 37851
      , kc = 37852
      , Bc = 37853
      , Fc = 2300
      , Hc = 2301
      , Uc = 2302
      , Gc = 2400
      , Vc = 2401
      , Wc = 2402
      , qc = 2500
      , jc = 3e3
      , Yc = 3001
      , Xc = 3007
      , Jc = 3002
      , Zc = 3003
      , Qc = 3004
      , $c = 3005
      , Kc = 3006
      , th = 3201
      , eh = 0
      , ih = 1
      , nh = 7680
      , rh = 35044
      , sh = 35048
      , ah = "300 es";
    class oh {
        addEventListener(t, e) {
            void 0 === this._listeners && (this._listeners = {});
            const i = this._listeners;
            void 0 === i[t] && (i[t] = []),
            -1 === i[t].indexOf(e) && i[t].push(e)
        }
        hasEventListener(t, e) {
            if (void 0 === this._listeners)
                return !1;
            const i = this._listeners;
            return void 0 !== i[t] && -1 !== i[t].indexOf(e)
        }
        removeEventListener(t, e) {
            if (void 0 === this._listeners)
                return;
            const i = this._listeners[t];
            if (void 0 !== i) {
                const t = i.indexOf(e);
                -1 !== t && i.splice(t, 1)
            }
        }
        dispatchEvent(t) {
            if (void 0 === this._listeners)
                return;
            const e = this._listeners[t.type];
            if (void 0 !== e) {
                t.target = this;
                const i = e.slice(0);
                for (let e = 0, n = i.length; e < n; e++)
                    i[e].call(this, t);
                t.target = null
            }
        }
    }
    const lh = [];
    for (let Cx = 0; Cx < 256; Cx++)
        lh[Cx] = (Cx < 16 ? "0" : "") + Cx.toString(16);
    const ch = Math.PI / 180
      , hh = 180 / Math.PI;
    function uh() {
        const t = 4294967295 * Math.random() | 0
          , e = 4294967295 * Math.random() | 0
          , i = 4294967295 * Math.random() | 0
          , n = 4294967295 * Math.random() | 0;
        return (lh[255 & t] + lh[t >> 8 & 255] + lh[t >> 16 & 255] + lh[t >> 24 & 255] + "-" + lh[255 & e] + lh[e >> 8 & 255] + "-" + lh[e >> 16 & 15 | 64] + lh[e >> 24 & 255] + "-" + lh[63 & i | 128] + lh[i >> 8 & 255] + "-" + lh[i >> 16 & 255] + lh[i >> 24 & 255] + lh[255 & n] + lh[n >> 8 & 255] + lh[n >> 16 & 255] + lh[n >> 24 & 255]).toUpperCase()
    }
    function dh(t, e, i) {
        return Math.max(e, Math.min(i, t))
    }
    function ph(t, e, i) {
        return (1 - i) * t + i * e
    }
    function fh(t) {
        return !(t & t - 1) && 0 !== t
    }
    function mh(t) {
        return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
    }
    class gh {
        constructor(t=0, e=0) {
            this.x = t,
            this.y = e
        }
        get width() {
            return this.x
        }
        set width(t) {
            this.x = t
        }
        get height() {
            return this.y
        }
        set height(t) {
            this.y = t
        }
        set(t, e) {
            return this.x = t,
            this.y = e,
            this
        }
        setScalar(t) {
            return this.x = t,
            this.y = t,
            this
        }
        setX(t) {
            return this.x = t,
            this
        }
        setY(t) {
            return this.y = t,
            this
        }
        setComponent(t, e) {
            switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            default:
                throw new Error("index is out of range: " + t)
            }
            return this
        }
        getComponent(t) {
            switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error("index is out of range: " + t)
            }
        }
        clone() {
            return new this.constructor(this.x,this.y)
        }
        copy(t) {
            return this.x = t.x,
            this.y = t.y,
            this
        }
        add(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(t, e)) : (this.x += t.x,
            this.y += t.y,
            this)
        }
        addScalar(t) {
            return this.x += t,
            this.y += t,
            this
        }
        addVectors(t, e) {
            return this.x = t.x + e.x,
            this.y = t.y + e.y,
            this
        }
        addScaledVector(t, e) {
            return this.x += t.x * e,
            this.y += t.y * e,
            this
        }
        sub(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(t, e)) : (this.x -= t.x,
            this.y -= t.y,
            this)
        }
        subScalar(t) {
            return this.x -= t,
            this.y -= t,
            this
        }
        subVectors(t, e) {
            return this.x = t.x - e.x,
            this.y = t.y - e.y,
            this
        }
        multiply(t) {
            return this.x *= t.x,
            this.y *= t.y,
            this
        }
        multiplyScalar(t) {
            return this.x *= t,
            this.y *= t,
            this
        }
        divide(t) {
            return this.x /= t.x,
            this.y /= t.y,
            this
        }
        divideScalar(t) {
            return this.multiplyScalar(1 / t)
        }
        applyMatrix3(t) {
            const e = this.x
              , i = this.y
              , n = t.elements;
            return this.x = n[0] * e + n[3] * i + n[6],
            this.y = n[1] * e + n[4] * i + n[7],
            this
        }
        min(t) {
            return this.x = Math.min(this.x, t.x),
            this.y = Math.min(this.y, t.y),
            this
        }
        max(t) {
            return this.x = Math.max(this.x, t.x),
            this.y = Math.max(this.y, t.y),
            this
        }
        clamp(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)),
            this.y = Math.max(t.y, Math.min(e.y, this.y)),
            this
        }
        clampScalar(t, e) {
            return this.x = Math.max(t, Math.min(e, this.x)),
            this.y = Math.max(t, Math.min(e, this.y)),
            this
        }
        clampLength(t, e) {
            const i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
        }
        floor() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this
        }
        ceil() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this
        }
        round() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this
        }
        roundToZero() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this
        }
        negate() {
            return this.x = -this.x,
            this.y = -this.y,
            this
        }
        dot(t) {
            return this.x * t.x + this.y * t.y
        }
        cross(t) {
            return this.x * t.y - this.y * t.x
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y)
        }
        normalize() {
            return this.divideScalar(this.length() || 1)
        }
        angle() {
            return Math.atan2(-this.y, -this.x) + Math.PI
        }
        distanceTo(t) {
            return Math.sqrt(this.distanceToSquared(t))
        }
        distanceToSquared(t) {
            const e = this.x - t.x
              , i = this.y - t.y;
            return e * e + i * i
        }
        manhattanDistanceTo(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
        }
        setLength(t) {
            return this.normalize().multiplyScalar(t)
        }
        lerp(t, e) {
            return this.x += (t.x - this.x) * e,
            this.y += (t.y - this.y) * e,
            this
        }
        lerpVectors(t, e, i) {
            return this.x = t.x + (e.x - t.x) * i,
            this.y = t.y + (e.y - t.y) * i,
            this
        }
        equals(t) {
            return t.x === this.x && t.y === this.y
        }
        fromArray(t, e=0) {
            return this.x = t[e],
            this.y = t[e + 1],
            this
        }
        toArray(t=[], e=0) {
            return t[e] = this.x,
            t[e + 1] = this.y,
            t
        }
        fromBufferAttribute(t, e, i) {
            return void 0 !== i && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),
            this.x = t.getX(e),
            this.y = t.getY(e),
            this
        }
        rotateAround(t, e) {
            const i = Math.cos(e)
              , n = Math.sin(e)
              , r = this.x - t.x
              , s = this.y - t.y;
            return this.x = r * i - s * n + t.x,
            this.y = r * n + s * i + t.y,
            this
        }
        random() {
            return this.x = Math.random(),
            this.y = Math.random(),
            this
        }
    }
    gh.prototype.isVector2 = !0;
    class vh {
        constructor() {
            this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
            arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
        }
        set(t, e, i, n, r, s, a, o, l) {
            const c = this.elements;
            return c[0] = t,
            c[1] = n,
            c[2] = a,
            c[3] = e,
            c[4] = r,
            c[5] = o,
            c[6] = i,
            c[7] = s,
            c[8] = l,
            this
        }
        identity() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
            this
        }
        copy(t) {
            const e = this.elements
              , i = t.elements;
            return e[0] = i[0],
            e[1] = i[1],
            e[2] = i[2],
            e[3] = i[3],
            e[4] = i[4],
            e[5] = i[5],
            e[6] = i[6],
            e[7] = i[7],
            e[8] = i[8],
            this
        }
        extractBasis(t, e, i) {
            return t.setFromMatrix3Column(this, 0),
            e.setFromMatrix3Column(this, 1),
            i.setFromMatrix3Column(this, 2),
            this
        }
        setFromMatrix4(t) {
            const e = t.elements;
            return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
            this
        }
        multiply(t) {
            return this.multiplyMatrices(this, t)
        }
        premultiply(t) {
            return this.multiplyMatrices(t, this)
        }
        multiplyMatrices(t, e) {
            const i = t.elements
              , n = e.elements
              , r = this.elements
              , s = i[0]
              , a = i[3]
              , o = i[6]
              , l = i[1]
              , c = i[4]
              , h = i[7]
              , u = i[2]
              , d = i[5]
              , p = i[8]
              , f = n[0]
              , m = n[3]
              , g = n[6]
              , v = n[1]
              , y = n[4]
              , x = n[7]
              , _ = n[2]
              , w = n[5]
              , b = n[8];
            return r[0] = s * f + a * v + o * _,
            r[3] = s * m + a * y + o * w,
            r[6] = s * g + a * x + o * b,
            r[1] = l * f + c * v + h * _,
            r[4] = l * m + c * y + h * w,
            r[7] = l * g + c * x + h * b,
            r[2] = u * f + d * v + p * _,
            r[5] = u * m + d * y + p * w,
            r[8] = u * g + d * x + p * b,
            this
        }
        multiplyScalar(t) {
            const e = this.elements;
            return e[0] *= t,
            e[3] *= t,
            e[6] *= t,
            e[1] *= t,
            e[4] *= t,
            e[7] *= t,
            e[2] *= t,
            e[5] *= t,
            e[8] *= t,
            this
        }
        determinant() {
            const t = this.elements
              , e = t[0]
              , i = t[1]
              , n = t[2]
              , r = t[3]
              , s = t[4]
              , a = t[5]
              , o = t[6]
              , l = t[7]
              , c = t[8];
            return e * s * c - e * a * l - i * r * c + i * a * o + n * r * l - n * s * o
        }
        invert() {
            const t = this.elements
              , e = t[0]
              , i = t[1]
              , n = t[2]
              , r = t[3]
              , s = t[4]
              , a = t[5]
              , o = t[6]
              , l = t[7]
              , c = t[8]
              , h = c * s - a * l
              , u = a * o - c * r
              , d = l * r - s * o
              , p = e * h + i * u + n * d;
            if (0 === p)
                return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            const f = 1 / p;
            return t[0] = h * f,
            t[1] = (n * l - c * i) * f,
            t[2] = (a * i - n * s) * f,
            t[3] = u * f,
            t[4] = (c * e - n * o) * f,
            t[5] = (n * r - a * e) * f,
            t[6] = d * f,
            t[7] = (i * o - l * e) * f,
            t[8] = (s * e - i * r) * f,
            this
        }
        transpose() {
            let t;
            const e = this.elements;
            return t = e[1],
            e[1] = e[3],
            e[3] = t,
            t = e[2],
            e[2] = e[6],
            e[6] = t,
            t = e[5],
            e[5] = e[7],
            e[7] = t,
            this
        }
        getNormalMatrix(t) {
            return this.setFromMatrix4(t).invert().transpose()
        }
        transposeIntoArray(t) {
            const e = this.elements;
            return t[0] = e[0],
            t[1] = e[3],
            t[2] = e[6],
            t[3] = e[1],
            t[4] = e[4],
            t[5] = e[7],
            t[6] = e[2],
            t[7] = e[5],
            t[8] = e[8],
            this
        }
        setUvTransform(t, e, i, n, r, s, a) {
            const o = Math.cos(r)
              , l = Math.sin(r);
            return this.set(i * o, i * l, -i * (o * s + l * a) + s + t, -n * l, n * o, -n * (-l * s + o * a) + a + e, 0, 0, 1),
            this
        }
        scale(t, e) {
            const i = this.elements;
            return i[0] *= t,
            i[3] *= t,
            i[6] *= t,
            i[1] *= e,
            i[4] *= e,
            i[7] *= e,
            this
        }
        rotate(t) {
            const e = Math.cos(t)
              , i = Math.sin(t)
              , n = this.elements
              , r = n[0]
              , s = n[3]
              , a = n[6]
              , o = n[1]
              , l = n[4]
              , c = n[7];
            return n[0] = e * r + i * o,
            n[3] = e * s + i * l,
            n[6] = e * a + i * c,
            n[1] = -i * r + e * o,
            n[4] = -i * s + e * l,
            n[7] = -i * a + e * c,
            this
        }
        translate(t, e) {
            const i = this.elements;
            return i[0] += t * i[2],
            i[3] += t * i[5],
            i[6] += t * i[8],
            i[1] += e * i[2],
            i[4] += e * i[5],
            i[7] += e * i[8],
            this
        }
        equals(t) {
            const e = this.elements
              , i = t.elements;
            for (let t = 0; t < 9; t++)
                if (e[t] !== i[t])
                    return !1;
            return !0
        }
        fromArray(t, e=0) {
            for (let i = 0; i < 9; i++)
                this.elements[i] = t[i + e];
            return this
        }
        toArray(t=[], e=0) {
            const i = this.elements;
            return t[e] = i[0],
            t[e + 1] = i[1],
            t[e + 2] = i[2],
            t[e + 3] = i[3],
            t[e + 4] = i[4],
            t[e + 5] = i[5],
            t[e + 6] = i[6],
            t[e + 7] = i[7],
            t[e + 8] = i[8],
            t
        }
        clone() {
            return (new this.constructor).fromArray(this.elements)
        }
    }
    let yh;
    vh.prototype.isMatrix3 = !0;
    class xh {
        static getDataURL(t) {
            if (/^data:/i.test(t.src))
                return t.src;
            if ("undefined" == typeof HTMLCanvasElement)
                return t.src;
            let e;
            if (t instanceof HTMLCanvasElement)
                e = t;
            else {
                void 0 === yh && (yh = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")),
                yh.width = t.width,
                yh.height = t.height;
                const i = yh.getContext("2d");
                t instanceof ImageData ? i.putImageData(t, 0, 0) : i.drawImage(t, 0, 0, t.width, t.height),
                e = yh
            }
            return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t),
            e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
        }
    }
    let _h = 0;
    class wh extends oh {
        constructor(t=wh.DEFAULT_IMAGE, e=wh.DEFAULT_MAPPING, i=_l, n=_l, r=Tl, s=Ll, a=Gl, o=Al, l=1, c=jc) {
            super(),
            Object.defineProperty(this, "id", {
                value: _h++
            }),
            this.uuid = uh(),
            this.name = "",
            this.image = t,
            this.mipmaps = [],
            this.mapping = e,
            this.wrapS = i,
            this.wrapT = n,
            this.magFilter = r,
            this.minFilter = s,
            this.anisotropy = l,
            this.format = a,
            this.internalFormat = null,
            this.type = o,
            this.offset = new gh(0,0),
            this.repeat = new gh(1,1),
            this.center = new gh(0,0),
            this.rotation = 0,
            this.matrixAutoUpdate = !0,
            this.matrix = new vh,
            this.generateMipmaps = !0,
            this.premultiplyAlpha = !1,
            this.flipY = !0,
            this.unpackAlignment = 4,
            this.encoding = c,
            this.version = 0,
            this.onUpdate = null
        }
        updateMatrix() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(t) {
            return this.name = t.name,
            this.image = t.image,
            this.mipmaps = t.mipmaps.slice(0),
            this.mapping = t.mapping,
            this.wrapS = t.wrapS,
            this.wrapT = t.wrapT,
            this.magFilter = t.magFilter,
            this.minFilter = t.minFilter,
            this.anisotropy = t.anisotropy,
            this.format = t.format,
            this.internalFormat = t.internalFormat,
            this.type = t.type,
            this.offset.copy(t.offset),
            this.repeat.copy(t.repeat),
            this.center.copy(t.center),
            this.rotation = t.rotation,
            this.matrixAutoUpdate = t.matrixAutoUpdate,
            this.matrix.copy(t.matrix),
            this.generateMipmaps = t.generateMipmaps,
            this.premultiplyAlpha = t.premultiplyAlpha,
            this.flipY = t.flipY,
            this.unpackAlignment = t.unpackAlignment,
            this.encoding = t.encoding,
            this
        }
        toJSON(t) {
            const e = void 0 === t || "string" == typeof t;
            if (!e && void 0 !== t.textures[this.uuid])
                return t.textures[this.uuid];
            const i = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                type: this.type,
                encoding: this.encoding,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            if (void 0 !== this.image) {
                const n = this.image;
                if (void 0 === n.uuid && (n.uuid = uh()),
                !e && void 0 === t.images[n.uuid]) {
                    let e;
                    if (Array.isArray(n)) {
                        e = [];
                        for (let t = 0, i = n.length; t < i; t++)
                            n[t].isDataTexture ? e.push(bh(n[t].image)) : e.push(bh(n[t]))
                    } else
                        e = bh(n);
                    t.images[n.uuid] = {
                        uuid: n.uuid,
                        url: e
                    }
                }
                i.image = n.uuid
            }
            return e || (t.textures[this.uuid] = i),
            i
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
        transformUv(t) {
            if (300 !== this.mapping)
                return t;
            if (t.applyMatrix3(this.matrix),
            t.x < 0 || t.x > 1)
                switch (this.wrapS) {
                case xl:
                    t.x = t.x - Math.floor(t.x);
                    break;
                case _l:
                    t.x = t.x < 0 ? 0 : 1;
                    break;
                case wl:
                    1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                }
            if (t.y < 0 || t.y > 1)
                switch (this.wrapT) {
                case xl:
                    t.y = t.y - Math.floor(t.y);
                    break;
                case _l:
                    t.y = t.y < 0 ? 0 : 1;
                    break;
                case wl:
                    1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                }
            return this.flipY && (t.y = 1 - t.y),
            t
        }
        set needsUpdate(t) {
            !0 === t && this.version++
        }
    }
    function bh(t) {
        return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? xh.getDataURL(t) : t.data ? {
            data: Array.prototype.slice.call(t.data),
            width: t.width,
            height: t.height,
            type: t.data.constructor.name
        } : (console.warn("THREE.Texture: Unable to serialize Texture."),
        {})
    }
    wh.DEFAULT_IMAGE = void 0,
    wh.DEFAULT_MAPPING = 300,
    wh.prototype.isTexture = !0;
    class Mh {
        constructor(t=0, e=0, i=0, n=1) {
            this.x = t,
            this.y = e,
            this.z = i,
            this.w = n
        }
        get width() {
            return this.z
        }
        set width(t) {
            this.z = t
        }
        get height() {
            return this.w
        }
        set height(t) {
            this.w = t
        }
        set(t, e, i, n) {
            return this.x = t,
            this.y = e,
            this.z = i,
            this.w = n,
            this
        }
        setScalar(t) {
            return this.x = t,
            this.y = t,
            this.z = t,
            this.w = t,
            this
        }
        setX(t) {
            return this.x = t,
            this
        }
        setY(t) {
            return this.y = t,
            this
        }
        setZ(t) {
            return this.z = t,
            this
        }
        setW(t) {
            return this.w = t,
            this
        }
        setComponent(t, e) {
            switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            case 2:
                this.z = e;
                break;
            case 3:
                this.w = e;
                break;
            default:
                throw new Error("index is out of range: " + t)
            }
            return this
        }
        getComponent(t) {
            switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error("index is out of range: " + t)
            }
        }
        clone() {
            return new this.constructor(this.x,this.y,this.z,this.w)
        }
        copy(t) {
            return this.x = t.x,
            this.y = t.y,
            this.z = t.z,
            this.w = void 0 !== t.w ? t.w : 1,
            this
        }
        add(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(t, e)) : (this.x += t.x,
            this.y += t.y,
            this.z += t.z,
            this.w += t.w,
            this)
        }
        addScalar(t) {
            return this.x += t,
            this.y += t,
            this.z += t,
            this.w += t,
            this
        }
        addVectors(t, e) {
            return this.x = t.x + e.x,
            this.y = t.y + e.y,
            this.z = t.z + e.z,
            this.w = t.w + e.w,
            this
        }
        addScaledVector(t, e) {
            return this.x += t.x * e,
            this.y += t.y * e,
            this.z += t.z * e,
            this.w += t.w * e,
            this
        }
        sub(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(t, e)) : (this.x -= t.x,
            this.y -= t.y,
            this.z -= t.z,
            this.w -= t.w,
            this)
        }
        subScalar(t) {
            return this.x -= t,
            this.y -= t,
            this.z -= t,
            this.w -= t,
            this
        }
        subVectors(t, e) {
            return this.x = t.x - e.x,
            this.y = t.y - e.y,
            this.z = t.z - e.z,
            this.w = t.w - e.w,
            this
        }
        multiply(t) {
            return this.x *= t.x,
            this.y *= t.y,
            this.z *= t.z,
            this.w *= t.w,
            this
        }
        multiplyScalar(t) {
            return this.x *= t,
            this.y *= t,
            this.z *= t,
            this.w *= t,
            this
        }
        applyMatrix4(t) {
            const e = this.x
              , i = this.y
              , n = this.z
              , r = this.w
              , s = t.elements;
            return this.x = s[0] * e + s[4] * i + s[8] * n + s[12] * r,
            this.y = s[1] * e + s[5] * i + s[9] * n + s[13] * r,
            this.z = s[2] * e + s[6] * i + s[10] * n + s[14] * r,
            this.w = s[3] * e + s[7] * i + s[11] * n + s[15] * r,
            this
        }
        divideScalar(t) {
            return this.multiplyScalar(1 / t)
        }
        setAxisAngleFromQuaternion(t) {
            this.w = 2 * Math.acos(t.w);
            const e = Math.sqrt(1 - t.w * t.w);
            return e < 1e-4 ? (this.x = 1,
            this.y = 0,
            this.z = 0) : (this.x = t.x / e,
            this.y = t.y / e,
            this.z = t.z / e),
            this
        }
        setAxisAngleFromRotationMatrix(t) {
            let e, i, n, r;
            const s = .01
              , a = .1
              , o = t.elements
              , l = o[0]
              , c = o[4]
              , h = o[8]
              , u = o[1]
              , d = o[5]
              , p = o[9]
              , f = o[2]
              , m = o[6]
              , g = o[10];
            if (Math.abs(c - u) < s && Math.abs(h - f) < s && Math.abs(p - m) < s) {
                if (Math.abs(c + u) < a && Math.abs(h + f) < a && Math.abs(p + m) < a && Math.abs(l + d + g - 3) < a)
                    return this.set(1, 0, 0, 0),
                    this;
                e = Math.PI;
                const t = (l + 1) / 2
                  , o = (d + 1) / 2
                  , v = (g + 1) / 2
                  , y = (c + u) / 4
                  , x = (h + f) / 4
                  , _ = (p + m) / 4;
                return t > o && t > v ? t < s ? (i = 0,
                n = .707106781,
                r = .707106781) : (i = Math.sqrt(t),
                n = y / i,
                r = x / i) : o > v ? o < s ? (i = .707106781,
                n = 0,
                r = .707106781) : (n = Math.sqrt(o),
                i = y / n,
                r = _ / n) : v < s ? (i = .707106781,
                n = .707106781,
                r = 0) : (r = Math.sqrt(v),
                i = x / r,
                n = _ / r),
                this.set(i, n, r, e),
                this
            }
            let v = Math.sqrt((m - p) * (m - p) + (h - f) * (h - f) + (u - c) * (u - c));
            return Math.abs(v) < .001 && (v = 1),
            this.x = (m - p) / v,
            this.y = (h - f) / v,
            this.z = (u - c) / v,
            this.w = Math.acos((l + d + g - 1) / 2),
            this
        }
        min(t) {
            return this.x = Math.min(this.x, t.x),
            this.y = Math.min(this.y, t.y),
            this.z = Math.min(this.z, t.z),
            this.w = Math.min(this.w, t.w),
            this
        }
        max(t) {
            return this.x = Math.max(this.x, t.x),
            this.y = Math.max(this.y, t.y),
            this.z = Math.max(this.z, t.z),
            this.w = Math.max(this.w, t.w),
            this
        }
        clamp(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)),
            this.y = Math.max(t.y, Math.min(e.y, this.y)),
            this.z = Math.max(t.z, Math.min(e.z, this.z)),
            this.w = Math.max(t.w, Math.min(e.w, this.w)),
            this
        }
        clampScalar(t, e) {
            return this.x = Math.max(t, Math.min(e, this.x)),
            this.y = Math.max(t, Math.min(e, this.y)),
            this.z = Math.max(t, Math.min(e, this.z)),
            this.w = Math.max(t, Math.min(e, this.w)),
            this
        }
        clampLength(t, e) {
            const i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
        }
        floor() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.z = Math.floor(this.z),
            this.w = Math.floor(this.w),
            this
        }
        ceil() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.z = Math.ceil(this.z),
            this.w = Math.ceil(this.w),
            this
        }
        round() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this.z = Math.round(this.z),
            this.w = Math.round(this.w),
            this
        }
        roundToZero() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
            this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
            this
        }
        negate() {
            return this.x = -this.x,
            this.y = -this.y,
            this.z = -this.z,
            this.w = -this.w,
            this
        }
        dot(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        }
        normalize() {
            return this.divideScalar(this.length() || 1)
        }
        setLength(t) {
            return this.normalize().multiplyScalar(t)
        }
        lerp(t, e) {
            return this.x += (t.x - this.x) * e,
            this.y += (t.y - this.y) * e,
            this.z += (t.z - this.z) * e,
            this.w += (t.w - this.w) * e,
            this
        }
        lerpVectors(t, e, i) {
            return this.x = t.x + (e.x - t.x) * i,
            this.y = t.y + (e.y - t.y) * i,
            this.z = t.z + (e.z - t.z) * i,
            this.w = t.w + (e.w - t.w) * i,
            this
        }
        equals(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
        }
        fromArray(t, e=0) {
            return this.x = t[e],
            this.y = t[e + 1],
            this.z = t[e + 2],
            this.w = t[e + 3],
            this
        }
        toArray(t=[], e=0) {
            return t[e] = this.x,
            t[e + 1] = this.y,
            t[e + 2] = this.z,
            t[e + 3] = this.w,
            t
        }
        fromBufferAttribute(t, e, i) {
            return void 0 !== i && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),
            this.x = t.getX(e),
            this.y = t.getY(e),
            this.z = t.getZ(e),
            this.w = t.getW(e),
            this
        }
        random() {
            return this.x = Math.random(),
            this.y = Math.random(),
            this.z = Math.random(),
            this.w = Math.random(),
            this
        }
    }
    Mh.prototype.isVector4 = !0;
    class Sh extends oh {
        constructor(t, e, i) {
            super(),
            this.width = t,
            this.height = e,
            this.depth = 1,
            this.scissor = new Mh(0,0,t,e),
            this.scissorTest = !1,
            this.viewport = new Mh(0,0,t,e),
            i = i || {},
            this.texture = new wh(void 0,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.encoding),
            this.texture.image = {},
            this.texture.image.width = t,
            this.texture.image.height = e,
            this.texture.image.depth = 1,
            this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps,
            this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : Tl,
            this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer,
            this.stencilBuffer = void 0 !== i.stencilBuffer && i.stencilBuffer,
            this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null
        }
        setTexture(t) {
            t.image = {
                width: this.width,
                height: this.height,
                depth: this.depth
            },
            this.texture = t
        }
        setSize(t, e, i=1) {
            this.width === t && this.height === e && this.depth === i || (this.width = t,
            this.height = e,
            this.depth = i,
            this.texture.image.width = t,
            this.texture.image.height = e,
            this.texture.image.depth = i,
            this.dispose()),
            this.viewport.set(0, 0, t, e),
            this.scissor.set(0, 0, t, e)
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(t) {
            return this.width = t.width,
            this.height = t.height,
            this.depth = t.depth,
            this.viewport.copy(t.viewport),
            this.texture = t.texture.clone(),
            this.depthBuffer = t.depthBuffer,
            this.stencilBuffer = t.stencilBuffer,
            this.depthTexture = t.depthTexture,
            this
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }
    Sh.prototype.isWebGLRenderTarget = !0;
    (class extends Sh {
        constructor(t, e, i) {
            super(t, e, i),
            this.samples = 4
        }
        copy(t) {
            return super.copy.call(this, t),
            this.samples = t.samples,
            this
        }
    }
    ).prototype.isWebGLMultisampleRenderTarget = !0;
    class Th {
        constructor(t=0, e=0, i=0, n=1) {
            this._x = t,
            this._y = e,
            this._z = i,
            this._w = n
        }
        static slerp(t, e, i, n) {
            return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),
            i.slerpQuaternions(t, e, n)
        }
        static slerpFlat(t, e, i, n, r, s, a) {
            let o = i[n + 0]
              , l = i[n + 1]
              , c = i[n + 2]
              , h = i[n + 3];
            const u = r[s + 0]
              , d = r[s + 1]
              , p = r[s + 2]
              , f = r[s + 3];
            if (0 === a)
                return t[e + 0] = o,
                t[e + 1] = l,
                t[e + 2] = c,
                void (t[e + 3] = h);
            if (1 === a)
                return t[e + 0] = u,
                t[e + 1] = d,
                t[e + 2] = p,
                void (t[e + 3] = f);
            if (h !== f || o !== u || l !== d || c !== p) {
                let t = 1 - a;
                const e = o * u + l * d + c * p + h * f
                  , i = e >= 0 ? 1 : -1
                  , n = 1 - e * e;
                if (n > Number.EPSILON) {
                    const r = Math.sqrt(n)
                      , s = Math.atan2(r, e * i);
                    t = Math.sin(t * s) / r,
                    a = Math.sin(a * s) / r
                }
                const r = a * i;
                if (o = o * t + u * r,
                l = l * t + d * r,
                c = c * t + p * r,
                h = h * t + f * r,
                t === 1 - a) {
                    const t = 1 / Math.sqrt(o * o + l * l + c * c + h * h);
                    o *= t,
                    l *= t,
                    c *= t,
                    h *= t
                }
            }
            t[e] = o,
            t[e + 1] = l,
            t[e + 2] = c,
            t[e + 3] = h
        }
        static multiplyQuaternionsFlat(t, e, i, n, r, s) {
            const a = i[n]
              , o = i[n + 1]
              , l = i[n + 2]
              , c = i[n + 3]
              , h = r[s]
              , u = r[s + 1]
              , d = r[s + 2]
              , p = r[s + 3];
            return t[e] = a * p + c * h + o * d - l * u,
            t[e + 1] = o * p + c * u + l * h - a * d,
            t[e + 2] = l * p + c * d + a * u - o * h,
            t[e + 3] = c * p - a * h - o * u - l * d,
            t
        }
        get x() {
            return this._x
        }
        set x(t) {
            this._x = t,
            this._onChangeCallback()
        }
        get y() {
            return this._y
        }
        set y(t) {
            this._y = t,
            this._onChangeCallback()
        }
        get z() {
            return this._z
        }
        set z(t) {
            this._z = t,
            this._onChangeCallback()
        }
        get w() {
            return this._w
        }
        set w(t) {
            this._w = t,
            this._onChangeCallback()
        }
        set(t, e, i, n) {
            return this._x = t,
            this._y = e,
            this._z = i,
            this._w = n,
            this._onChangeCallback(),
            this
        }
        clone() {
            return new this.constructor(this._x,this._y,this._z,this._w)
        }
        copy(t) {
            return this._x = t.x,
            this._y = t.y,
            this._z = t.z,
            this._w = t.w,
            this._onChangeCallback(),
            this
        }
        setFromEuler(t, e) {
            if (!t || !t.isEuler)
                throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            const i = t._x
              , n = t._y
              , r = t._z
              , s = t._order
              , a = Math.cos
              , o = Math.sin
              , l = a(i / 2)
              , c = a(n / 2)
              , h = a(r / 2)
              , u = o(i / 2)
              , d = o(n / 2)
              , p = o(r / 2);
            switch (s) {
            case "XYZ":
                this._x = u * c * h + l * d * p,
                this._y = l * d * h - u * c * p,
                this._z = l * c * p + u * d * h,
                this._w = l * c * h - u * d * p;
                break;
            case "YXZ":
                this._x = u * c * h + l * d * p,
                this._y = l * d * h - u * c * p,
                this._z = l * c * p - u * d * h,
                this._w = l * c * h + u * d * p;
                break;
            case "ZXY":
                this._x = u * c * h - l * d * p,
                this._y = l * d * h + u * c * p,
                this._z = l * c * p + u * d * h,
                this._w = l * c * h - u * d * p;
                break;
            case "ZYX":
                this._x = u * c * h - l * d * p,
                this._y = l * d * h + u * c * p,
                this._z = l * c * p - u * d * h,
                this._w = l * c * h + u * d * p;
                break;
            case "YZX":
                this._x = u * c * h + l * d * p,
                this._y = l * d * h + u * c * p,
                this._z = l * c * p - u * d * h,
                this._w = l * c * h - u * d * p;
                break;
            case "XZY":
                this._x = u * c * h - l * d * p,
                this._y = l * d * h - u * c * p,
                this._z = l * c * p + u * d * h,
                this._w = l * c * h + u * d * p;
                break;
            default:
                console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s)
            }
            return !1 !== e && this._onChangeCallback(),
            this
        }
        setFromAxisAngle(t, e) {
            const i = e / 2
              , n = Math.sin(i);
            return this._x = t.x * n,
            this._y = t.y * n,
            this._z = t.z * n,
            this._w = Math.cos(i),
            this._onChangeCallback(),
            this
        }
        setFromRotationMatrix(t) {
            const e = t.elements
              , i = e[0]
              , n = e[4]
              , r = e[8]
              , s = e[1]
              , a = e[5]
              , o = e[9]
              , l = e[2]
              , c = e[6]
              , h = e[10]
              , u = i + a + h;
            if (u > 0) {
                const t = .5 / Math.sqrt(u + 1);
                this._w = .25 / t,
                this._x = (c - o) * t,
                this._y = (r - l) * t,
                this._z = (s - n) * t
            } else if (i > a && i > h) {
                const t = 2 * Math.sqrt(1 + i - a - h);
                this._w = (c - o) / t,
                this._x = .25 * t,
                this._y = (n + s) / t,
                this._z = (r + l) / t
            } else if (a > h) {
                const t = 2 * Math.sqrt(1 + a - i - h);
                this._w = (r - l) / t,
                this._x = (n + s) / t,
                this._y = .25 * t,
                this._z = (o + c) / t
            } else {
                const t = 2 * Math.sqrt(1 + h - i - a);
                this._w = (s - n) / t,
                this._x = (r + l) / t,
                this._y = (o + c) / t,
                this._z = .25 * t
            }
            return this._onChangeCallback(),
            this
        }
        setFromUnitVectors(t, e) {
            let i = t.dot(e) + 1;
            return i < Number.EPSILON ? (i = 0,
            Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y,
            this._y = t.x,
            this._z = 0,
            this._w = i) : (this._x = 0,
            this._y = -t.z,
            this._z = t.y,
            this._w = i)) : (this._x = t.y * e.z - t.z * e.y,
            this._y = t.z * e.x - t.x * e.z,
            this._z = t.x * e.y - t.y * e.x,
            this._w = i),
            this.normalize()
        }
        angleTo(t) {
            return 2 * Math.acos(Math.abs(dh(this.dot(t), -1, 1)))
        }
        rotateTowards(t, e) {
            const i = this.angleTo(t);
            if (0 === i)
                return this;
            const n = Math.min(1, e / i);
            return this.slerp(t, n),
            this
        }
        identity() {
            return this.set(0, 0, 0, 1)
        }
        invert() {
            return this.conjugate()
        }
        conjugate() {
            return this._x *= -1,
            this._y *= -1,
            this._z *= -1,
            this._onChangeCallback(),
            this
        }
        dot(t) {
            return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
        }
        lengthSq() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        }
        length() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        }
        normalize() {
            let t = this.length();
            return 0 === t ? (this._x = 0,
            this._y = 0,
            this._z = 0,
            this._w = 1) : (t = 1 / t,
            this._x = this._x * t,
            this._y = this._y * t,
            this._z = this._z * t,
            this._w = this._w * t),
            this._onChangeCallback(),
            this
        }
        multiply(t, e) {
            return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),
            this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
        }
        premultiply(t) {
            return this.multiplyQuaternions(t, this)
        }
        multiplyQuaternions(t, e) {
            const i = t._x
              , n = t._y
              , r = t._z
              , s = t._w
              , a = e._x
              , o = e._y
              , l = e._z
              , c = e._w;
            return this._x = i * c + s * a + n * l - r * o,
            this._y = n * c + s * o + r * a - i * l,
            this._z = r * c + s * l + i * o - n * a,
            this._w = s * c - i * a - n * o - r * l,
            this._onChangeCallback(),
            this
        }
        slerp(t, e) {
            if (0 === e)
                return this;
            if (1 === e)
                return this.copy(t);
            const i = this._x
              , n = this._y
              , r = this._z
              , s = this._w;
            let a = s * t._w + i * t._x + n * t._y + r * t._z;
            if (a < 0 ? (this._w = -t._w,
            this._x = -t._x,
            this._y = -t._y,
            this._z = -t._z,
            a = -a) : this.copy(t),
            a >= 1)
                return this._w = s,
                this._x = i,
                this._y = n,
                this._z = r,
                this;
            const o = 1 - a * a;
            if (o <= Number.EPSILON) {
                const t = 1 - e;
                return this._w = t * s + e * this._w,
                this._x = t * i + e * this._x,
                this._y = t * n + e * this._y,
                this._z = t * r + e * this._z,
                this.normalize(),
                this._onChangeCallback(),
                this
            }
            const l = Math.sqrt(o)
              , c = Math.atan2(l, a)
              , h = Math.sin((1 - e) * c) / l
              , u = Math.sin(e * c) / l;
            return this._w = s * h + this._w * u,
            this._x = i * h + this._x * u,
            this._y = n * h + this._y * u,
            this._z = r * h + this._z * u,
            this._onChangeCallback(),
            this
        }
        slerpQuaternions(t, e, i) {
            this.copy(t).slerp(e, i)
        }
        equals(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
        }
        fromArray(t, e=0) {
            return this._x = t[e],
            this._y = t[e + 1],
            this._z = t[e + 2],
            this._w = t[e + 3],
            this._onChangeCallback(),
            this
        }
        toArray(t=[], e=0) {
            return t[e] = this._x,
            t[e + 1] = this._y,
            t[e + 2] = this._z,
            t[e + 3] = this._w,
            t
        }
        fromBufferAttribute(t, e) {
            return this._x = t.getX(e),
            this._y = t.getY(e),
            this._z = t.getZ(e),
            this._w = t.getW(e),
            this
        }
        _onChange(t) {
            return this._onChangeCallback = t,
            this
        }
        _onChangeCallback() {}
    }
    Th.prototype.isQuaternion = !0;
    class Eh {
        constructor(t=0, e=0, i=0) {
            this.x = t,
            this.y = e,
            this.z = i
        }
        set(t, e, i) {
            return void 0 === i && (i = this.z),
            this.x = t,
            this.y = e,
            this.z = i,
            this
        }
        setScalar(t) {
            return this.x = t,
            this.y = t,
            this.z = t,
            this
        }
        setX(t) {
            return this.x = t,
            this
        }
        setY(t) {
            return this.y = t,
            this
        }
        setZ(t) {
            return this.z = t,
            this
        }
        setComponent(t, e) {
            switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            case 2:
                this.z = e;
                break;
            default:
                throw new Error("index is out of range: " + t)
            }
            return this
        }
        getComponent(t) {
            switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error("index is out of range: " + t)
            }
        }
        clone() {
            return new this.constructor(this.x,this.y,this.z)
        }
        copy(t) {
            return this.x = t.x,
            this.y = t.y,
            this.z = t.z,
            this
        }
        add(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(t, e)) : (this.x += t.x,
            this.y += t.y,
            this.z += t.z,
            this)
        }
        addScalar(t) {
            return this.x += t,
            this.y += t,
            this.z += t,
            this
        }
        addVectors(t, e) {
            return this.x = t.x + e.x,
            this.y = t.y + e.y,
            this.z = t.z + e.z,
            this
        }
        addScaledVector(t, e) {
            return this.x += t.x * e,
            this.y += t.y * e,
            this.z += t.z * e,
            this
        }
        sub(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(t, e)) : (this.x -= t.x,
            this.y -= t.y,
            this.z -= t.z,
            this)
        }
        subScalar(t) {
            return this.x -= t,
            this.y -= t,
            this.z -= t,
            this
        }
        subVectors(t, e) {
            return this.x = t.x - e.x,
            this.y = t.y - e.y,
            this.z = t.z - e.z,
            this
        }
        multiply(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),
            this.multiplyVectors(t, e)) : (this.x *= t.x,
            this.y *= t.y,
            this.z *= t.z,
            this)
        }
        multiplyScalar(t) {
            return this.x *= t,
            this.y *= t,
            this.z *= t,
            this
        }
        multiplyVectors(t, e) {
            return this.x = t.x * e.x,
            this.y = t.y * e.y,
            this.z = t.z * e.z,
            this
        }
        applyEuler(t) {
            return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),
            this.applyQuaternion(Ah.setFromEuler(t))
        }
        applyAxisAngle(t, e) {
            return this.applyQuaternion(Ah.setFromAxisAngle(t, e))
        }
        applyMatrix3(t) {
            const e = this.x
              , i = this.y
              , n = this.z
              , r = t.elements;
            return this.x = r[0] * e + r[3] * i + r[6] * n,
            this.y = r[1] * e + r[4] * i + r[7] * n,
            this.z = r[2] * e + r[5] * i + r[8] * n,
            this
        }
        applyNormalMatrix(t) {
            return this.applyMatrix3(t).normalize()
        }
        applyMatrix4(t) {
            const e = this.x
              , i = this.y
              , n = this.z
              , r = t.elements
              , s = 1 / (r[3] * e + r[7] * i + r[11] * n + r[15]);
            return this.x = (r[0] * e + r[4] * i + r[8] * n + r[12]) * s,
            this.y = (r[1] * e + r[5] * i + r[9] * n + r[13]) * s,
            this.z = (r[2] * e + r[6] * i + r[10] * n + r[14]) * s,
            this
        }
        applyQuaternion(t) {
            const e = this.x
              , i = this.y
              , n = this.z
              , r = t.x
              , s = t.y
              , a = t.z
              , o = t.w
              , l = o * e + s * n - a * i
              , c = o * i + a * e - r * n
              , h = o * n + r * i - s * e
              , u = -r * e - s * i - a * n;
            return this.x = l * o + u * -r + c * -a - h * -s,
            this.y = c * o + u * -s + h * -r - l * -a,
            this.z = h * o + u * -a + l * -s - c * -r,
            this
        }
        project(t) {
            return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
        }
        unproject(t) {
            return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
        }
        transformDirection(t) {
            const e = this.x
              , i = this.y
              , n = this.z
              , r = t.elements;
            return this.x = r[0] * e + r[4] * i + r[8] * n,
            this.y = r[1] * e + r[5] * i + r[9] * n,
            this.z = r[2] * e + r[6] * i + r[10] * n,
            this.normalize()
        }
        divide(t) {
            return this.x /= t.x,
            this.y /= t.y,
            this.z /= t.z,
            this
        }
        divideScalar(t) {
            return this.multiplyScalar(1 / t)
        }
        min(t) {
            return this.x = Math.min(this.x, t.x),
            this.y = Math.min(this.y, t.y),
            this.z = Math.min(this.z, t.z),
            this
        }
        max(t) {
            return this.x = Math.max(this.x, t.x),
            this.y = Math.max(this.y, t.y),
            this.z = Math.max(this.z, t.z),
            this
        }
        clamp(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)),
            this.y = Math.max(t.y, Math.min(e.y, this.y)),
            this.z = Math.max(t.z, Math.min(e.z, this.z)),
            this
        }
        clampScalar(t, e) {
            return this.x = Math.max(t, Math.min(e, this.x)),
            this.y = Math.max(t, Math.min(e, this.y)),
            this.z = Math.max(t, Math.min(e, this.z)),
            this
        }
        clampLength(t, e) {
            const i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
        }
        floor() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.z = Math.floor(this.z),
            this
        }
        ceil() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.z = Math.ceil(this.z),
            this
        }
        round() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this.z = Math.round(this.z),
            this
        }
        roundToZero() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
            this
        }
        negate() {
            return this.x = -this.x,
            this.y = -this.y,
            this.z = -this.z,
            this
        }
        dot(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        }
        normalize() {
            return this.divideScalar(this.length() || 1)
        }
        setLength(t) {
            return this.normalize().multiplyScalar(t)
        }
        lerp(t, e) {
            return this.x += (t.x - this.x) * e,
            this.y += (t.y - this.y) * e,
            this.z += (t.z - this.z) * e,
            this
        }
        lerpVectors(t, e, i) {
            return this.x = t.x + (e.x - t.x) * i,
            this.y = t.y + (e.y - t.y) * i,
            this.z = t.z + (e.z - t.z) * i,
            this
        }
        cross(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),
            this.crossVectors(t, e)) : this.crossVectors(this, t)
        }
        crossVectors(t, e) {
            const i = t.x
              , n = t.y
              , r = t.z
              , s = e.x
              , a = e.y
              , o = e.z;
            return this.x = n * o - r * a,
            this.y = r * s - i * o,
            this.z = i * a - n * s,
            this
        }
        projectOnVector(t) {
            const e = t.lengthSq();
            if (0 === e)
                return this.set(0, 0, 0);
            const i = t.dot(this) / e;
            return this.copy(t).multiplyScalar(i)
        }
        projectOnPlane(t) {
            return Lh.copy(this).projectOnVector(t),
            this.sub(Lh)
        }
        reflect(t) {
            return this.sub(Lh.copy(t).multiplyScalar(2 * this.dot(t)))
        }
        angleTo(t) {
            const e = Math.sqrt(this.lengthSq() * t.lengthSq());
            if (0 === e)
                return Math.PI / 2;
            const i = this.dot(t) / e;
            return Math.acos(dh(i, -1, 1))
        }
        distanceTo(t) {
            return Math.sqrt(this.distanceToSquared(t))
        }
        distanceToSquared(t) {
            const e = this.x - t.x
              , i = this.y - t.y
              , n = this.z - t.z;
            return e * e + i * i + n * n
        }
        manhattanDistanceTo(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
        }
        setFromSpherical(t) {
            return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
        }
        setFromSphericalCoords(t, e, i) {
            const n = Math.sin(e) * t;
            return this.x = n * Math.sin(i),
            this.y = Math.cos(e) * t,
            this.z = n * Math.cos(i),
            this
        }
        setFromCylindrical(t) {
            return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
        }
        setFromCylindricalCoords(t, e, i) {
            return this.x = t * Math.sin(e),
            this.y = i,
            this.z = t * Math.cos(e),
            this
        }
        setFromMatrixPosition(t) {
            const e = t.elements;
            return this.x = e[12],
            this.y = e[13],
            this.z = e[14],
            this
        }
        setFromMatrixScale(t) {
            const e = this.setFromMatrixColumn(t, 0).length()
              , i = this.setFromMatrixColumn(t, 1).length()
              , n = this.setFromMatrixColumn(t, 2).length();
            return this.x = e,
            this.y = i,
            this.z = n,
            this
        }
        setFromMatrixColumn(t, e) {
            return this.fromArray(t.elements, 4 * e)
        }
        setFromMatrix3Column(t, e) {
            return this.fromArray(t.elements, 3 * e)
        }
        equals(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z
        }
        fromArray(t, e=0) {
            return this.x = t[e],
            this.y = t[e + 1],
            this.z = t[e + 2],
            this
        }
        toArray(t=[], e=0) {
            return t[e] = this.x,
            t[e + 1] = this.y,
            t[e + 2] = this.z,
            t
        }
        fromBufferAttribute(t, e, i) {
            return void 0 !== i && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),
            this.x = t.getX(e),
            this.y = t.getY(e),
            this.z = t.getZ(e),
            this
        }
        random() {
            return this.x = Math.random(),
            this.y = Math.random(),
            this.z = Math.random(),
            this
        }
    }
    Eh.prototype.isVector3 = !0;
    const Lh = new Eh
      , Ah = new Th;
    class Ch {
        constructor(t=new Eh(1 / 0,1 / 0,1 / 0), e=new Eh(-1 / 0,-1 / 0,-1 / 0)) {
            this.min = t,
            this.max = e
        }
        set(t, e) {
            return this.min.copy(t),
            this.max.copy(e),
            this
        }
        setFromArray(t) {
            let e = 1 / 0
              , i = 1 / 0
              , n = 1 / 0
              , r = -1 / 0
              , s = -1 / 0
              , a = -1 / 0;
            for (let o = 0, l = t.length; o < l; o += 3) {
                const l = t[o]
                  , c = t[o + 1]
                  , h = t[o + 2];
                l < e && (e = l),
                c < i && (i = c),
                h < n && (n = h),
                l > r && (r = l),
                c > s && (s = c),
                h > a && (a = h)
            }
            return this.min.set(e, i, n),
            this.max.set(r, s, a),
            this
        }
        setFromBufferAttribute(t) {
            let e = 1 / 0
              , i = 1 / 0
              , n = 1 / 0
              , r = -1 / 0
              , s = -1 / 0
              , a = -1 / 0;
            for (let o = 0, l = t.count; o < l; o++) {
                const l = t.getX(o)
                  , c = t.getY(o)
                  , h = t.getZ(o);
                l < e && (e = l),
                c < i && (i = c),
                h < n && (n = h),
                l > r && (r = l),
                c > s && (s = c),
                h > a && (a = h)
            }
            return this.min.set(e, i, n),
            this.max.set(r, s, a),
            this
        }
        setFromPoints(t) {
            this.makeEmpty();
            for (let e = 0, i = t.length; e < i; e++)
                this.expandByPoint(t[e]);
            return this
        }
        setFromCenterAndSize(t, e) {
            const i = Rh.copy(e).multiplyScalar(.5);
            return this.min.copy(t).sub(i),
            this.max.copy(t).add(i),
            this
        }
        setFromObject(t) {
            return this.makeEmpty(),
            this.expandByObject(t)
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(t) {
            return this.min.copy(t.min),
            this.max.copy(t.max),
            this
        }
        makeEmpty() {
            return this.min.x = this.min.y = this.min.z = 1 / 0,
            this.max.x = this.max.y = this.max.z = -1 / 0,
            this
        }
        isEmpty() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        }
        getCenter(t) {
            return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"),
            t = new Eh),
            this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
        }
        getSize(t) {
            return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"),
            t = new Eh),
            this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
        }
        expandByPoint(t) {
            return this.min.min(t),
            this.max.max(t),
            this
        }
        expandByVector(t) {
            return this.min.sub(t),
            this.max.add(t),
            this
        }
        expandByScalar(t) {
            return this.min.addScalar(-t),
            this.max.addScalar(t),
            this
        }
        expandByObject(t) {
            t.updateWorldMatrix(!1, !1);
            const e = t.geometry;
            void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(),
            Ih.copy(e.boundingBox),
            Ih.applyMatrix4(t.matrixWorld),
            this.union(Ih));
            const i = t.children;
            for (let t = 0, e = i.length; t < e; t++)
                this.expandByObject(i[t]);
            return this
        }
        containsPoint(t) {
            return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
        }
        containsBox(t) {
            return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
        }
        getParameter(t, e) {
            return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"),
            e = new Eh),
            e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
        }
        intersectsBox(t) {
            return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
        }
        intersectsSphere(t) {
            return this.clampPoint(t.center, Rh),
            Rh.distanceToSquared(t.center) <= t.radius * t.radius
        }
        intersectsPlane(t) {
            let e, i;
            return t.normal.x > 0 ? (e = t.normal.x * this.min.x,
            i = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x,
            i = t.normal.x * this.min.x),
            t.normal.y > 0 ? (e += t.normal.y * this.min.y,
            i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y,
            i += t.normal.y * this.min.y),
            t.normal.z > 0 ? (e += t.normal.z * this.min.z,
            i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z,
            i += t.normal.z * this.min.z),
            e <= -t.constant && i >= -t.constant
        }
        intersectsTriangle(t) {
            if (this.isEmpty())
                return !1;
            this.getCenter(Fh),
            Hh.subVectors(this.max, Fh),
            Dh.subVectors(t.a, Fh),
            Nh.subVectors(t.b, Fh),
            Oh.subVectors(t.c, Fh),
            zh.subVectors(Nh, Dh),
            kh.subVectors(Oh, Nh),
            Bh.subVectors(Dh, Oh);
            let e = [0, -zh.z, zh.y, 0, -kh.z, kh.y, 0, -Bh.z, Bh.y, zh.z, 0, -zh.x, kh.z, 0, -kh.x, Bh.z, 0, -Bh.x, -zh.y, zh.x, 0, -kh.y, kh.x, 0, -Bh.y, Bh.x, 0];
            return !!Vh(e, Dh, Nh, Oh, Hh) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1],
            !!Vh(e, Dh, Nh, Oh, Hh) && (Uh.crossVectors(zh, kh),
            e = [Uh.x, Uh.y, Uh.z],
            Vh(e, Dh, Nh, Oh, Hh)))
        }
        clampPoint(t, e) {
            return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"),
            e = new Eh),
            e.copy(t).clamp(this.min, this.max)
        }
        distanceToPoint(t) {
            return Rh.copy(t).clamp(this.min, this.max).sub(t).length()
        }
        getBoundingSphere(t) {
            return void 0 === t && console.error("THREE.Box3: .getBoundingSphere() target is now required"),
            this.getCenter(t.center),
            t.radius = .5 * this.getSize(Rh).length(),
            t
        }
        intersect(t) {
            return this.min.max(t.min),
            this.max.min(t.max),
            this.isEmpty() && this.makeEmpty(),
            this
        }
        union(t) {
            return this.min.min(t.min),
            this.max.max(t.max),
            this
        }
        applyMatrix4(t) {
            return this.isEmpty() || (Ph[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
            Ph[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
            Ph[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
            Ph[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
            Ph[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
            Ph[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
            Ph[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
            Ph[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
            this.setFromPoints(Ph)),
            this
        }
        translate(t) {
            return this.min.add(t),
            this.max.add(t),
            this
        }
        equals(t) {
            return t.min.equals(this.min) && t.max.equals(this.max)
        }
    }
    Ch.prototype.isBox3 = !0;
    const Ph = [new Eh, new Eh, new Eh, new Eh, new Eh, new Eh, new Eh, new Eh]
      , Rh = new Eh
      , Ih = new Ch
      , Dh = new Eh
      , Nh = new Eh
      , Oh = new Eh
      , zh = new Eh
      , kh = new Eh
      , Bh = new Eh
      , Fh = new Eh
      , Hh = new Eh
      , Uh = new Eh
      , Gh = new Eh;
    function Vh(t, e, i, n, r) {
        for (let s = 0, a = t.length - 3; s <= a; s += 3) {
            Gh.fromArray(t, s);
            const a = r.x * Math.abs(Gh.x) + r.y * Math.abs(Gh.y) + r.z * Math.abs(Gh.z)
              , o = e.dot(Gh)
              , l = i.dot(Gh)
              , c = n.dot(Gh);
            if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > a)
                return !1
        }
        return !0
    }
    const Wh = new Ch
      , qh = new Eh
      , jh = new Eh
      , Yh = new Eh;
    class Xh {
        constructor(t=new Eh, e=-1) {
            this.center = t,
            this.radius = e
        }
        set(t, e) {
            return this.center.copy(t),
            this.radius = e,
            this
        }
        setFromPoints(t, e) {
            const i = this.center;
            void 0 !== e ? i.copy(e) : Wh.setFromPoints(t).getCenter(i);
            let n = 0;
            for (let e = 0, r = t.length; e < r; e++)
                n = Math.max(n, i.distanceToSquared(t[e]));
            return this.radius = Math.sqrt(n),
            this
        }
        copy(t) {
            return this.center.copy(t.center),
            this.radius = t.radius,
            this
        }
        isEmpty() {
            return this.radius < 0
        }
        makeEmpty() {
            return this.center.set(0, 0, 0),
            this.radius = -1,
            this
        }
        containsPoint(t) {
            return t.distanceToSquared(this.center) <= this.radius * this.radius
        }
        distanceToPoint(t) {
            return t.distanceTo(this.center) - this.radius
        }
        intersectsSphere(t) {
            const e = this.radius + t.radius;
            return t.center.distanceToSquared(this.center) <= e * e
        }
        intersectsBox(t) {
            return t.intersectsSphere(this)
        }
        intersectsPlane(t) {
            return Math.abs(t.distanceToPoint(this.center)) <= this.radius
        }
        clampPoint(t, e) {
            const i = this.center.distanceToSquared(t);
            return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"),
            e = new Eh),
            e.copy(t),
            i > this.radius * this.radius && (e.sub(this.center).normalize(),
            e.multiplyScalar(this.radius).add(this.center)),
            e
        }
        getBoundingBox(t) {
            return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"),
            t = new Ch),
            this.isEmpty() ? (t.makeEmpty(),
            t) : (t.set(this.center, this.center),
            t.expandByScalar(this.radius),
            t)
        }
        applyMatrix4(t) {
            return this.center.applyMatrix4(t),
            this.radius = this.radius * t.getMaxScaleOnAxis(),
            this
        }
        translate(t) {
            return this.center.add(t),
            this
        }
        expandByPoint(t) {
            Yh.subVectors(t, this.center);
            const e = Yh.lengthSq();
            if (e > this.radius * this.radius) {
                const t = Math.sqrt(e)
                  , i = .5 * (t - this.radius);
                this.center.add(Yh.multiplyScalar(i / t)),
                this.radius += i
            }
            return this
        }
        union(t) {
            return jh.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius),
            this.expandByPoint(qh.copy(t.center).add(jh)),
            this.expandByPoint(qh.copy(t.center).sub(jh)),
            this
        }
        equals(t) {
            return t.center.equals(this.center) && t.radius === this.radius
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }
    const Jh = new Eh
      , Zh = new Eh
      , Qh = new Eh
      , $h = new Eh
      , Kh = new Eh
      , tu = new Eh
      , eu = new Eh;
    class iu {
        constructor(t=new Eh, e=new Eh(0,0,-1)) {
            this.origin = t,
            this.direction = e
        }
        set(t, e) {
            return this.origin.copy(t),
            this.direction.copy(e),
            this
        }
        copy(t) {
            return this.origin.copy(t.origin),
            this.direction.copy(t.direction),
            this
        }
        at(t, e) {
            return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"),
            e = new Eh),
            e.copy(this.direction).multiplyScalar(t).add(this.origin)
        }
        lookAt(t) {
            return this.direction.copy(t).sub(this.origin).normalize(),
            this
        }
        recast(t) {
            return this.origin.copy(this.at(t, Jh)),
            this
        }
        closestPointToPoint(t, e) {
            void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"),
            e = new Eh),
            e.subVectors(t, this.origin);
            const i = e.dot(this.direction);
            return i < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(i).add(this.origin)
        }
        distanceToPoint(t) {
            return Math.sqrt(this.distanceSqToPoint(t))
        }
        distanceSqToPoint(t) {
            const e = Jh.subVectors(t, this.origin).dot(this.direction);
            return e < 0 ? this.origin.distanceToSquared(t) : (Jh.copy(this.direction).multiplyScalar(e).add(this.origin),
            Jh.distanceToSquared(t))
        }
        distanceSqToSegment(t, e, i, n) {
            Zh.copy(t).add(e).multiplyScalar(.5),
            Qh.copy(e).sub(t).normalize(),
            $h.copy(this.origin).sub(Zh);
            const r = .5 * t.distanceTo(e)
              , s = -this.direction.dot(Qh)
              , a = $h.dot(this.direction)
              , o = -$h.dot(Qh)
              , l = $h.lengthSq()
              , c = Math.abs(1 - s * s);
            let h, u, d, p;
            if (c > 0)
                if (h = s * o - a,
                u = s * a - o,
                p = r * c,
                h >= 0)
                    if (u >= -p)
                        if (u <= p) {
                            const t = 1 / c;
                            h *= t,
                            u *= t,
                            d = h * (h + s * u + 2 * a) + u * (s * h + u + 2 * o) + l
                        } else
                            u = r,
                            h = Math.max(0, -(s * u + a)),
                            d = -h * h + u * (u + 2 * o) + l;
                    else
                        u = -r,
                        h = Math.max(0, -(s * u + a)),
                        d = -h * h + u * (u + 2 * o) + l;
                else
                    u <= -p ? (h = Math.max(0, -(-s * r + a)),
                    u = h > 0 ? -r : Math.min(Math.max(-r, -o), r),
                    d = -h * h + u * (u + 2 * o) + l) : u <= p ? (h = 0,
                    u = Math.min(Math.max(-r, -o), r),
                    d = u * (u + 2 * o) + l) : (h = Math.max(0, -(s * r + a)),
                    u = h > 0 ? r : Math.min(Math.max(-r, -o), r),
                    d = -h * h + u * (u + 2 * o) + l);
            else
                u = s > 0 ? -r : r,
                h = Math.max(0, -(s * u + a)),
                d = -h * h + u * (u + 2 * o) + l;
            return i && i.copy(this.direction).multiplyScalar(h).add(this.origin),
            n && n.copy(Qh).multiplyScalar(u).add(Zh),
            d
        }
        intersectSphere(t, e) {
            Jh.subVectors(t.center, this.origin);
            const i = Jh.dot(this.direction)
              , n = Jh.dot(Jh) - i * i
              , r = t.radius * t.radius;
            if (n > r)
                return null;
            const s = Math.sqrt(r - n)
              , a = i - s
              , o = i + s;
            return a < 0 && o < 0 ? null : a < 0 ? this.at(o, e) : this.at(a, e)
        }
        intersectsSphere(t) {
            return this.distanceSqToPoint(t.center) <= t.radius * t.radius
        }
        distanceToPlane(t) {
            const e = t.normal.dot(this.direction);
            if (0 === e)
                return 0 === t.distanceToPoint(this.origin) ? 0 : null;
            const i = -(this.origin.dot(t.normal) + t.constant) / e;
            return i >= 0 ? i : null
        }
        intersectPlane(t, e) {
            const i = this.distanceToPlane(t);
            return null === i ? null : this.at(i, e)
        }
        intersectsPlane(t) {
            const e = t.distanceToPoint(this.origin);
            if (0 === e)
                return !0;
            return t.normal.dot(this.direction) * e < 0
        }
        intersectBox(t, e) {
            let i, n, r, s, a, o;
            const l = 1 / this.direction.x
              , c = 1 / this.direction.y
              , h = 1 / this.direction.z
              , u = this.origin;
            return l >= 0 ? (i = (t.min.x - u.x) * l,
            n = (t.max.x - u.x) * l) : (i = (t.max.x - u.x) * l,
            n = (t.min.x - u.x) * l),
            c >= 0 ? (r = (t.min.y - u.y) * c,
            s = (t.max.y - u.y) * c) : (r = (t.max.y - u.y) * c,
            s = (t.min.y - u.y) * c),
            i > s || r > n ? null : ((r > i || i != i) && (i = r),
            (s < n || n != n) && (n = s),
            h >= 0 ? (a = (t.min.z - u.z) * h,
            o = (t.max.z - u.z) * h) : (a = (t.max.z - u.z) * h,
            o = (t.min.z - u.z) * h),
            i > o || a > n ? null : ((a > i || i != i) && (i = a),
            (o < n || n != n) && (n = o),
            n < 0 ? null : this.at(i >= 0 ? i : n, e)))
        }
        intersectsBox(t) {
            return null !== this.intersectBox(t, Jh)
        }
        intersectTriangle(t, e, i, n, r) {
            Kh.subVectors(e, t),
            tu.subVectors(i, t),
            eu.crossVectors(Kh, tu);
            let s, a = this.direction.dot(eu);
            if (a > 0) {
                if (n)
                    return null;
                s = 1
            } else {
                if (!(a < 0))
                    return null;
                s = -1,
                a = -a
            }
            $h.subVectors(this.origin, t);
            const o = s * this.direction.dot(tu.crossVectors($h, tu));
            if (o < 0)
                return null;
            const l = s * this.direction.dot(Kh.cross($h));
            if (l < 0)
                return null;
            if (o + l > a)
                return null;
            const c = -s * $h.dot(eu);
            return c < 0 ? null : this.at(c / a, r)
        }
        applyMatrix4(t) {
            return this.origin.applyMatrix4(t),
            this.direction.transformDirection(t),
            this
        }
        equals(t) {
            return t.origin.equals(this.origin) && t.direction.equals(this.direction)
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }
    class nu {
        constructor() {
            this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
        }
        set(t, e, i, n, r, s, a, o, l, c, h, u, d, p, f, m) {
            const g = this.elements;
            return g[0] = t,
            g[4] = e,
            g[8] = i,
            g[12] = n,
            g[1] = r,
            g[5] = s,
            g[9] = a,
            g[13] = o,
            g[2] = l,
            g[6] = c,
            g[10] = h,
            g[14] = u,
            g[3] = d,
            g[7] = p,
            g[11] = f,
            g[15] = m,
            this
        }
        identity() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
        }
        clone() {
            return (new nu).fromArray(this.elements)
        }
        copy(t) {
            const e = this.elements
              , i = t.elements;
            return e[0] = i[0],
            e[1] = i[1],
            e[2] = i[2],
            e[3] = i[3],
            e[4] = i[4],
            e[5] = i[5],
            e[6] = i[6],
            e[7] = i[7],
            e[8] = i[8],
            e[9] = i[9],
            e[10] = i[10],
            e[11] = i[11],
            e[12] = i[12],
            e[13] = i[13],
            e[14] = i[14],
            e[15] = i[15],
            this
        }
        copyPosition(t) {
            const e = this.elements
              , i = t.elements;
            return e[12] = i[12],
            e[13] = i[13],
            e[14] = i[14],
            this
        }
        setFromMatrix3(t) {
            const e = t.elements;
            return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1),
            this
        }
        extractBasis(t, e, i) {
            return t.setFromMatrixColumn(this, 0),
            e.setFromMatrixColumn(this, 1),
            i.setFromMatrixColumn(this, 2),
            this
        }
        makeBasis(t, e, i) {
            return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1),
            this
        }
        extractRotation(t) {
            const e = this.elements
              , i = t.elements
              , n = 1 / ru.setFromMatrixColumn(t, 0).length()
              , r = 1 / ru.setFromMatrixColumn(t, 1).length()
              , s = 1 / ru.setFromMatrixColumn(t, 2).length();
            return e[0] = i[0] * n,
            e[1] = i[1] * n,
            e[2] = i[2] * n,
            e[3] = 0,
            e[4] = i[4] * r,
            e[5] = i[5] * r,
            e[6] = i[6] * r,
            e[7] = 0,
            e[8] = i[8] * s,
            e[9] = i[9] * s,
            e[10] = i[10] * s,
            e[11] = 0,
            e[12] = 0,
            e[13] = 0,
            e[14] = 0,
            e[15] = 1,
            this
        }
        makeRotationFromEuler(t) {
            t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            const e = this.elements
              , i = t.x
              , n = t.y
              , r = t.z
              , s = Math.cos(i)
              , a = Math.sin(i)
              , o = Math.cos(n)
              , l = Math.sin(n)
              , c = Math.cos(r)
              , h = Math.sin(r);
            if ("XYZ" === t.order) {
                const t = s * c
                  , i = s * h
                  , n = a * c
                  , r = a * h;
                e[0] = o * c,
                e[4] = -o * h,
                e[8] = l,
                e[1] = i + n * l,
                e[5] = t - r * l,
                e[9] = -a * o,
                e[2] = r - t * l,
                e[6] = n + i * l,
                e[10] = s * o
            } else if ("YXZ" === t.order) {
                const t = o * c
                  , i = o * h
                  , n = l * c
                  , r = l * h;
                e[0] = t + r * a,
                e[4] = n * a - i,
                e[8] = s * l,
                e[1] = s * h,
                e[5] = s * c,
                e[9] = -a,
                e[2] = i * a - n,
                e[6] = r + t * a,
                e[10] = s * o
            } else if ("ZXY" === t.order) {
                const t = o * c
                  , i = o * h
                  , n = l * c
                  , r = l * h;
                e[0] = t - r * a,
                e[4] = -s * h,
                e[8] = n + i * a,
                e[1] = i + n * a,
                e[5] = s * c,
                e[9] = r - t * a,
                e[2] = -s * l,
                e[6] = a,
                e[10] = s * o
            } else if ("ZYX" === t.order) {
                const t = s * c
                  , i = s * h
                  , n = a * c
                  , r = a * h;
                e[0] = o * c,
                e[4] = n * l - i,
                e[8] = t * l + r,
                e[1] = o * h,
                e[5] = r * l + t,
                e[9] = i * l - n,
                e[2] = -l,
                e[6] = a * o,
                e[10] = s * o
            } else if ("YZX" === t.order) {
                const t = s * o
                  , i = s * l
                  , n = a * o
                  , r = a * l;
                e[0] = o * c,
                e[4] = r - t * h,
                e[8] = n * h + i,
                e[1] = h,
                e[5] = s * c,
                e[9] = -a * c,
                e[2] = -l * c,
                e[6] = i * h + n,
                e[10] = t - r * h
            } else if ("XZY" === t.order) {
                const t = s * o
                  , i = s * l
                  , n = a * o
                  , r = a * l;
                e[0] = o * c,
                e[4] = -h,
                e[8] = l * c,
                e[1] = t * h + r,
                e[5] = s * c,
                e[9] = i * h - n,
                e[2] = n * h - i,
                e[6] = a * c,
                e[10] = r * h + t
            }
            return e[3] = 0,
            e[7] = 0,
            e[11] = 0,
            e[12] = 0,
            e[13] = 0,
            e[14] = 0,
            e[15] = 1,
            this
        }
        makeRotationFromQuaternion(t) {
            return this.compose(au, t, ou)
        }
        lookAt(t, e, i) {
            const n = this.elements;
            return hu.subVectors(t, e),
            0 === hu.lengthSq() && (hu.z = 1),
            hu.normalize(),
            lu.crossVectors(i, hu),
            0 === lu.lengthSq() && (1 === Math.abs(i.z) ? hu.x += 1e-4 : hu.z += 1e-4,
            hu.normalize(),
            lu.crossVectors(i, hu)),
            lu.normalize(),
            cu.crossVectors(hu, lu),
            n[0] = lu.x,
            n[4] = cu.x,
            n[8] = hu.x,
            n[1] = lu.y,
            n[5] = cu.y,
            n[9] = hu.y,
            n[2] = lu.z,
            n[6] = cu.z,
            n[10] = hu.z,
            this
        }
        multiply(t, e) {
            return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),
            this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
        }
        premultiply(t) {
            return this.multiplyMatrices(t, this)
        }
        multiplyMatrices(t, e) {
            const i = t.elements
              , n = e.elements
              , r = this.elements
              , s = i[0]
              , a = i[4]
              , o = i[8]
              , l = i[12]
              , c = i[1]
              , h = i[5]
              , u = i[9]
              , d = i[13]
              , p = i[2]
              , f = i[6]
              , m = i[10]
              , g = i[14]
              , v = i[3]
              , y = i[7]
              , x = i[11]
              , _ = i[15]
              , w = n[0]
              , b = n[4]
              , M = n[8]
              , S = n[12]
              , T = n[1]
              , E = n[5]
              , L = n[9]
              , A = n[13]
              , C = n[2]
              , P = n[6]
              , R = n[10]
              , I = n[14]
              , D = n[3]
              , N = n[7]
              , O = n[11]
              , z = n[15];
            return r[0] = s * w + a * T + o * C + l * D,
            r[4] = s * b + a * E + o * P + l * N,
            r[8] = s * M + a * L + o * R + l * O,
            r[12] = s * S + a * A + o * I + l * z,
            r[1] = c * w + h * T + u * C + d * D,
            r[5] = c * b + h * E + u * P + d * N,
            r[9] = c * M + h * L + u * R + d * O,
            r[13] = c * S + h * A + u * I + d * z,
            r[2] = p * w + f * T + m * C + g * D,
            r[6] = p * b + f * E + m * P + g * N,
            r[10] = p * M + f * L + m * R + g * O,
            r[14] = p * S + f * A + m * I + g * z,
            r[3] = v * w + y * T + x * C + _ * D,
            r[7] = v * b + y * E + x * P + _ * N,
            r[11] = v * M + y * L + x * R + _ * O,
            r[15] = v * S + y * A + x * I + _ * z,
            this
        }
        multiplyScalar(t) {
            const e = this.elements;
            return e[0] *= t,
            e[4] *= t,
            e[8] *= t,
            e[12] *= t,
            e[1] *= t,
            e[5] *= t,
            e[9] *= t,
            e[13] *= t,
            e[2] *= t,
            e[6] *= t,
            e[10] *= t,
            e[14] *= t,
            e[3] *= t,
            e[7] *= t,
            e[11] *= t,
            e[15] *= t,
            this
        }
        determinant() {
            const t = this.elements
              , e = t[0]
              , i = t[4]
              , n = t[8]
              , r = t[12]
              , s = t[1]
              , a = t[5]
              , o = t[9]
              , l = t[13]
              , c = t[2]
              , h = t[6]
              , u = t[10]
              , d = t[14];
            return t[3] * (+r * o * h - n * l * h - r * a * u + i * l * u + n * a * d - i * o * d) + t[7] * (+e * o * d - e * l * u + r * s * u - n * s * d + n * l * c - r * o * c) + t[11] * (+e * l * h - e * a * d - r * s * h + i * s * d + r * a * c - i * l * c) + t[15] * (-n * a * c - e * o * h + e * a * u + n * s * h - i * s * u + i * o * c)
        }
        transpose() {
            const t = this.elements;
            let e;
            return e = t[1],
            t[1] = t[4],
            t[4] = e,
            e = t[2],
            t[2] = t[8],
            t[8] = e,
            e = t[6],
            t[6] = t[9],
            t[9] = e,
            e = t[3],
            t[3] = t[12],
            t[12] = e,
            e = t[7],
            t[7] = t[13],
            t[13] = e,
            e = t[11],
            t[11] = t[14],
            t[14] = e,
            this
        }
        setPosition(t, e, i) {
            const n = this.elements;
            return t.isVector3 ? (n[12] = t.x,
            n[13] = t.y,
            n[14] = t.z) : (n[12] = t,
            n[13] = e,
            n[14] = i),
            this
        }
        invert() {
            const t = this.elements
              , e = t[0]
              , i = t[1]
              , n = t[2]
              , r = t[3]
              , s = t[4]
              , a = t[5]
              , o = t[6]
              , l = t[7]
              , c = t[8]
              , h = t[9]
              , u = t[10]
              , d = t[11]
              , p = t[12]
              , f = t[13]
              , m = t[14]
              , g = t[15]
              , v = h * m * l - f * u * l + f * o * d - a * m * d - h * o * g + a * u * g
              , y = p * u * l - c * m * l - p * o * d + s * m * d + c * o * g - s * u * g
              , x = c * f * l - p * h * l + p * a * d - s * f * d - c * a * g + s * h * g
              , _ = p * h * o - c * f * o - p * a * u + s * f * u + c * a * m - s * h * m
              , w = e * v + i * y + n * x + r * _;
            if (0 === w)
                return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            const b = 1 / w;
            return t[0] = v * b,
            t[1] = (f * u * r - h * m * r - f * n * d + i * m * d + h * n * g - i * u * g) * b,
            t[2] = (a * m * r - f * o * r + f * n * l - i * m * l - a * n * g + i * o * g) * b,
            t[3] = (h * o * r - a * u * r - h * n * l + i * u * l + a * n * d - i * o * d) * b,
            t[4] = y * b,
            t[5] = (c * m * r - p * u * r + p * n * d - e * m * d - c * n * g + e * u * g) * b,
            t[6] = (p * o * r - s * m * r - p * n * l + e * m * l + s * n * g - e * o * g) * b,
            t[7] = (s * u * r - c * o * r + c * n * l - e * u * l - s * n * d + e * o * d) * b,
            t[8] = x * b,
            t[9] = (p * h * r - c * f * r - p * i * d + e * f * d + c * i * g - e * h * g) * b,
            t[10] = (s * f * r - p * a * r + p * i * l - e * f * l - s * i * g + e * a * g) * b,
            t[11] = (c * a * r - s * h * r - c * i * l + e * h * l + s * i * d - e * a * d) * b,
            t[12] = _ * b,
            t[13] = (c * f * n - p * h * n + p * i * u - e * f * u - c * i * m + e * h * m) * b,
            t[14] = (p * a * n - s * f * n - p * i * o + e * f * o + s * i * m - e * a * m) * b,
            t[15] = (s * h * n - c * a * n + c * i * o - e * h * o - s * i * u + e * a * u) * b,
            this
        }
        scale(t) {
            const e = this.elements
              , i = t.x
              , n = t.y
              , r = t.z;
            return e[0] *= i,
            e[4] *= n,
            e[8] *= r,
            e[1] *= i,
            e[5] *= n,
            e[9] *= r,
            e[2] *= i,
            e[6] *= n,
            e[10] *= r,
            e[3] *= i,
            e[7] *= n,
            e[11] *= r,
            this
        }
        getMaxScaleOnAxis() {
            const t = this.elements
              , e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2]
              , i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6]
              , n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
            return Math.sqrt(Math.max(e, i, n))
        }
        makeTranslation(t, e, i) {
            return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1),
            this
        }
        makeRotationX(t) {
            const e = Math.cos(t)
              , i = Math.sin(t);
            return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1),
            this
        }
        makeRotationY(t) {
            const e = Math.cos(t)
              , i = Math.sin(t);
            return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1),
            this
        }
        makeRotationZ(t) {
            const e = Math.cos(t)
              , i = Math.sin(t);
            return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
        }
        makeRotationAxis(t, e) {
            const i = Math.cos(e)
              , n = Math.sin(e)
              , r = 1 - i
              , s = t.x
              , a = t.y
              , o = t.z
              , l = r * s
              , c = r * a;
            return this.set(l * s + i, l * a - n * o, l * o + n * a, 0, l * a + n * o, c * a + i, c * o - n * s, 0, l * o - n * a, c * o + n * s, r * o * o + i, 0, 0, 0, 0, 1),
            this
        }
        makeScale(t, e, i) {
            return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1),
            this
        }
        makeShear(t, e, i) {
            return this.set(1, e, i, 0, t, 1, i, 0, t, e, 1, 0, 0, 0, 0, 1),
            this
        }
        compose(t, e, i) {
            const n = this.elements
              , r = e._x
              , s = e._y
              , a = e._z
              , o = e._w
              , l = r + r
              , c = s + s
              , h = a + a
              , u = r * l
              , d = r * c
              , p = r * h
              , f = s * c
              , m = s * h
              , g = a * h
              , v = o * l
              , y = o * c
              , x = o * h
              , _ = i.x
              , w = i.y
              , b = i.z;
            return n[0] = (1 - (f + g)) * _,
            n[1] = (d + x) * _,
            n[2] = (p - y) * _,
            n[3] = 0,
            n[4] = (d - x) * w,
            n[5] = (1 - (u + g)) * w,
            n[6] = (m + v) * w,
            n[7] = 0,
            n[8] = (p + y) * b,
            n[9] = (m - v) * b,
            n[10] = (1 - (u + f)) * b,
            n[11] = 0,
            n[12] = t.x,
            n[13] = t.y,
            n[14] = t.z,
            n[15] = 1,
            this
        }
        decompose(t, e, i) {
            const n = this.elements;
            let r = ru.set(n[0], n[1], n[2]).length();
            const s = ru.set(n[4], n[5], n[6]).length()
              , a = ru.set(n[8], n[9], n[10]).length();
            this.determinant() < 0 && (r = -r),
            t.x = n[12],
            t.y = n[13],
            t.z = n[14],
            su.copy(this);
            const o = 1 / r
              , l = 1 / s
              , c = 1 / a;
            return su.elements[0] *= o,
            su.elements[1] *= o,
            su.elements[2] *= o,
            su.elements[4] *= l,
            su.elements[5] *= l,
            su.elements[6] *= l,
            su.elements[8] *= c,
            su.elements[9] *= c,
            su.elements[10] *= c,
            e.setFromRotationMatrix(su),
            i.x = r,
            i.y = s,
            i.z = a,
            this
        }
        makePerspective(t, e, i, n, r, s) {
            void 0 === s && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            const a = this.elements
              , o = 2 * r / (e - t)
              , l = 2 * r / (i - n)
              , c = (e + t) / (e - t)
              , h = (i + n) / (i - n)
              , u = -(s + r) / (s - r)
              , d = -2 * s * r / (s - r);
            return a[0] = o,
            a[4] = 0,
            a[8] = c,
            a[12] = 0,
            a[1] = 0,
            a[5] = l,
            a[9] = h,
            a[13] = 0,
            a[2] = 0,
            a[6] = 0,
            a[10] = u,
            a[14] = d,
            a[3] = 0,
            a[7] = 0,
            a[11] = -1,
            a[15] = 0,
            this
        }
        makeOrthographic(t, e, i, n, r, s) {
            const a = this.elements
              , o = 1 / (e - t)
              , l = 1 / (i - n)
              , c = 1 / (s - r)
              , h = (e + t) * o
              , u = (i + n) * l
              , d = (s + r) * c;
            return a[0] = 2 * o,
            a[4] = 0,
            a[8] = 0,
            a[12] = -h,
            a[1] = 0,
            a[5] = 2 * l,
            a[9] = 0,
            a[13] = -u,
            a[2] = 0,
            a[6] = 0,
            a[10] = -2 * c,
            a[14] = -d,
            a[3] = 0,
            a[7] = 0,
            a[11] = 0,
            a[15] = 1,
            this
        }
        equals(t) {
            const e = this.elements
              , i = t.elements;
            for (let t = 0; t < 16; t++)
                if (e[t] !== i[t])
                    return !1;
            return !0
        }
        fromArray(t, e=0) {
            for (let i = 0; i < 16; i++)
                this.elements[i] = t[i + e];
            return this
        }
        toArray(t=[], e=0) {
            const i = this.elements;
            return t[e] = i[0],
            t[e + 1] = i[1],
            t[e + 2] = i[2],
            t[e + 3] = i[3],
            t[e + 4] = i[4],
            t[e + 5] = i[5],
            t[e + 6] = i[6],
            t[e + 7] = i[7],
            t[e + 8] = i[8],
            t[e + 9] = i[9],
            t[e + 10] = i[10],
            t[e + 11] = i[11],
            t[e + 12] = i[12],
            t[e + 13] = i[13],
            t[e + 14] = i[14],
            t[e + 15] = i[15],
            t
        }
    }
    nu.prototype.isMatrix4 = !0;
    const ru = new Eh
      , su = new nu
      , au = new Eh(0,0,0)
      , ou = new Eh(1,1,1)
      , lu = new Eh
      , cu = new Eh
      , hu = new Eh
      , uu = new nu
      , du = new Th;
    class pu {
        constructor(t=0, e=0, i=0, n=pu.DefaultOrder) {
            this._x = t,
            this._y = e,
            this._z = i,
            this._order = n
        }
        get x() {
            return this._x
        }
        set x(t) {
            this._x = t,
            this._onChangeCallback()
        }
        get y() {
            return this._y
        }
        set y(t) {
            this._y = t,
            this._onChangeCallback()
        }
        get z() {
            return this._z
        }
        set z(t) {
            this._z = t,
            this._onChangeCallback()
        }
        get order() {
            return this._order
        }
        set order(t) {
            this._order = t,
            this._onChangeCallback()
        }
        set(t, e, i, n) {
            return this._x = t,
            this._y = e,
            this._z = i,
            this._order = n || this._order,
            this._onChangeCallback(),
            this
        }
        clone() {
            return new this.constructor(this._x,this._y,this._z,this._order)
        }
        copy(t) {
            return this._x = t._x,
            this._y = t._y,
            this._z = t._z,
            this._order = t._order,
            this._onChangeCallback(),
            this
        }
        setFromRotationMatrix(t, e, i) {
            const n = t.elements
              , r = n[0]
              , s = n[4]
              , a = n[8]
              , o = n[1]
              , l = n[5]
              , c = n[9]
              , h = n[2]
              , u = n[6]
              , d = n[10];
            switch (e = e || this._order) {
            case "XYZ":
                this._y = Math.asin(dh(a, -1, 1)),
                Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, d),
                this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(u, l),
                this._z = 0);
                break;
            case "YXZ":
                this._x = Math.asin(-dh(c, -1, 1)),
                Math.abs(c) < .9999999 ? (this._y = Math.atan2(a, d),
                this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-h, r),
                this._z = 0);
                break;
            case "ZXY":
                this._x = Math.asin(dh(u, -1, 1)),
                Math.abs(u) < .9999999 ? (this._y = Math.atan2(-h, d),
                this._z = Math.atan2(-s, l)) : (this._y = 0,
                this._z = Math.atan2(o, r));
                break;
            case "ZYX":
                this._y = Math.asin(-dh(h, -1, 1)),
                Math.abs(h) < .9999999 ? (this._x = Math.atan2(u, d),
                this._z = Math.atan2(o, r)) : (this._x = 0,
                this._z = Math.atan2(-s, l));
                break;
            case "YZX":
                this._z = Math.asin(dh(o, -1, 1)),
                Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, l),
                this._y = Math.atan2(-h, r)) : (this._x = 0,
                this._y = Math.atan2(a, d));
                break;
            case "XZY":
                this._z = Math.asin(-dh(s, -1, 1)),
                Math.abs(s) < .9999999 ? (this._x = Math.atan2(u, l),
                this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-c, d),
                this._y = 0);
                break;
            default:
                console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
            }
            return this._order = e,
            !1 !== i && this._onChangeCallback(),
            this
        }
        setFromQuaternion(t, e, i) {
            return uu.makeRotationFromQuaternion(t),
            this.setFromRotationMatrix(uu, e, i)
        }
        setFromVector3(t, e) {
            return this.set(t.x, t.y, t.z, e || this._order)
        }
        reorder(t) {
            return du.setFromEuler(this),
            this.setFromQuaternion(du, t)
        }
        equals(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
        }
        fromArray(t) {
            return this._x = t[0],
            this._y = t[1],
            this._z = t[2],
            void 0 !== t[3] && (this._order = t[3]),
            this._onChangeCallback(),
            this
        }
        toArray(t=[], e=0) {
            return t[e] = this._x,
            t[e + 1] = this._y,
            t[e + 2] = this._z,
            t[e + 3] = this._order,
            t
        }
        toVector3(t) {
            return t ? t.set(this._x, this._y, this._z) : new Eh(this._x,this._y,this._z)
        }
        _onChange(t) {
            return this._onChangeCallback = t,
            this
        }
        _onChangeCallback() {}
    }
    pu.prototype.isEuler = !0,
    pu.DefaultOrder = "XYZ",
    pu.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
    class fu {
        constructor() {
            this.mask = 1
        }
        set(t) {
            this.mask = 1 << t
        }
        enable(t) {
            this.mask |= 1 << t
        }
        enableAll() {
            this.mask = -1
        }
        toggle(t) {
            this.mask ^= 1 << t
        }
        disable(t) {
            this.mask &= ~(1 << t)
        }
        disableAll() {
            this.mask = 0
        }
        test(t) {
            return !!(this.mask & t.mask)
        }
    }
    let mu = 0;
    const gu = new Eh
      , vu = new Th
      , yu = new nu
      , xu = new Eh
      , _u = new Eh
      , wu = new Eh
      , bu = new Th
      , Mu = new Eh(1,0,0)
      , Su = new Eh(0,1,0)
      , Tu = new Eh(0,0,1)
      , Eu = {
        type: "added"
    }
      , Lu = {
        type: "removed"
    };
    class Au extends oh {
        constructor() {
            super(),
            Object.defineProperty(this, "id", {
                value: mu++
            }),
            this.uuid = uh(),
            this.name = "",
            this.type = "Object3D",
            this.parent = null,
            this.children = [],
            this.up = Au.DefaultUp.clone();
            const t = new Eh
              , e = new pu
              , i = new Th
              , n = new Eh(1,1,1);
            e._onChange((function() {
                i.setFromEuler(e, !1)
            }
            )),
            i._onChange((function() {
                e.setFromQuaternion(i, void 0, !1)
            }
            )),
            Object.defineProperties(this, {
                position: {
                    configurable: !0,
                    enumerable: !0,
                    value: t
                },
                rotation: {
                    configurable: !0,
                    enumerable: !0,
                    value: e
                },
                quaternion: {
                    configurable: !0,
                    enumerable: !0,
                    value: i
                },
                scale: {
                    configurable: !0,
                    enumerable: !0,
                    value: n
                },
                modelViewMatrix: {
                    value: new nu
                },
                normalMatrix: {
                    value: new vh
                }
            }),
            this.matrix = new nu,
            this.matrixWorld = new nu,
            this.matrixAutoUpdate = Au.DefaultMatrixAutoUpdate,
            this.matrixWorldNeedsUpdate = !1,
            this.layers = new fu,
            this.visible = !0,
            this.castShadow = !1,
            this.receiveShadow = !1,
            this.frustumCulled = !0,
            this.renderOrder = 0,
            this.animations = [],
            this.userData = {}
        }
        onBeforeRender() {}
        onAfterRender() {}
        applyMatrix4(t) {
            this.matrixAutoUpdate && this.updateMatrix(),
            this.matrix.premultiply(t),
            this.matrix.decompose(this.position, this.quaternion, this.scale)
        }
        applyQuaternion(t) {
            return this.quaternion.premultiply(t),
            this
        }
        setRotationFromAxisAngle(t, e) {
            this.quaternion.setFromAxisAngle(t, e)
        }
        setRotationFromEuler(t) {
            this.quaternion.setFromEuler(t, !0)
        }
        setRotationFromMatrix(t) {
            this.quaternion.setFromRotationMatrix(t)
        }
        setRotationFromQuaternion(t) {
            this.quaternion.copy(t)
        }
        rotateOnAxis(t, e) {
            return vu.setFromAxisAngle(t, e),
            this.quaternion.multiply(vu),
            this
        }
        rotateOnWorldAxis(t, e) {
            return vu.setFromAxisAngle(t, e),
            this.quaternion.premultiply(vu),
            this
        }
        rotateX(t) {
            return this.rotateOnAxis(Mu, t)
        }
        rotateY(t) {
            return this.rotateOnAxis(Su, t)
        }
        rotateZ(t) {
            return this.rotateOnAxis(Tu, t)
        }
        translateOnAxis(t, e) {
            return gu.copy(t).applyQuaternion(this.quaternion),
            this.position.add(gu.multiplyScalar(e)),
            this
        }
        translateX(t) {
            return this.translateOnAxis(Mu, t)
        }
        translateY(t) {
            return this.translateOnAxis(Su, t)
        }
        translateZ(t) {
            return this.translateOnAxis(Tu, t)
        }
        localToWorld(t) {
            return t.applyMatrix4(this.matrixWorld)
        }
        worldToLocal(t) {
            return t.applyMatrix4(yu.copy(this.matrixWorld).invert())
        }
        lookAt(t, e, i) {
            t.isVector3 ? xu.copy(t) : xu.set(t, e, i);
            const n = this.parent;
            this.updateWorldMatrix(!0, !1),
            _u.setFromMatrixPosition(this.matrixWorld),
            this.isCamera || this.isLight ? yu.lookAt(_u, xu, this.up) : yu.lookAt(xu, _u, this.up),
            this.quaternion.setFromRotationMatrix(yu),
            n && (yu.extractRotation(n.matrixWorld),
            vu.setFromRotationMatrix(yu),
            this.quaternion.premultiply(vu.invert()))
        }
        add(t) {
            if (arguments.length > 1) {
                for (let t = 0; t < arguments.length; t++)
                    this.add(arguments[t]);
                return this
            }
            return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t),
            this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t),
            t.parent = this,
            this.children.push(t),
            t.dispatchEvent(Eu)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t),
            this)
        }
        remove(t) {
            if (arguments.length > 1) {
                for (let t = 0; t < arguments.length; t++)
                    this.remove(arguments[t]);
                return this
            }
            const e = this.children.indexOf(t);
            return -1 !== e && (t.parent = null,
            this.children.splice(e, 1),
            t.dispatchEvent(Lu)),
            this
        }
        clear() {
            for (let t = 0; t < this.children.length; t++) {
                const e = this.children[t];
                e.parent = null,
                e.dispatchEvent(Lu)
            }
            return this.children.length = 0,
            this
        }
        attach(t) {
            return this.updateWorldMatrix(!0, !1),
            yu.copy(this.matrixWorld).invert(),
            null !== t.parent && (t.parent.updateWorldMatrix(!0, !1),
            yu.multiply(t.parent.matrixWorld)),
            t.applyMatrix4(yu),
            this.add(t),
            t.updateWorldMatrix(!1, !0),
            this
        }
        getObjectById(t) {
            return this.getObjectByProperty("id", t)
        }
        getObjectByName(t) {
            return this.getObjectByProperty("name", t)
        }
        getObjectByProperty(t, e) {
            if (this[t] === e)
                return this;
            for (let i = 0, n = this.children.length; i < n; i++) {
                const n = this.children[i].getObjectByProperty(t, e);
                if (void 0 !== n)
                    return n
            }
        }
        getWorldPosition(t) {
            return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"),
            t = new Eh),
            this.updateWorldMatrix(!0, !1),
            t.setFromMatrixPosition(this.matrixWorld)
        }
        getWorldQuaternion(t) {
            return void 0 === t && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),
            t = new Th),
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(_u, t, wu),
            t
        }
        getWorldScale(t) {
            return void 0 === t && (console.warn("THREE.Object3D: .getWorldScale() target is now required"),
            t = new Eh),
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(_u, bu, t),
            t
        }
        getWorldDirection(t) {
            void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"),
            t = new Eh),
            this.updateWorldMatrix(!0, !1);
            const e = this.matrixWorld.elements;
            return t.set(e[8], e[9], e[10]).normalize()
        }
        raycast() {}
        traverse(t) {
            t(this);
            const e = this.children;
            for (let i = 0, n = e.length; i < n; i++)
                e[i].traverse(t)
        }
        traverseVisible(t) {
            if (!1 === this.visible)
                return;
            t(this);
            const e = this.children;
            for (let i = 0, n = e.length; i < n; i++)
                e[i].traverseVisible(t)
        }
        traverseAncestors(t) {
            const e = this.parent;
            null !== e && (t(e),
            e.traverseAncestors(t))
        }
        updateMatrix() {
            this.matrix.compose(this.position, this.quaternion, this.scale),
            this.matrixWorldNeedsUpdate = !0
        }
        updateMatrixWorld(t) {
            this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            this.matrixWorldNeedsUpdate = !1,
            t = !0);
            const e = this.children;
            for (let i = 0, n = e.length; i < n; i++)
                e[i].updateMatrixWorld(t)
        }
        updateWorldMatrix(t, e) {
            const i = this.parent;
            if (!0 === t && null !== i && i.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            !0 === e) {
                const t = this.children;
                for (let e = 0, i = t.length; e < i; e++)
                    t[e].updateWorldMatrix(!1, !0)
            }
        }
        toJSON(t) {
            const e = void 0 === t || "string" == typeof t
              , i = {};
            e && (t = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {},
                skeletons: {},
                animations: {}
            },
            i.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            const n = {};
            function r(e, i) {
                return void 0 === e[i.uuid] && (e[i.uuid] = i.toJSON(t)),
                i.uuid
            }
            if (n.uuid = this.uuid,
            n.type = this.type,
            "" !== this.name && (n.name = this.name),
            !0 === this.castShadow && (n.castShadow = !0),
            !0 === this.receiveShadow && (n.receiveShadow = !0),
            !1 === this.visible && (n.visible = !1),
            !1 === this.frustumCulled && (n.frustumCulled = !1),
            0 !== this.renderOrder && (n.renderOrder = this.renderOrder),
            "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData),
            n.layers = this.layers.mask,
            n.matrix = this.matrix.toArray(),
            !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1),
            this.isInstancedMesh && (n.type = "InstancedMesh",
            n.count = this.count,
            n.instanceMatrix = this.instanceMatrix.toJSON(),
            null !== this.instanceColor && (n.instanceColor = this.instanceColor.toJSON())),
            this.isMesh || this.isLine || this.isPoints) {
                n.geometry = r(t.geometries, this.geometry);
                const e = this.geometry.parameters;
                if (void 0 !== e && void 0 !== e.shapes) {
                    const i = e.shapes;
                    if (Array.isArray(i))
                        for (let e = 0, n = i.length; e < n; e++) {
                            const n = i[e];
                            r(t.shapes, n)
                        }
                    else
                        r(t.shapes, i)
                }
            }
            if (this.isSkinnedMesh && (n.bindMode = this.bindMode,
            n.bindMatrix = this.bindMatrix.toArray(),
            void 0 !== this.skeleton && (r(t.skeletons, this.skeleton),
            n.skeleton = this.skeleton.uuid)),
            void 0 !== this.material)
                if (Array.isArray(this.material)) {
                    const e = [];
                    for (let i = 0, n = this.material.length; i < n; i++)
                        e.push(r(t.materials, this.material[i]));
                    n.material = e
                } else
                    n.material = r(t.materials, this.material);
            if (this.children.length > 0) {
                n.children = [];
                for (let e = 0; e < this.children.length; e++)
                    n.children.push(this.children[e].toJSON(t).object)
            }
            if (this.animations.length > 0) {
                n.animations = [];
                for (let e = 0; e < this.animations.length; e++) {
                    const i = this.animations[e];
                    n.animations.push(r(t.animations, i))
                }
            }
            if (e) {
                const e = s(t.geometries)
                  , n = s(t.materials)
                  , r = s(t.textures)
                  , a = s(t.images)
                  , o = s(t.shapes)
                  , l = s(t.skeletons)
                  , c = s(t.animations);
                e.length > 0 && (i.geometries = e),
                n.length > 0 && (i.materials = n),
                r.length > 0 && (i.textures = r),
                a.length > 0 && (i.images = a),
                o.length > 0 && (i.shapes = o),
                l.length > 0 && (i.skeletons = l),
                c.length > 0 && (i.animations = c)
            }
            return i.object = n,
            i;
            function s(t) {
                const e = [];
                for (const i in t) {
                    const n = t[i];
                    delete n.metadata,
                    e.push(n)
                }
                return e
            }
        }
        clone(t) {
            return (new this.constructor).copy(this, t)
        }
        copy(t, e=!0) {
            if (this.name = t.name,
            this.up.copy(t.up),
            this.position.copy(t.position),
            this.rotation.order = t.rotation.order,
            this.quaternion.copy(t.quaternion),
            this.scale.copy(t.scale),
            this.matrix.copy(t.matrix),
            this.matrixWorld.copy(t.matrixWorld),
            this.matrixAutoUpdate = t.matrixAutoUpdate,
            this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate,
            this.layers.mask = t.layers.mask,
            this.visible = t.visible,
            this.castShadow = t.castShadow,
            this.receiveShadow = t.receiveShadow,
            this.frustumCulled = t.frustumCulled,
            this.renderOrder = t.renderOrder,
            this.userData = JSON.parse(JSON.stringify(t.userData)),
            !0 === e)
                for (let e = 0; e < t.children.length; e++) {
                    const i = t.children[e];
                    this.add(i.clone())
                }
            return this
        }
    }
    Au.DefaultUp = new Eh(0,1,0),
    Au.DefaultMatrixAutoUpdate = !0,
    Au.prototype.isObject3D = !0;
    const Cu = new Eh
      , Pu = new Eh
      , Ru = new vh;
    class Iu {
        constructor(t=new Eh(1,0,0), e=0) {
            this.normal = t,
            this.constant = e
        }
        set(t, e) {
            return this.normal.copy(t),
            this.constant = e,
            this
        }
        setComponents(t, e, i, n) {
            return this.normal.set(t, e, i),
            this.constant = n,
            this
        }
        setFromNormalAndCoplanarPoint(t, e) {
            return this.normal.copy(t),
            this.constant = -e.dot(this.normal),
            this
        }
        setFromCoplanarPoints(t, e, i) {
            const n = Cu.subVectors(i, e).cross(Pu.subVectors(t, e)).normalize();
            return this.setFromNormalAndCoplanarPoint(n, t),
            this
        }
        copy(t) {
            return this.normal.copy(t.normal),
            this.constant = t.constant,
            this
        }
        normalize() {
            const t = 1 / this.normal.length();
            return this.normal.multiplyScalar(t),
            this.constant *= t,
            this
        }
        negate() {
            return this.constant *= -1,
            this.normal.negate(),
            this
        }
        distanceToPoint(t) {
            return this.normal.dot(t) + this.constant
        }
        distanceToSphere(t) {
            return this.distanceToPoint(t.center) - t.radius
        }
        projectPoint(t, e) {
            return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"),
            e = new Eh),
            e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
        }
        intersectLine(t, e) {
            void 0 === e && (console.warn("THREE.Plane: .intersectLine() target is now required"),
            e = new Eh);
            const i = t.delta(Cu)
              , n = this.normal.dot(i);
            if (0 === n)
                return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
            const r = -(t.start.dot(this.normal) + this.constant) / n;
            return r < 0 || r > 1 ? null : e.copy(i).multiplyScalar(r).add(t.start)
        }
        intersectsLine(t) {
            const e = this.distanceToPoint(t.start)
              , i = this.distanceToPoint(t.end);
            return e < 0 && i > 0 || i < 0 && e > 0
        }
        intersectsBox(t) {
            return t.intersectsPlane(this)
        }
        intersectsSphere(t) {
            return t.intersectsPlane(this)
        }
        coplanarPoint(t) {
            return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"),
            t = new Eh),
            t.copy(this.normal).multiplyScalar(-this.constant)
        }
        applyMatrix4(t, e) {
            const i = e || Ru.getNormalMatrix(t)
              , n = this.coplanarPoint(Cu).applyMatrix4(t)
              , r = this.normal.applyMatrix3(i).normalize();
            return this.constant = -n.dot(r),
            this
        }
        translate(t) {
            return this.constant -= t.dot(this.normal),
            this
        }
        equals(t) {
            return t.normal.equals(this.normal) && t.constant === this.constant
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }
    Iu.prototype.isPlane = !0;
    const Du = new Eh
      , Nu = new Eh
      , Ou = new Eh
      , zu = new Eh
      , ku = new Eh
      , Bu = new Eh
      , Fu = new Eh
      , Hu = new Eh
      , Uu = new Eh
      , Gu = new Eh;
    class Vu {
        constructor(t=new Eh, e=new Eh, i=new Eh) {
            this.a = t,
            this.b = e,
            this.c = i
        }
        static getNormal(t, e, i, n) {
            void 0 === n && (console.warn("THREE.Triangle: .getNormal() target is now required"),
            n = new Eh),
            n.subVectors(i, e),
            Du.subVectors(t, e),
            n.cross(Du);
            const r = n.lengthSq();
            return r > 0 ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0)
        }
        static getBarycoord(t, e, i, n, r) {
            Du.subVectors(n, e),
            Nu.subVectors(i, e),
            Ou.subVectors(t, e);
            const s = Du.dot(Du)
              , a = Du.dot(Nu)
              , o = Du.dot(Ou)
              , l = Nu.dot(Nu)
              , c = Nu.dot(Ou)
              , h = s * l - a * a;
            if (void 0 === r && (console.warn("THREE.Triangle: .getBarycoord() target is now required"),
            r = new Eh),
            0 === h)
                return r.set(-2, -1, -1);
            const u = 1 / h
              , d = (l * o - a * c) * u
              , p = (s * c - a * o) * u;
            return r.set(1 - d - p, p, d)
        }
        static containsPoint(t, e, i, n) {
            return this.getBarycoord(t, e, i, n, zu),
            zu.x >= 0 && zu.y >= 0 && zu.x + zu.y <= 1
        }
        static getUV(t, e, i, n, r, s, a, o) {
            return this.getBarycoord(t, e, i, n, zu),
            o.set(0, 0),
            o.addScaledVector(r, zu.x),
            o.addScaledVector(s, zu.y),
            o.addScaledVector(a, zu.z),
            o
        }
        static isFrontFacing(t, e, i, n) {
            return Du.subVectors(i, e),
            Nu.subVectors(t, e),
            Du.cross(Nu).dot(n) < 0
        }
        set(t, e, i) {
            return this.a.copy(t),
            this.b.copy(e),
            this.c.copy(i),
            this
        }
        setFromPointsAndIndices(t, e, i, n) {
            return this.a.copy(t[e]),
            this.b.copy(t[i]),
            this.c.copy(t[n]),
            this
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(t) {
            return this.a.copy(t.a),
            this.b.copy(t.b),
            this.c.copy(t.c),
            this
        }
        getArea() {
            return Du.subVectors(this.c, this.b),
            Nu.subVectors(this.a, this.b),
            .5 * Du.cross(Nu).length()
        }
        getMidpoint(t) {
            return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"),
            t = new Eh),
            t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        }
        getNormal(t) {
            return Vu.getNormal(this.a, this.b, this.c, t)
        }
        getPlane(t) {
            return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"),
            t = new Iu),
            t.setFromCoplanarPoints(this.a, this.b, this.c)
        }
        getBarycoord(t, e) {
            return Vu.getBarycoord(t, this.a, this.b, this.c, e)
        }
        getUV(t, e, i, n, r) {
            return Vu.getUV(t, this.a, this.b, this.c, e, i, n, r)
        }
        containsPoint(t) {
            return Vu.containsPoint(t, this.a, this.b, this.c)
        }
        isFrontFacing(t) {
            return Vu.isFrontFacing(this.a, this.b, this.c, t)
        }
        intersectsBox(t) {
            return t.intersectsTriangle(this)
        }
        closestPointToPoint(t, e) {
            void 0 === e && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),
            e = new Eh);
            const i = this.a
              , n = this.b
              , r = this.c;
            let s, a;
            ku.subVectors(n, i),
            Bu.subVectors(r, i),
            Hu.subVectors(t, i);
            const o = ku.dot(Hu)
              , l = Bu.dot(Hu);
            if (o <= 0 && l <= 0)
                return e.copy(i);
            Uu.subVectors(t, n);
            const c = ku.dot(Uu)
              , h = Bu.dot(Uu);
            if (c >= 0 && h <= c)
                return e.copy(n);
            const u = o * h - c * l;
            if (u <= 0 && o >= 0 && c <= 0)
                return s = o / (o - c),
                e.copy(i).addScaledVector(ku, s);
            Gu.subVectors(t, r);
            const d = ku.dot(Gu)
              , p = Bu.dot(Gu);
            if (p >= 0 && d <= p)
                return e.copy(r);
            const f = d * l - o * p;
            if (f <= 0 && l >= 0 && p <= 0)
                return a = l / (l - p),
                e.copy(i).addScaledVector(Bu, a);
            const m = c * p - d * h;
            if (m <= 0 && h - c >= 0 && d - p >= 0)
                return Fu.subVectors(r, n),
                a = (h - c) / (h - c + (d - p)),
                e.copy(n).addScaledVector(Fu, a);
            const g = 1 / (m + f + u);
            return s = f * g,
            a = u * g,
            e.copy(i).addScaledVector(ku, s).addScaledVector(Bu, a)
        }
        equals(t) {
            return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
        }
    }
    let Wu = 0;
    function qu() {
        Object.defineProperty(this, "id", {
            value: Wu++
        }),
        this.uuid = uh(),
        this.name = "",
        this.type = "Material",
        this.fog = !0,
        this.blending = Co,
        this.side = To,
        this.vertexColors = !1,
        this.opacity = 1,
        this.transparent = !1,
        this.blendSrc = Vo,
        this.blendDst = Wo,
        this.blendEquation = No,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.depthFunc = Ko,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = 519,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilFail = nh,
        this.stencilZFail = nh,
        this.stencilZPass = nh,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaTest = 0,
        this.alphaToCoverage = !1,
        this.premultipliedAlpha = !1,
        this.visible = !0,
        this.toneMapped = !0,
        this.userData = {},
        this.version = 0
    }
    qu.prototype = Object.assign(Object.create(oh.prototype), {
        constructor: qu,
        isMaterial: !0,
        onBuild: function() {},
        onBeforeCompile: function() {},
        customProgramCacheKey: function() {
            return this.onBeforeCompile.toString()
        },
        setValues: function(t) {
            if (void 0 !== t)
                for (const e in t) {
                    const i = t[e];
                    if (void 0 === i) {
                        console.warn("THREE.Material: '" + e + "' parameter is undefined.");
                        continue
                    }
                    if ("shading" === e) {
                        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                        this.flatShading = 1 === i;
                        continue
                    }
                    const n = this[e];
                    void 0 !== n ? n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[e] = i : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                }
        },
        toJSON: function(t) {
            const e = void 0 === t || "string" == typeof t;
            e && (t = {
                textures: {},
                images: {}
            });
            const i = {
                metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };
            function n(t) {
                const e = [];
                for (const i in t) {
                    const n = t[i];
                    delete n.metadata,
                    e.push(n)
                }
                return e
            }
            if (i.uuid = this.uuid,
            i.type = this.type,
            "" !== this.name && (i.name = this.name),
            this.color && this.color.isColor && (i.color = this.color.getHex()),
            void 0 !== this.roughness && (i.roughness = this.roughness),
            void 0 !== this.metalness && (i.metalness = this.metalness),
            this.sheen && this.sheen.isColor && (i.sheen = this.sheen.getHex()),
            this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()),
            this.emissiveIntensity && 1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity),
            this.specular && this.specular.isColor && (i.specular = this.specular.getHex()),
            void 0 !== this.shininess && (i.shininess = this.shininess),
            void 0 !== this.clearcoat && (i.clearcoat = this.clearcoat),
            void 0 !== this.clearcoatRoughness && (i.clearcoatRoughness = this.clearcoatRoughness),
            this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
            this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
            this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid,
            i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
            this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid),
            this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(t).uuid),
            this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(t).uuid),
            this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(t).uuid,
            i.lightMapIntensity = this.lightMapIntensity),
            this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(t).uuid,
            i.aoMapIntensity = this.aoMapIntensity),
            this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(t).uuid,
            i.bumpScale = this.bumpScale),
            this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(t).uuid,
            i.normalMapType = this.normalMapType,
            i.normalScale = this.normalScale.toArray()),
            this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(t).uuid,
            i.displacementScale = this.displacementScale,
            i.displacementBias = this.displacementBias),
            this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(t).uuid),
            this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(t).uuid),
            this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(t).uuid),
            this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(t).uuid),
            this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(t).uuid,
            void 0 !== this.combine && (i.combine = this.combine)),
            void 0 !== this.envMapIntensity && (i.envMapIntensity = this.envMapIntensity),
            void 0 !== this.reflectivity && (i.reflectivity = this.reflectivity),
            void 0 !== this.refractionRatio && (i.refractionRatio = this.refractionRatio),
            this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(t).uuid),
            void 0 !== this.size && (i.size = this.size),
            null !== this.shadowSide && (i.shadowSide = this.shadowSide),
            void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation),
            this.blending !== Co && (i.blending = this.blending),
            this.side !== To && (i.side = this.side),
            this.vertexColors && (i.vertexColors = !0),
            this.opacity < 1 && (i.opacity = this.opacity),
            !0 === this.transparent && (i.transparent = this.transparent),
            i.depthFunc = this.depthFunc,
            i.depthTest = this.depthTest,
            i.depthWrite = this.depthWrite,
            i.colorWrite = this.colorWrite,
            i.stencilWrite = this.stencilWrite,
            i.stencilWriteMask = this.stencilWriteMask,
            i.stencilFunc = this.stencilFunc,
            i.stencilRef = this.stencilRef,
            i.stencilFuncMask = this.stencilFuncMask,
            i.stencilFail = this.stencilFail,
            i.stencilZFail = this.stencilZFail,
            i.stencilZPass = this.stencilZPass,
            this.rotation && 0 !== this.rotation && (i.rotation = this.rotation),
            !0 === this.polygonOffset && (i.polygonOffset = !0),
            0 !== this.polygonOffsetFactor && (i.polygonOffsetFactor = this.polygonOffsetFactor),
            0 !== this.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits),
            this.linewidth && 1 !== this.linewidth && (i.linewidth = this.linewidth),
            void 0 !== this.dashSize && (i.dashSize = this.dashSize),
            void 0 !== this.gapSize && (i.gapSize = this.gapSize),
            void 0 !== this.scale && (i.scale = this.scale),
            !0 === this.dithering && (i.dithering = !0),
            this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
            !0 === this.alphaToCoverage && (i.alphaToCoverage = this.alphaToCoverage),
            !0 === this.premultipliedAlpha && (i.premultipliedAlpha = this.premultipliedAlpha),
            !0 === this.wireframe && (i.wireframe = this.wireframe),
            this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth),
            "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap),
            "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin),
            !0 === this.morphTargets && (i.morphTargets = !0),
            !0 === this.morphNormals && (i.morphNormals = !0),
            !0 === this.skinning && (i.skinning = !0),
            !0 === this.flatShading && (i.flatShading = this.flatShading),
            !1 === this.visible && (i.visible = !1),
            !1 === this.toneMapped && (i.toneMapped = !1),
            "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData),
            e) {
                const e = n(t.textures)
                  , r = n(t.images);
                e.length > 0 && (i.textures = e),
                r.length > 0 && (i.images = r)
            }
            return i
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            this.name = t.name,
            this.fog = t.fog,
            this.blending = t.blending,
            this.side = t.side,
            this.vertexColors = t.vertexColors,
            this.opacity = t.opacity,
            this.transparent = t.transparent,
            this.blendSrc = t.blendSrc,
            this.blendDst = t.blendDst,
            this.blendEquation = t.blendEquation,
            this.blendSrcAlpha = t.blendSrcAlpha,
            this.blendDstAlpha = t.blendDstAlpha,
            this.blendEquationAlpha = t.blendEquationAlpha,
            this.depthFunc = t.depthFunc,
            this.depthTest = t.depthTest,
            this.depthWrite = t.depthWrite,
            this.stencilWriteMask = t.stencilWriteMask,
            this.stencilFunc = t.stencilFunc,
            this.stencilRef = t.stencilRef,
            this.stencilFuncMask = t.stencilFuncMask,
            this.stencilFail = t.stencilFail,
            this.stencilZFail = t.stencilZFail,
            this.stencilZPass = t.stencilZPass,
            this.stencilWrite = t.stencilWrite;
            const e = t.clippingPlanes;
            let i = null;
            if (null !== e) {
                const t = e.length;
                i = new Array(t);
                for (let n = 0; n !== t; ++n)
                    i[n] = e[n].clone()
            }
            return this.clippingPlanes = i,
            this.clipIntersection = t.clipIntersection,
            this.clipShadows = t.clipShadows,
            this.shadowSide = t.shadowSide,
            this.colorWrite = t.colorWrite,
            this.precision = t.precision,
            this.polygonOffset = t.polygonOffset,
            this.polygonOffsetFactor = t.polygonOffsetFactor,
            this.polygonOffsetUnits = t.polygonOffsetUnits,
            this.dithering = t.dithering,
            this.alphaTest = t.alphaTest,
            this.alphaToCoverage = t.alphaToCoverage,
            this.premultipliedAlpha = t.premultipliedAlpha,
            this.visible = t.visible,
            this.toneMapped = t.toneMapped,
            this.userData = JSON.parse(JSON.stringify(t.userData)),
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    Object.defineProperty(qu.prototype, "needsUpdate", {
        set: function(t) {
            !0 === t && this.version++
        }
    });
    const ju = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    }
      , Yu = {
        h: 0,
        s: 0,
        l: 0
    }
      , Xu = {
        h: 0,
        s: 0,
        l: 0
    };
    function Ju(t, e, i) {
        return i < 0 && (i += 1),
        i > 1 && (i -= 1),
        i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - i) : t
    }
    function Zu(t) {
        return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
    }
    function Qu(t) {
        return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
    }
    class $u {
        constructor(t, e, i) {
            return void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i)
        }
        set(t) {
            return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t),
            this
        }
        setScalar(t) {
            return this.r = t,
            this.g = t,
            this.b = t,
            this
        }
        setHex(t) {
            return t = Math.floor(t),
            this.r = (t >> 16 & 255) / 255,
            this.g = (t >> 8 & 255) / 255,
            this.b = (255 & t) / 255,
            this
        }
        setRGB(t, e, i) {
            return this.r = t,
            this.g = e,
            this.b = i,
            this
        }
        setHSL(t, e, i) {
            if (t = function(t, e) {
                return (t % e + e) % e
            }(t, 1),
            e = dh(e, 0, 1),
            i = dh(i, 0, 1),
            0 === e)
                this.r = this.g = this.b = i;
            else {
                const n = i <= .5 ? i * (1 + e) : i + e - i * e
                  , r = 2 * i - n;
                this.r = Ju(r, n, t + 1 / 3),
                this.g = Ju(r, n, t),
                this.b = Ju(r, n, t - 1 / 3)
            }
            return this
        }
        setStyle(t) {
            function e(e) {
                void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
            }
            let i;
            if (i = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)) {
                let t;
                const n = i[1]
                  , r = i[2];
                switch (n) {
                case "rgb":
                case "rgba":
                    if (t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))
                        return this.r = Math.min(255, parseInt(t[1], 10)) / 255,
                        this.g = Math.min(255, parseInt(t[2], 10)) / 255,
                        this.b = Math.min(255, parseInt(t[3], 10)) / 255,
                        e(t[4]),
                        this;
                    if (t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))
                        return this.r = Math.min(100, parseInt(t[1], 10)) / 100,
                        this.g = Math.min(100, parseInt(t[2], 10)) / 100,
                        this.b = Math.min(100, parseInt(t[3], 10)) / 100,
                        e(t[4]),
                        this;
                    break;
                case "hsl":
                case "hsla":
                    if (t = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) {
                        const i = parseFloat(t[1]) / 360
                          , n = parseInt(t[2], 10) / 100
                          , r = parseInt(t[3], 10) / 100;
                        return e(t[4]),
                        this.setHSL(i, n, r)
                    }
                }
            } else if (i = /^\#([A-Fa-f\d]+)$/.exec(t)) {
                const t = i[1]
                  , e = t.length;
                if (3 === e)
                    return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255,
                    this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255,
                    this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255,
                    this;
                if (6 === e)
                    return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255,
                    this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255,
                    this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255,
                    this
            }
            return t && t.length > 0 ? this.setColorName(t) : this
        }
        setColorName(t) {
            const e = ju[t.toLowerCase()];
            return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t),
            this
        }
        clone() {
            return new this.constructor(this.r,this.g,this.b)
        }
        copy(t) {
            return this.r = t.r,
            this.g = t.g,
            this.b = t.b,
            this
        }
        copyGammaToLinear(t, e=2) {
            return this.r = Math.pow(t.r, e),
            this.g = Math.pow(t.g, e),
            this.b = Math.pow(t.b, e),
            this
        }
        copyLinearToGamma(t, e=2) {
            const i = e > 0 ? 1 / e : 1;
            return this.r = Math.pow(t.r, i),
            this.g = Math.pow(t.g, i),
            this.b = Math.pow(t.b, i),
            this
        }
        convertGammaToLinear(t) {
            return this.copyGammaToLinear(this, t),
            this
        }
        convertLinearToGamma(t) {
            return this.copyLinearToGamma(this, t),
            this
        }
        copySRGBToLinear(t) {
            return this.r = Zu(t.r),
            this.g = Zu(t.g),
            this.b = Zu(t.b),
            this
        }
        copyLinearToSRGB(t) {
            return this.r = Qu(t.r),
            this.g = Qu(t.g),
            this.b = Qu(t.b),
            this
        }
        convertSRGBToLinear() {
            return this.copySRGBToLinear(this),
            this
        }
        convertLinearToSRGB() {
            return this.copyLinearToSRGB(this),
            this
        }
        getHex() {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b
        }
        getHexString() {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        }
        getHSL(t) {
            void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"),
            t = {
                h: 0,
                s: 0,
                l: 0
            });
            const e = this.r
              , i = this.g
              , n = this.b
              , r = Math.max(e, i, n)
              , s = Math.min(e, i, n);
            let a, o;
            const l = (s + r) / 2;
            if (s === r)
                a = 0,
                o = 0;
            else {
                const t = r - s;
                switch (o = l <= .5 ? t / (r + s) : t / (2 - r - s),
                r) {
                case e:
                    a = (i - n) / t + (i < n ? 6 : 0);
                    break;
                case i:
                    a = (n - e) / t + 2;
                    break;
                case n:
                    a = (e - i) / t + 4
                }
                a /= 6
            }
            return t.h = a,
            t.s = o,
            t.l = l,
            t
        }
        getStyle() {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        }
        offsetHSL(t, e, i) {
            return this.getHSL(Yu),
            Yu.h += t,
            Yu.s += e,
            Yu.l += i,
            this.setHSL(Yu.h, Yu.s, Yu.l),
            this
        }
        add(t) {
            return this.r += t.r,
            this.g += t.g,
            this.b += t.b,
            this
        }
        addColors(t, e) {
            return this.r = t.r + e.r,
            this.g = t.g + e.g,
            this.b = t.b + e.b,
            this
        }
        addScalar(t) {
            return this.r += t,
            this.g += t,
            this.b += t,
            this
        }
        sub(t) {
            return this.r = Math.max(0, this.r - t.r),
            this.g = Math.max(0, this.g - t.g),
            this.b = Math.max(0, this.b - t.b),
            this
        }
        multiply(t) {
            return this.r *= t.r,
            this.g *= t.g,
            this.b *= t.b,
            this
        }
        multiplyScalar(t) {
            return this.r *= t,
            this.g *= t,
            this.b *= t,
            this
        }
        lerp(t, e) {
            return this.r += (t.r - this.r) * e,
            this.g += (t.g - this.g) * e,
            this.b += (t.b - this.b) * e,
            this
        }
        lerpColors(t, e, i) {
            return this.r = t.r + (e.r - t.r) * i,
            this.g = t.g + (e.g - t.g) * i,
            this.b = t.b + (e.b - t.b) * i,
            this
        }
        lerpHSL(t, e) {
            this.getHSL(Yu),
            t.getHSL(Xu);
            const i = ph(Yu.h, Xu.h, e)
              , n = ph(Yu.s, Xu.s, e)
              , r = ph(Yu.l, Xu.l, e);
            return this.setHSL(i, n, r),
            this
        }
        equals(t) {
            return t.r === this.r && t.g === this.g && t.b === this.b
        }
        fromArray(t, e=0) {
            return this.r = t[e],
            this.g = t[e + 1],
            this.b = t[e + 2],
            this
        }
        toArray(t=[], e=0) {
            return t[e] = this.r,
            t[e + 1] = this.g,
            t[e + 2] = this.b,
            t
        }
        fromBufferAttribute(t, e) {
            return this.r = t.getX(e),
            this.g = t.getY(e),
            this.b = t.getZ(e),
            !0 === t.normalized && (this.r /= 255,
            this.g /= 255,
            this.b /= 255),
            this
        }
        toJSON() {
            return this.getHex()
        }
    }
    $u.NAMES = ju,
    $u.prototype.isColor = !0,
    $u.prototype.r = 1,
    $u.prototype.g = 1,
    $u.prototype.b = 1;
    class Ku extends qu {
        constructor(t) {
            super(),
            this.type = "MeshBasicMaterial",
            this.color = new $u(16777215),
            this.map = null,
            this.lightMap = null,
            this.lightMapIntensity = 1,
            this.aoMap = null,
            this.aoMapIntensity = 1,
            this.specularMap = null,
            this.alphaMap = null,
            this.envMap = null,
            this.combine = rl,
            this.reflectivity = 1,
            this.refractionRatio = .98,
            this.wireframe = !1,
            this.wireframeLinewidth = 1,
            this.wireframeLinecap = "round",
            this.wireframeLinejoin = "round",
            this.skinning = !1,
            this.morphTargets = !1,
            this.setValues(t)
        }
        copy(t) {
            return super.copy(t),
            this.color.copy(t.color),
            this.map = t.map,
            this.lightMap = t.lightMap,
            this.lightMapIntensity = t.lightMapIntensity,
            this.aoMap = t.aoMap,
            this.aoMapIntensity = t.aoMapIntensity,
            this.specularMap = t.specularMap,
            this.alphaMap = t.alphaMap,
            this.envMap = t.envMap,
            this.combine = t.combine,
            this.reflectivity = t.reflectivity,
            this.refractionRatio = t.refractionRatio,
            this.wireframe = t.wireframe,
            this.wireframeLinewidth = t.wireframeLinewidth,
            this.wireframeLinecap = t.wireframeLinecap,
            this.wireframeLinejoin = t.wireframeLinejoin,
            this.skinning = t.skinning,
            this.morphTargets = t.morphTargets,
            this
        }
    }
    Ku.prototype.isMeshBasicMaterial = !0;
    const td = new Eh
      , ed = new gh;
    class id {
        constructor(t, e, i) {
            if (Array.isArray(t))
                throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.name = "",
            this.array = t,
            this.itemSize = e,
            this.count = void 0 !== t ? t.length / e : 0,
            this.normalized = !0 === i,
            this.usage = rh,
            this.updateRange = {
                offset: 0,
                count: -1
            },
            this.version = 0,
            this.onUploadCallback = function() {}
        }
        set needsUpdate(t) {
            !0 === t && this.version++
        }
        setUsage(t) {
            return this.usage = t,
            this
        }
        copy(t) {
            return this.name = t.name,
            this.array = new t.array.constructor(t.array),
            this.itemSize = t.itemSize,
            this.count = t.count,
            this.normalized = t.normalized,
            this.usage = t.usage,
            this
        }
        copyAt(t, e, i) {
            t *= this.itemSize,
            i *= e.itemSize;
            for (let n = 0, r = this.itemSize; n < r; n++)
                this.array[t + n] = e.array[i + n];
            return this
        }
        copyArray(t) {
            return this.array.set(t),
            this
        }
        copyColorsArray(t) {
            const e = this.array;
            let i = 0;
            for (let n = 0, r = t.length; n < r; n++) {
                let r = t[n];
                void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n),
                r = new $u),
                e[i++] = r.r,
                e[i++] = r.g,
                e[i++] = r.b
            }
            return this
        }
        copyVector2sArray(t) {
            const e = this.array;
            let i = 0;
            for (let n = 0, r = t.length; n < r; n++) {
                let r = t[n];
                void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n),
                r = new gh),
                e[i++] = r.x,
                e[i++] = r.y
            }
            return this
        }
        copyVector3sArray(t) {
            const e = this.array;
            let i = 0;
            for (let n = 0, r = t.length; n < r; n++) {
                let r = t[n];
                void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n),
                r = new Eh),
                e[i++] = r.x,
                e[i++] = r.y,
                e[i++] = r.z
            }
            return this
        }
        copyVector4sArray(t) {
            const e = this.array;
            let i = 0;
            for (let n = 0, r = t.length; n < r; n++) {
                let r = t[n];
                void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n),
                r = new Mh),
                e[i++] = r.x,
                e[i++] = r.y,
                e[i++] = r.z,
                e[i++] = r.w
            }
            return this
        }
        applyMatrix3(t) {
            if (2 === this.itemSize)
                for (let e = 0, i = this.count; e < i; e++)
                    ed.fromBufferAttribute(this, e),
                    ed.applyMatrix3(t),
                    this.setXY(e, ed.x, ed.y);
            else if (3 === this.itemSize)
                for (let e = 0, i = this.count; e < i; e++)
                    td.fromBufferAttribute(this, e),
                    td.applyMatrix3(t),
                    this.setXYZ(e, td.x, td.y, td.z);
            return this
        }
        applyMatrix4(t) {
            for (let e = 0, i = this.count; e < i; e++)
                td.x = this.getX(e),
                td.y = this.getY(e),
                td.z = this.getZ(e),
                td.applyMatrix4(t),
                this.setXYZ(e, td.x, td.y, td.z);
            return this
        }
        applyNormalMatrix(t) {
            for (let e = 0, i = this.count; e < i; e++)
                td.x = this.getX(e),
                td.y = this.getY(e),
                td.z = this.getZ(e),
                td.applyNormalMatrix(t),
                this.setXYZ(e, td.x, td.y, td.z);
            return this
        }
        transformDirection(t) {
            for (let e = 0, i = this.count; e < i; e++)
                td.x = this.getX(e),
                td.y = this.getY(e),
                td.z = this.getZ(e),
                td.transformDirection(t),
                this.setXYZ(e, td.x, td.y, td.z);
            return this
        }
        set(t, e=0) {
            return this.array.set(t, e),
            this
        }
        getX(t) {
            return this.array[t * this.itemSize]
        }
        setX(t, e) {
            return this.array[t * this.itemSize] = e,
            this
        }
        getY(t) {
            return this.array[t * this.itemSize + 1]
        }
        setY(t, e) {
            return this.array[t * this.itemSize + 1] = e,
            this
        }
        getZ(t) {
            return this.array[t * this.itemSize + 2]
        }
        setZ(t, e) {
            return this.array[t * this.itemSize + 2] = e,
            this
        }
        getW(t) {
            return this.array[t * this.itemSize + 3]
        }
        setW(t, e) {
            return this.array[t * this.itemSize + 3] = e,
            this
        }
        setXY(t, e, i) {
            return t *= this.itemSize,
            this.array[t + 0] = e,
            this.array[t + 1] = i,
            this
        }
        setXYZ(t, e, i, n) {
            return t *= this.itemSize,
            this.array[t + 0] = e,
            this.array[t + 1] = i,
            this.array[t + 2] = n,
            this
        }
        setXYZW(t, e, i, n, r) {
            return t *= this.itemSize,
            this.array[t + 0] = e,
            this.array[t + 1] = i,
            this.array[t + 2] = n,
            this.array[t + 3] = r,
            this
        }
        onUpload(t) {
            return this.onUploadCallback = t,
            this
        }
        clone() {
            return new this.constructor(this.array,this.itemSize).copy(this)
        }
        toJSON() {
            const t = {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.prototype.slice.call(this.array),
                normalized: this.normalized
            };
            return "" !== this.name && (t.name = this.name),
            this.usage !== rh && (t.usage = this.usage),
            0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange),
            t
        }
    }
    id.prototype.isBufferAttribute = !0;
    class nd extends id {
        constructor(t, e, i) {
            super(new Uint16Array(t), e, i)
        }
    }
    class rd extends id {
        constructor(t, e, i) {
            super(new Uint32Array(t), e, i)
        }
    }
    (class extends id {
        constructor(t, e, i) {
            super(new Uint16Array(t), e, i)
        }
    }
    ).prototype.isFloat16BufferAttribute = !0;
    class sd extends id {
        constructor(t, e, i) {
            super(new Float32Array(t), e, i)
        }
    }
    function ad(t) {
        if (0 === t.length)
            return -1 / 0;
        let e = t[0];
        for (let i = 1, n = t.length; i < n; ++i)
            t[i] > e && (e = t[i]);
        return e
    }
    let od = 0;
    const ld = new nu
      , cd = new Au
      , hd = new Eh
      , ud = new Ch
      , dd = new Ch
      , pd = new Eh;
    class fd extends oh {
        constructor() {
            super(),
            Object.defineProperty(this, "id", {
                value: od++
            }),
            this.uuid = uh(),
            this.name = "",
            this.type = "BufferGeometry",
            this.index = null,
            this.attributes = {},
            this.morphAttributes = {},
            this.morphTargetsRelative = !1,
            this.groups = [],
            this.boundingBox = null,
            this.boundingSphere = null,
            this.drawRange = {
                start: 0,
                count: 1 / 0
            },
            this.userData = {}
        }
        getIndex() {
            return this.index
        }
        setIndex(t) {
            return Array.isArray(t) ? this.index = new (ad(t) > 65535 ? rd : nd)(t,1) : this.index = t,
            this
        }
        getAttribute(t) {
            return this.attributes[t]
        }
        setAttribute(t, e) {
            return this.attributes[t] = e,
            this
        }
        deleteAttribute(t) {
            return delete this.attributes[t],
            this
        }
        hasAttribute(t) {
            return void 0 !== this.attributes[t]
        }
        addGroup(t, e, i=0) {
            this.groups.push({
                start: t,
                count: e,
                materialIndex: i
            })
        }
        clearGroups() {
            this.groups = []
        }
        setDrawRange(t, e) {
            this.drawRange.start = t,
            this.drawRange.count = e
        }
        applyMatrix4(t) {
            const e = this.attributes.position;
            void 0 !== e && (e.applyMatrix4(t),
            e.needsUpdate = !0);
            const i = this.attributes.normal;
            if (void 0 !== i) {
                const e = (new vh).getNormalMatrix(t);
                i.applyNormalMatrix(e),
                i.needsUpdate = !0
            }
            const n = this.attributes.tangent;
            return void 0 !== n && (n.transformDirection(t),
            n.needsUpdate = !0),
            null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this
        }
        rotateX(t) {
            return ld.makeRotationX(t),
            this.applyMatrix4(ld),
            this
        }
        rotateY(t) {
            return ld.makeRotationY(t),
            this.applyMatrix4(ld),
            this
        }
        rotateZ(t) {
            return ld.makeRotationZ(t),
            this.applyMatrix4(ld),
            this
        }
        translate(t, e, i) {
            return ld.makeTranslation(t, e, i),
            this.applyMatrix4(ld),
            this
        }
        scale(t, e, i) {
            return ld.makeScale(t, e, i),
            this.applyMatrix4(ld),
            this
        }
        lookAt(t) {
            return cd.lookAt(t),
            cd.updateMatrix(),
            this.applyMatrix4(cd.matrix),
            this
        }
        center() {
            return this.computeBoundingBox(),
            this.boundingBox.getCenter(hd).negate(),
            this.translate(hd.x, hd.y, hd.z),
            this
        }
        setFromPoints(t) {
            const e = [];
            for (let i = 0, n = t.length; i < n; i++) {
                const n = t[i];
                e.push(n.x, n.y, n.z || 0)
            }
            return this.setAttribute("position", new sd(e,3)),
            this
        }
        computeBoundingBox() {
            null === this.boundingBox && (this.boundingBox = new Ch);
            const t = this.attributes.position
              , e = this.morphAttributes.position;
            if (t && t.isGLBufferAttribute)
                return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this),
                void this.boundingBox.set(new Eh(-1 / 0,-1 / 0,-1 / 0), new Eh(1 / 0,1 / 0,1 / 0));
            if (void 0 !== t) {
                if (this.boundingBox.setFromBufferAttribute(t),
                e)
                    for (let t = 0, i = e.length; t < i; t++) {
                        const i = e[t];
                        ud.setFromBufferAttribute(i),
                        this.morphTargetsRelative ? (pd.addVectors(this.boundingBox.min, ud.min),
                        this.boundingBox.expandByPoint(pd),
                        pd.addVectors(this.boundingBox.max, ud.max),
                        this.boundingBox.expandByPoint(pd)) : (this.boundingBox.expandByPoint(ud.min),
                        this.boundingBox.expandByPoint(ud.max))
                    }
            } else
                this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
        }
        computeBoundingSphere() {
            null === this.boundingSphere && (this.boundingSphere = new Xh);
            const t = this.attributes.position
              , e = this.morphAttributes.position;
            if (t && t.isGLBufferAttribute)
                return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this),
                void this.boundingSphere.set(new Eh, 1 / 0);
            if (t) {
                const i = this.boundingSphere.center;
                if (ud.setFromBufferAttribute(t),
                e)
                    for (let t = 0, i = e.length; t < i; t++) {
                        const i = e[t];
                        dd.setFromBufferAttribute(i),
                        this.morphTargetsRelative ? (pd.addVectors(ud.min, dd.min),
                        ud.expandByPoint(pd),
                        pd.addVectors(ud.max, dd.max),
                        ud.expandByPoint(pd)) : (ud.expandByPoint(dd.min),
                        ud.expandByPoint(dd.max))
                    }
                ud.getCenter(i);
                let n = 0;
                for (let e = 0, r = t.count; e < r; e++)
                    pd.fromBufferAttribute(t, e),
                    n = Math.max(n, i.distanceToSquared(pd));
                if (e)
                    for (let r = 0, s = e.length; r < s; r++) {
                        const s = e[r]
                          , a = this.morphTargetsRelative;
                        for (let e = 0, r = s.count; e < r; e++)
                            pd.fromBufferAttribute(s, e),
                            a && (hd.fromBufferAttribute(t, e),
                            pd.add(hd)),
                            n = Math.max(n, i.distanceToSquared(pd))
                    }
                this.boundingSphere.radius = Math.sqrt(n),
                isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
            }
        }
        computeFaceNormals() {}
        computeTangents() {
            const t = this.index
              , e = this.attributes;
            if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv)
                return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            const i = t.array
              , n = e.position.array
              , r = e.normal.array
              , s = e.uv.array
              , a = n.length / 3;
            void 0 === e.tangent && this.setAttribute("tangent", new id(new Float32Array(4 * a),4));
            const o = e.tangent.array
              , l = []
              , c = [];
            for (let t = 0; t < a; t++)
                l[t] = new Eh,
                c[t] = new Eh;
            const h = new Eh
              , u = new Eh
              , d = new Eh
              , p = new gh
              , f = new gh
              , m = new gh
              , g = new Eh
              , v = new Eh;
            function y(t, e, i) {
                h.fromArray(n, 3 * t),
                u.fromArray(n, 3 * e),
                d.fromArray(n, 3 * i),
                p.fromArray(s, 2 * t),
                f.fromArray(s, 2 * e),
                m.fromArray(s, 2 * i),
                u.sub(h),
                d.sub(h),
                f.sub(p),
                m.sub(p);
                const r = 1 / (f.x * m.y - m.x * f.y);
                isFinite(r) && (g.copy(u).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(r),
                v.copy(d).multiplyScalar(f.x).addScaledVector(u, -m.x).multiplyScalar(r),
                l[t].add(g),
                l[e].add(g),
                l[i].add(g),
                c[t].add(v),
                c[e].add(v),
                c[i].add(v))
            }
            let x = this.groups;
            0 === x.length && (x = [{
                start: 0,
                count: i.length
            }]);
            for (let t = 0, e = x.length; t < e; ++t) {
                const e = x[t]
                  , n = e.start;
                for (let t = n, r = n + e.count; t < r; t += 3)
                    y(i[t + 0], i[t + 1], i[t + 2])
            }
            const _ = new Eh
              , w = new Eh
              , b = new Eh
              , M = new Eh;
            function S(t) {
                b.fromArray(r, 3 * t),
                M.copy(b);
                const e = l[t];
                _.copy(e),
                _.sub(b.multiplyScalar(b.dot(e))).normalize(),
                w.crossVectors(M, e);
                const i = w.dot(c[t]) < 0 ? -1 : 1;
                o[4 * t] = _.x,
                o[4 * t + 1] = _.y,
                o[4 * t + 2] = _.z,
                o[4 * t + 3] = i
            }
            for (let t = 0, e = x.length; t < e; ++t) {
                const e = x[t]
                  , n = e.start;
                for (let t = n, r = n + e.count; t < r; t += 3)
                    S(i[t + 0]),
                    S(i[t + 1]),
                    S(i[t + 2])
            }
        }
        computeVertexNormals() {
            const t = this.index
              , e = this.getAttribute("position");
            if (void 0 !== e) {
                let i = this.getAttribute("normal");
                if (void 0 === i)
                    i = new id(new Float32Array(3 * e.count),3),
                    this.setAttribute("normal", i);
                else
                    for (let t = 0, e = i.count; t < e; t++)
                        i.setXYZ(t, 0, 0, 0);
                const n = new Eh
                  , r = new Eh
                  , s = new Eh
                  , a = new Eh
                  , o = new Eh
                  , l = new Eh
                  , c = new Eh
                  , h = new Eh;
                if (t)
                    for (let u = 0, d = t.count; u < d; u += 3) {
                        const d = t.getX(u + 0)
                          , p = t.getX(u + 1)
                          , f = t.getX(u + 2);
                        n.fromBufferAttribute(e, d),
                        r.fromBufferAttribute(e, p),
                        s.fromBufferAttribute(e, f),
                        c.subVectors(s, r),
                        h.subVectors(n, r),
                        c.cross(h),
                        a.fromBufferAttribute(i, d),
                        o.fromBufferAttribute(i, p),
                        l.fromBufferAttribute(i, f),
                        a.add(c),
                        o.add(c),
                        l.add(c),
                        i.setXYZ(d, a.x, a.y, a.z),
                        i.setXYZ(p, o.x, o.y, o.z),
                        i.setXYZ(f, l.x, l.y, l.z)
                    }
                else
                    for (let t = 0, a = e.count; t < a; t += 3)
                        n.fromBufferAttribute(e, t + 0),
                        r.fromBufferAttribute(e, t + 1),
                        s.fromBufferAttribute(e, t + 2),
                        c.subVectors(s, r),
                        h.subVectors(n, r),
                        c.cross(h),
                        i.setXYZ(t + 0, c.x, c.y, c.z),
                        i.setXYZ(t + 1, c.x, c.y, c.z),
                        i.setXYZ(t + 2, c.x, c.y, c.z);
                this.normalizeNormals(),
                i.needsUpdate = !0
            }
        }
        merge(t, e) {
            if (!t || !t.isBufferGeometry)
                return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
            void 0 === e && (e = 0,
            console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
            const i = this.attributes;
            for (const n in i) {
                if (void 0 === t.attributes[n])
                    continue;
                const r = i[n].array
                  , s = t.attributes[n]
                  , a = s.array
                  , o = s.itemSize * e
                  , l = Math.min(a.length, r.length - o);
                for (let t = 0, e = o; t < l; t++,
                e++)
                    r[e] = a[t]
            }
            return this
        }
        normalizeNormals() {
            const t = this.attributes.normal;
            for (let e = 0, i = t.count; e < i; e++)
                pd.fromBufferAttribute(t, e),
                pd.normalize(),
                t.setXYZ(e, pd.x, pd.y, pd.z)
        }
        toNonIndexed() {
            function t(t, e) {
                const i = t.array
                  , n = t.itemSize
                  , r = t.normalized
                  , s = new i.constructor(e.length * n);
                let a = 0
                  , o = 0;
                for (let t = 0, r = e.length; t < r; t++) {
                    a = e[t] * n;
                    for (let t = 0; t < n; t++)
                        s[o++] = i[a++]
                }
                return new id(s,n,r)
            }
            if (null === this.index)
                return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
                this;
            const e = new fd
              , i = this.index.array
              , n = this.attributes;
            for (const r in n) {
                const s = t(n[r], i);
                e.setAttribute(r, s)
            }
            const r = this.morphAttributes;
            for (const n in r) {
                const s = []
                  , a = r[n];
                for (let e = 0, n = a.length; e < n; e++) {
                    const n = t(a[e], i);
                    s.push(n)
                }
                e.morphAttributes[n] = s
            }
            e.morphTargetsRelative = this.morphTargetsRelative;
            const s = this.groups;
            for (let t = 0, i = s.length; t < i; t++) {
                const i = s[t];
                e.addGroup(i.start, i.count, i.materialIndex)
            }
            return e
        }
        toJSON() {
            const t = {
                metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (t.uuid = this.uuid,
            t.type = this.type,
            "" !== this.name && (t.name = this.name),
            Object.keys(this.userData).length > 0 && (t.userData = this.userData),
            void 0 !== this.parameters) {
                const e = this.parameters;
                for (const i in e)
                    void 0 !== e[i] && (t[i] = e[i]);
                return t
            }
            t.data = {
                attributes: {}
            };
            const e = this.index;
            null !== e && (t.data.index = {
                type: e.array.constructor.name,
                array: Array.prototype.slice.call(e.array)
            });
            const i = this.attributes;
            for (const e in i) {
                const n = i[e];
                t.data.attributes[e] = n.toJSON(t.data)
            }
            const n = {};
            let r = !1;
            for (const e in this.morphAttributes) {
                const i = this.morphAttributes[e]
                  , s = [];
                for (let e = 0, n = i.length; e < n; e++) {
                    const n = i[e];
                    s.push(n.toJSON(t.data))
                }
                s.length > 0 && (n[e] = s,
                r = !0)
            }
            r && (t.data.morphAttributes = n,
            t.data.morphTargetsRelative = this.morphTargetsRelative);
            const s = this.groups;
            s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
            const a = this.boundingSphere;
            return null !== a && (t.data.boundingSphere = {
                center: a.center.toArray(),
                radius: a.radius
            }),
            t
        }
        clone() {
            return (new fd).copy(this)
        }
        copy(t) {
            this.index = null,
            this.attributes = {},
            this.morphAttributes = {},
            this.groups = [],
            this.boundingBox = null,
            this.boundingSphere = null;
            const e = {};
            this.name = t.name;
            const i = t.index;
            null !== i && this.setIndex(i.clone(e));
            const n = t.attributes;
            for (const t in n) {
                const i = n[t];
                this.setAttribute(t, i.clone(e))
            }
            const r = t.morphAttributes;
            for (const t in r) {
                const i = []
                  , n = r[t];
                for (let t = 0, r = n.length; t < r; t++)
                    i.push(n[t].clone(e));
                this.morphAttributes[t] = i
            }
            this.morphTargetsRelative = t.morphTargetsRelative;
            const s = t.groups;
            for (let t = 0, e = s.length; t < e; t++) {
                const e = s[t];
                this.addGroup(e.start, e.count, e.materialIndex)
            }
            const a = t.boundingBox;
            null !== a && (this.boundingBox = a.clone());
            const o = t.boundingSphere;
            return null !== o && (this.boundingSphere = o.clone()),
            this.drawRange.start = t.drawRange.start,
            this.drawRange.count = t.drawRange.count,
            this.userData = t.userData,
            this
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }
    fd.prototype.isBufferGeometry = !0;
    const md = new nu
      , gd = new iu
      , vd = new Xh
      , yd = new Eh
      , xd = new Eh
      , _d = new Eh
      , wd = new Eh
      , bd = new Eh
      , Md = new Eh
      , Sd = new Eh
      , Td = new Eh
      , Ed = new Eh
      , Ld = new gh
      , Ad = new gh
      , Cd = new gh
      , Pd = new Eh
      , Rd = new Eh;
    class Id extends Au {
        constructor(t=new fd, e=new Ku) {
            super(),
            this.type = "Mesh",
            this.geometry = t,
            this.material = e,
            this.updateMorphTargets()
        }
        copy(t) {
            return super.copy(t),
            void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
            void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)),
            this.material = t.material,
            this.geometry = t.geometry,
            this
        }
        updateMorphTargets() {
            const t = this.geometry;
            if (t.isBufferGeometry) {
                const e = t.morphAttributes
                  , i = Object.keys(e);
                if (i.length > 0) {
                    const t = e[i[0]];
                    if (void 0 !== t) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let e = 0, i = t.length; e < i; e++) {
                            const i = t[e].name || String(e);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[i] = e
                        }
                    }
                }
            } else {
                const e = t.morphTargets;
                void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        }
        raycast(t, e) {
            const i = this.geometry
              , n = this.material
              , r = this.matrixWorld;
            if (void 0 === n)
                return;
            if (null === i.boundingSphere && i.computeBoundingSphere(),
            vd.copy(i.boundingSphere),
            vd.applyMatrix4(r),
            !1 === t.ray.intersectsSphere(vd))
                return;
            if (md.copy(r).invert(),
            gd.copy(t.ray).applyMatrix4(md),
            null !== i.boundingBox && !1 === gd.intersectsBox(i.boundingBox))
                return;
            let s;
            if (i.isBufferGeometry) {
                const r = i.index
                  , a = i.attributes.position
                  , o = i.morphAttributes.position
                  , l = i.morphTargetsRelative
                  , c = i.attributes.uv
                  , h = i.attributes.uv2
                  , u = i.groups
                  , d = i.drawRange;
                if (null !== r)
                    if (Array.isArray(n))
                        for (let i = 0, p = u.length; i < p; i++) {
                            const p = u[i]
                              , f = n[p.materialIndex];
                            for (let i = Math.max(p.start, d.start), n = Math.min(p.start + p.count, d.start + d.count); i < n; i += 3) {
                                const n = r.getX(i)
                                  , u = r.getX(i + 1)
                                  , d = r.getX(i + 2);
                                s = Dd(this, f, t, gd, a, o, l, c, h, n, u, d),
                                s && (s.faceIndex = Math.floor(i / 3),
                                s.face.materialIndex = p.materialIndex,
                                e.push(s))
                            }
                        }
                    else {
                        for (let i = Math.max(0, d.start), u = Math.min(r.count, d.start + d.count); i < u; i += 3) {
                            const u = r.getX(i)
                              , d = r.getX(i + 1)
                              , p = r.getX(i + 2);
                            s = Dd(this, n, t, gd, a, o, l, c, h, u, d, p),
                            s && (s.faceIndex = Math.floor(i / 3),
                            e.push(s))
                        }
                    }
                else if (void 0 !== a)
                    if (Array.isArray(n))
                        for (let i = 0, r = u.length; i < r; i++) {
                            const r = u[i]
                              , p = n[r.materialIndex];
                            for (let i = Math.max(r.start, d.start), n = Math.min(r.start + r.count, d.start + d.count); i < n; i += 3) {
                                s = Dd(this, p, t, gd, a, o, l, c, h, i, i + 1, i + 2),
                                s && (s.faceIndex = Math.floor(i / 3),
                                s.face.materialIndex = r.materialIndex,
                                e.push(s))
                            }
                        }
                    else {
                        for (let i = Math.max(0, d.start), r = Math.min(a.count, d.start + d.count); i < r; i += 3) {
                            s = Dd(this, n, t, gd, a, o, l, c, h, i, i + 1, i + 2),
                            s && (s.faceIndex = Math.floor(i / 3),
                            e.push(s))
                        }
                    }
            } else
                i.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
        }
    }
    function Dd(t, e, i, n, r, s, a, o, l, c, h, u) {
        yd.fromBufferAttribute(r, c),
        xd.fromBufferAttribute(r, h),
        _d.fromBufferAttribute(r, u);
        const d = t.morphTargetInfluences;
        if (e.morphTargets && s && d) {
            Sd.set(0, 0, 0),
            Td.set(0, 0, 0),
            Ed.set(0, 0, 0);
            for (let t = 0, e = s.length; t < e; t++) {
                const e = d[t]
                  , i = s[t];
                0 !== e && (wd.fromBufferAttribute(i, c),
                bd.fromBufferAttribute(i, h),
                Md.fromBufferAttribute(i, u),
                a ? (Sd.addScaledVector(wd, e),
                Td.addScaledVector(bd, e),
                Ed.addScaledVector(Md, e)) : (Sd.addScaledVector(wd.sub(yd), e),
                Td.addScaledVector(bd.sub(xd), e),
                Ed.addScaledVector(Md.sub(_d), e)))
            }
            yd.add(Sd),
            xd.add(Td),
            _d.add(Ed)
        }
        t.isSkinnedMesh && e.skinning && (t.boneTransform(c, yd),
        t.boneTransform(h, xd),
        t.boneTransform(u, _d));
        const p = function(t, e, i, n, r, s, a, o) {
            let l;
            if (l = e.side === Eo ? n.intersectTriangle(a, s, r, !0, o) : n.intersectTriangle(r, s, a, e.side !== Lo, o),
            null === l)
                return null;
            Rd.copy(o),
            Rd.applyMatrix4(t.matrixWorld);
            const c = i.ray.origin.distanceTo(Rd);
            return c < i.near || c > i.far ? null : {
                distance: c,
                point: Rd.clone(),
                object: t
            }
        }(t, e, i, n, yd, xd, _d, Pd);
        if (p) {
            o && (Ld.fromBufferAttribute(o, c),
            Ad.fromBufferAttribute(o, h),
            Cd.fromBufferAttribute(o, u),
            p.uv = Vu.getUV(Pd, yd, xd, _d, Ld, Ad, Cd, new gh)),
            l && (Ld.fromBufferAttribute(l, c),
            Ad.fromBufferAttribute(l, h),
            Cd.fromBufferAttribute(l, u),
            p.uv2 = Vu.getUV(Pd, yd, xd, _d, Ld, Ad, Cd, new gh));
            const t = {
                a: c,
                b: h,
                c: u,
                normal: new Eh,
                materialIndex: 0
            };
            Vu.getNormal(yd, xd, _d, t.normal),
            p.face = t
        }
        return p
    }
    Id.prototype.isMesh = !0;
    class Nd extends fd {
        constructor(t=1, e=1, i=1, n=1, r=1, s=1) {
            super(),
            this.type = "BoxGeometry",
            this.parameters = {
                width: t,
                height: e,
                depth: i,
                widthSegments: n,
                heightSegments: r,
                depthSegments: s
            };
            const a = this;
            n = Math.floor(n),
            r = Math.floor(r),
            s = Math.floor(s);
            const o = []
              , l = []
              , c = []
              , h = [];
            let u = 0
              , d = 0;
            function p(t, e, i, n, r, s, p, f, m, g, v) {
                const y = s / m
                  , x = p / g
                  , _ = s / 2
                  , w = p / 2
                  , b = f / 2
                  , M = m + 1
                  , S = g + 1;
                let T = 0
                  , E = 0;
                const L = new Eh;
                for (let s = 0; s < S; s++) {
                    const a = s * x - w;
                    for (let o = 0; o < M; o++) {
                        const u = o * y - _;
                        L[t] = u * n,
                        L[e] = a * r,
                        L[i] = b,
                        l.push(L.x, L.y, L.z),
                        L[t] = 0,
                        L[e] = 0,
                        L[i] = f > 0 ? 1 : -1,
                        c.push(L.x, L.y, L.z),
                        h.push(o / m),
                        h.push(1 - s / g),
                        T += 1
                    }
                }
                for (let t = 0; t < g; t++)
                    for (let e = 0; e < m; e++) {
                        const i = u + e + M * t
                          , n = u + e + M * (t + 1)
                          , r = u + (e + 1) + M * (t + 1)
                          , s = u + (e + 1) + M * t;
                        o.push(i, n, s),
                        o.push(n, r, s),
                        E += 6
                    }
                a.addGroup(d, E, v),
                d += E,
                u += T
            }
            p("z", "y", "x", -1, -1, i, e, t, s, r, 0),
            p("z", "y", "x", 1, -1, i, e, -t, s, r, 1),
            p("x", "z", "y", 1, 1, t, i, e, n, s, 2),
            p("x", "z", "y", 1, -1, t, i, -e, n, s, 3),
            p("x", "y", "z", 1, -1, t, e, i, n, r, 4),
            p("x", "y", "z", -1, -1, t, e, -i, n, r, 5),
            this.setIndex(o),
            this.setAttribute("position", new sd(l,3)),
            this.setAttribute("normal", new sd(c,3)),
            this.setAttribute("uv", new sd(h,2))
        }
    }
    function Od(t) {
        const e = {};
        for (const i in t) {
            e[i] = {};
            for (const n in t[i]) {
                const r = t[i][n];
                r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? e[i][n] = r.clone() : Array.isArray(r) ? e[i][n] = r.slice() : e[i][n] = r
            }
        }
        return e
    }
    function zd(t) {
        const e = {};
        for (let i = 0; i < t.length; i++) {
            const n = Od(t[i]);
            for (const t in n)
                e[t] = n[t]
        }
        return e
    }
    const kd = {
        clone: Od,
        merge: zd
    };
    class Bd extends qu {
        constructor(t) {
            super(),
            this.type = "ShaderMaterial",
            this.defines = {},
            this.uniforms = {},
            this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
            this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
            this.linewidth = 1,
            this.wireframe = !1,
            this.wireframeLinewidth = 1,
            this.fog = !1,
            this.lights = !1,
            this.clipping = !1,
            this.skinning = !1,
            this.morphTargets = !1,
            this.morphNormals = !1,
            this.extensions = {
                derivatives: !1,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1
            },
            this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv2: [0, 0]
            },
            this.index0AttributeName = void 0,
            this.uniformsNeedUpdate = !1,
            this.glslVersion = null,
            void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),
            this.setValues(t))
        }
        copy(t) {
            return super.copy(t),
            this.fragmentShader = t.fragmentShader,
            this.vertexShader = t.vertexShader,
            this.uniforms = Od(t.uniforms),
            this.defines = Object.assign({}, t.defines),
            this.wireframe = t.wireframe,
            this.wireframeLinewidth = t.wireframeLinewidth,
            this.lights = t.lights,
            this.clipping = t.clipping,
            this.skinning = t.skinning,
            this.morphTargets = t.morphTargets,
            this.morphNormals = t.morphNormals,
            this.extensions = Object.assign({}, t.extensions),
            this.glslVersion = t.glslVersion,
            this
        }
        toJSON(t) {
            const e = super.toJSON(t);
            e.glslVersion = this.glslVersion,
            e.uniforms = {};
            for (const i in this.uniforms) {
                const n = this.uniforms[i].value;
                n && n.isTexture ? e.uniforms[i] = {
                    type: "t",
                    value: n.toJSON(t).uuid
                } : n && n.isColor ? e.uniforms[i] = {
                    type: "c",
                    value: n.getHex()
                } : n && n.isVector2 ? e.uniforms[i] = {
                    type: "v2",
                    value: n.toArray()
                } : n && n.isVector3 ? e.uniforms[i] = {
                    type: "v3",
                    value: n.toArray()
                } : n && n.isVector4 ? e.uniforms[i] = {
                    type: "v4",
                    value: n.toArray()
                } : n && n.isMatrix3 ? e.uniforms[i] = {
                    type: "m3",
                    value: n.toArray()
                } : n && n.isMatrix4 ? e.uniforms[i] = {
                    type: "m4",
                    value: n.toArray()
                } : e.uniforms[i] = {
                    value: n
                }
            }
            Object.keys(this.defines).length > 0 && (e.defines = this.defines),
            e.vertexShader = this.vertexShader,
            e.fragmentShader = this.fragmentShader;
            const i = {};
            for (const t in this.extensions)
                !0 === this.extensions[t] && (i[t] = !0);
            return Object.keys(i).length > 0 && (e.extensions = i),
            e
        }
    }
    Bd.prototype.isShaderMaterial = !0;
    class Fd extends Au {
        constructor() {
            super(),
            this.type = "Camera",
            this.matrixWorldInverse = new nu,
            this.projectionMatrix = new nu,
            this.projectionMatrixInverse = new nu
        }
        copy(t, e) {
            return super.copy(t, e),
            this.matrixWorldInverse.copy(t.matrixWorldInverse),
            this.projectionMatrix.copy(t.projectionMatrix),
            this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
            this
        }
        getWorldDirection(t) {
            void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"),
            t = new Eh),
            this.updateWorldMatrix(!0, !1);
            const e = this.matrixWorld.elements;
            return t.set(-e[8], -e[9], -e[10]).normalize()
        }
        updateMatrixWorld(t) {
            super.updateMatrixWorld(t),
            this.matrixWorldInverse.copy(this.matrixWorld).invert()
        }
        updateWorldMatrix(t, e) {
            super.updateWorldMatrix(t, e),
            this.matrixWorldInverse.copy(this.matrixWorld).invert()
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }
    Fd.prototype.isCamera = !0;
    class Hd extends Fd {
        constructor(t=50, e=1, i=.1, n=2e3) {
            super(),
            this.type = "PerspectiveCamera",
            this.fov = t,
            this.zoom = 1,
            this.near = i,
            this.far = n,
            this.focus = 10,
            this.aspect = e,
            this.view = null,
            this.filmGauge = 35,
            this.filmOffset = 0,
            this.updateProjectionMatrix()
        }
        copy(t, e) {
            return super.copy(t, e),
            this.fov = t.fov,
            this.zoom = t.zoom,
            this.near = t.near,
            this.far = t.far,
            this.focus = t.focus,
            this.aspect = t.aspect,
            this.view = null === t.view ? null : Object.assign({}, t.view),
            this.filmGauge = t.filmGauge,
            this.filmOffset = t.filmOffset,
            this
        }
        setFocalLength(t) {
            const e = .5 * this.getFilmHeight() / t;
            this.fov = 2 * hh * Math.atan(e),
            this.updateProjectionMatrix()
        }
        getFocalLength() {
            const t = Math.tan(.5 * ch * this.fov);
            return .5 * this.getFilmHeight() / t
        }
        getEffectiveFOV() {
            return 2 * hh * Math.atan(Math.tan(.5 * ch * this.fov) / this.zoom)
        }
        getFilmWidth() {
            return this.filmGauge * Math.min(this.aspect, 1)
        }
        getFilmHeight() {
            return this.filmGauge / Math.max(this.aspect, 1)
        }
        setViewOffset(t, e, i, n, r, s) {
            this.aspect = t / e,
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }),
            this.view.enabled = !0,
            this.view.fullWidth = t,
            this.view.fullHeight = e,
            this.view.offsetX = i,
            this.view.offsetY = n,
            this.view.width = r,
            this.view.height = s,
            this.updateProjectionMatrix()
        }
        clearViewOffset() {
            null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix()
        }
        updateProjectionMatrix() {
            const t = this.near;
            let e = t * Math.tan(.5 * ch * this.fov) / this.zoom
              , i = 2 * e
              , n = this.aspect * i
              , r = -.5 * n;
            const s = this.view;
            if (null !== this.view && this.view.enabled) {
                const t = s.fullWidth
                  , a = s.fullHeight;
                r += s.offsetX * n / t,
                e -= s.offsetY * i / a,
                n *= s.width / t,
                i *= s.height / a
            }
            const a = this.filmOffset;
            0 !== a && (r += t * a / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(r, r + n, e, e - i, t, this.far),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
        }
        toJSON(t) {
            const e = super.toJSON(t);
            return e.object.fov = this.fov,
            e.object.zoom = this.zoom,
            e.object.near = this.near,
            e.object.far = this.far,
            e.object.focus = this.focus,
            e.object.aspect = this.aspect,
            null !== this.view && (e.object.view = Object.assign({}, this.view)),
            e.object.filmGauge = this.filmGauge,
            e.object.filmOffset = this.filmOffset,
            e
        }
    }
    Hd.prototype.isPerspectiveCamera = !0;
    const Ud = 90;
    class Gd extends Au {
        constructor(t, e, i) {
            if (super(),
            this.type = "CubeCamera",
            !0 !== i.isWebGLCubeRenderTarget)
                return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
            this.renderTarget = i;
            const n = new Hd(Ud,1,t,e);
            n.layers = this.layers,
            n.up.set(0, -1, 0),
            n.lookAt(new Eh(1,0,0)),
            this.add(n);
            const r = new Hd(Ud,1,t,e);
            r.layers = this.layers,
            r.up.set(0, -1, 0),
            r.lookAt(new Eh(-1,0,0)),
            this.add(r);
            const s = new Hd(Ud,1,t,e);
            s.layers = this.layers,
            s.up.set(0, 0, 1),
            s.lookAt(new Eh(0,1,0)),
            this.add(s);
            const a = new Hd(Ud,1,t,e);
            a.layers = this.layers,
            a.up.set(0, 0, -1),
            a.lookAt(new Eh(0,-1,0)),
            this.add(a);
            const o = new Hd(Ud,1,t,e);
            o.layers = this.layers,
            o.up.set(0, -1, 0),
            o.lookAt(new Eh(0,0,1)),
            this.add(o);
            const l = new Hd(Ud,1,t,e);
            l.layers = this.layers,
            l.up.set(0, -1, 0),
            l.lookAt(new Eh(0,0,-1)),
            this.add(l)
        }
        update(t, e) {
            null === this.parent && this.updateMatrixWorld();
            const i = this.renderTarget
              , [n,r,s,a,o,l] = this.children
              , c = t.xr.enabled
              , h = t.getRenderTarget();
            t.xr.enabled = !1;
            const u = i.texture.generateMipmaps;
            i.texture.generateMipmaps = !1,
            t.setRenderTarget(i, 0),
            t.render(e, n),
            t.setRenderTarget(i, 1),
            t.render(e, r),
            t.setRenderTarget(i, 2),
            t.render(e, s),
            t.setRenderTarget(i, 3),
            t.render(e, a),
            t.setRenderTarget(i, 4),
            t.render(e, o),
            i.texture.generateMipmaps = u,
            t.setRenderTarget(i, 5),
            t.render(e, l),
            t.setRenderTarget(h),
            t.xr.enabled = c
        }
    }
    class Vd extends wh {
        constructor(t, e, i, n, r, s, a, o, l, c) {
            super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : pl, i, n, r, s, a = void 0 !== a ? a : Ul, o, l, c),
            this._needsFlipEnvMap = !0,
            this.flipY = !1
        }
        get images() {
            return this.image
        }
        set images(t) {
            this.image = t
        }
    }
    Vd.prototype.isCubeTexture = !0;
    class Wd extends Sh {
        constructor(t, e, i) {
            Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),
            e = i),
            super(t, t, e),
            e = e || {},
            this.texture = new Vd(void 0,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),
            this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps,
            this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : Tl,
            this.texture._needsFlipEnvMap = !1
        }
        fromEquirectangularTexture(t, e) {
            this.texture.type = e.type,
            this.texture.format = Gl,
            this.texture.encoding = e.encoding,
            this.texture.generateMipmaps = e.generateMipmaps,
            this.texture.minFilter = e.minFilter,
            this.texture.magFilter = e.magFilter;
            const i = {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
            }
              , n = new Nd(5,5,5)
              , r = new Bd({
                name: "CubemapFromEquirect",
                uniforms: Od(i.uniforms),
                vertexShader: i.vertexShader,
                fragmentShader: i.fragmentShader,
                side: Eo,
                blending: Ao
            });
            r.uniforms.tEquirect.value = e;
            const s = new Id(n,r)
              , a = e.minFilter;
            e.minFilter === Ll && (e.minFilter = Tl);
            return new Gd(1,10,this).update(t, s),
            e.minFilter = a,
            s.geometry.dispose(),
            s.material.dispose(),
            this
        }
        clear(t, e, i, n) {
            const r = t.getRenderTarget();
            for (let r = 0; r < 6; r++)
                t.setRenderTarget(this, r),
                t.clear(e, i, n);
            t.setRenderTarget(r)
        }
    }
    Wd.prototype.isWebGLCubeRenderTarget = !0;
    class qd extends wh {
        constructor(t, e, i, n, r, s, a, o, l, c, h, u) {
            super(null, s, a, o, l, c, n, r, h, u),
            this.image = {
                data: t || null,
                width: e || 1,
                height: i || 1
            },
            this.magFilter = void 0 !== l ? l : bl,
            this.minFilter = void 0 !== c ? c : bl,
            this.generateMipmaps = !1,
            this.flipY = !1,
            this.unpackAlignment = 1,
            this.needsUpdate = !0
        }
    }
    qd.prototype.isDataTexture = !0;
    const jd = new Xh
      , Yd = new Eh;
    class Xd {
        constructor(t=new Iu, e=new Iu, i=new Iu, n=new Iu, r=new Iu, s=new Iu) {
            this.planes = [t, e, i, n, r, s]
        }
        set(t, e, i, n, r, s) {
            const a = this.planes;
            return a[0].copy(t),
            a[1].copy(e),
            a[2].copy(i),
            a[3].copy(n),
            a[4].copy(r),
            a[5].copy(s),
            this
        }
        copy(t) {
            const e = this.planes;
            for (let i = 0; i < 6; i++)
                e[i].copy(t.planes[i]);
            return this
        }
        setFromProjectionMatrix(t) {
            const e = this.planes
              , i = t.elements
              , n = i[0]
              , r = i[1]
              , s = i[2]
              , a = i[3]
              , o = i[4]
              , l = i[5]
              , c = i[6]
              , h = i[7]
              , u = i[8]
              , d = i[9]
              , p = i[10]
              , f = i[11]
              , m = i[12]
              , g = i[13]
              , v = i[14]
              , y = i[15];
            return e[0].setComponents(a - n, h - o, f - u, y - m).normalize(),
            e[1].setComponents(a + n, h + o, f + u, y + m).normalize(),
            e[2].setComponents(a + r, h + l, f + d, y + g).normalize(),
            e[3].setComponents(a - r, h - l, f - d, y - g).normalize(),
            e[4].setComponents(a - s, h - c, f - p, y - v).normalize(),
            e[5].setComponents(a + s, h + c, f + p, y + v).normalize(),
            this
        }
        intersectsObject(t) {
            const e = t.geometry;
            return null === e.boundingSphere && e.computeBoundingSphere(),
            jd.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
            this.intersectsSphere(jd)
        }
        intersectsSprite(t) {
            return jd.center.set(0, 0, 0),
            jd.radius = .7071067811865476,
            jd.applyMatrix4(t.matrixWorld),
            this.intersectsSphere(jd)
        }
        intersectsSphere(t) {
            const e = this.planes
              , i = t.center
              , n = -t.radius;
            for (let t = 0; t < 6; t++) {
                if (e[t].distanceToPoint(i) < n)
                    return !1
            }
            return !0
        }
        intersectsBox(t) {
            const e = this.planes;
            for (let i = 0; i < 6; i++) {
                const n = e[i];
                if (Yd.x = n.normal.x > 0 ? t.max.x : t.min.x,
                Yd.y = n.normal.y > 0 ? t.max.y : t.min.y,
                Yd.z = n.normal.z > 0 ? t.max.z : t.min.z,
                n.distanceToPoint(Yd) < 0)
                    return !1
            }
            return !0
        }
        containsPoint(t) {
            const e = this.planes;
            for (let i = 0; i < 6; i++)
                if (e[i].distanceToPoint(t) < 0)
                    return !1;
            return !0
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }
    function Jd() {
        let t = null
          , e = !1
          , i = null
          , n = null;
        function r(e, s) {
            i(e, s),
            n = t.requestAnimationFrame(r)
        }
        return {
            start: function() {
                !0 !== e && null !== i && (n = t.requestAnimationFrame(r),
                e = !0)
            },
            stop: function() {
                t.cancelAnimationFrame(n),
                e = !1
            },
            setAnimationLoop: function(t) {
                i = t
            },
            setContext: function(e) {
                t = e
            }
        }
    }
    function Zd(t, e) {
        const i = e.isWebGL2
          , n = new WeakMap;
        return {
            get: function(t) {
                return t.isInterleavedBufferAttribute && (t = t.data),
                n.get(t)
            },
            remove: function(e) {
                e.isInterleavedBufferAttribute && (e = e.data);
                const i = n.get(e);
                i && (t.deleteBuffer(i.buffer),
                n.delete(e))
            },
            update: function(e, r) {
                if (e.isGLBufferAttribute) {
                    const t = n.get(e);
                    return void ((!t || t.version < e.version) && n.set(e, {
                        buffer: e.buffer,
                        type: e.type,
                        bytesPerElement: e.elementSize,
                        version: e.version
                    }))
                }
                e.isInterleavedBufferAttribute && (e = e.data);
                const s = n.get(e);
                void 0 === s ? n.set(e, function(e, n) {
                    const r = e.array
                      , s = e.usage
                      , a = t.createBuffer();
                    t.bindBuffer(n, a),
                    t.bufferData(n, r, s),
                    e.onUploadCallback();
                    let o = 5126;
                    return r instanceof Float32Array ? o = 5126 : r instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r instanceof Uint16Array ? e.isFloat16BufferAttribute ? i ? o = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : o = 5123 : r instanceof Int16Array ? o = 5122 : r instanceof Uint32Array ? o = 5125 : r instanceof Int32Array ? o = 5124 : r instanceof Int8Array ? o = 5120 : r instanceof Uint8Array && (o = 5121),
                    {
                        buffer: a,
                        type: o,
                        bytesPerElement: r.BYTES_PER_ELEMENT,
                        version: e.version
                    }
                }(e, r)) : s.version < e.version && (!function(e, n, r) {
                    const s = n.array
                      , a = n.updateRange;
                    t.bindBuffer(r, e),
                    -1 === a.count ? t.bufferSubData(r, 0, s) : (i ? t.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s, a.offset, a.count) : t.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s.subarray(a.offset, a.offset + a.count)),
                    a.count = -1)
                }(s.buffer, e, r),
                s.version = e.version)
            }
        }
    }
    class Qd extends fd {
        constructor(t=1, e=1, i=1, n=1) {
            super(),
            this.type = "PlaneGeometry",
            this.parameters = {
                width: t,
                height: e,
                widthSegments: i,
                heightSegments: n
            };
            const r = t / 2
              , s = e / 2
              , a = Math.floor(i)
              , o = Math.floor(n)
              , l = a + 1
              , c = o + 1
              , h = t / a
              , u = e / o
              , d = []
              , p = []
              , f = []
              , m = [];
            for (let t = 0; t < c; t++) {
                const e = t * u - s;
                for (let i = 0; i < l; i++) {
                    const n = i * h - r;
                    p.push(n, -e, 0),
                    f.push(0, 0, 1),
                    m.push(i / a),
                    m.push(1 - t / o)
                }
            }
            for (let t = 0; t < o; t++)
                for (let e = 0; e < a; e++) {
                    const i = e + l * t
                      , n = e + l * (t + 1)
                      , r = e + 1 + l * (t + 1)
                      , s = e + 1 + l * t;
                    d.push(i, n, s),
                    d.push(n, r, s)
                }
            this.setIndex(d),
            this.setAttribute("position", new sd(p,3)),
            this.setAttribute("normal", new sd(f,3)),
            this.setAttribute("uv", new sd(m,2))
        }
    }
    const $d = {
        alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
        alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
        aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
        aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        begin_vertex: "vec3 transformed = vec3( position );",
        beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
        bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
        bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
        clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
        clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
        clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
        clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
        color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
        color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
        color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
        color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
        common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
        cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
        defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
        displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
        displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
        emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
        emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
        encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
        envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
        envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
        envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
        envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
        envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
        envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
        fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",
        fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
        fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
        fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
        gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
        lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
        lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
        lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
        lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
        lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
        lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
        lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
        lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
        lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
        lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
        lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
        lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
        logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
        logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
        logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
        logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
        map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
        map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
        map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
        metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
        morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
        morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
        normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
        normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
        normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
        clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
        clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
        clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
        packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
        premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
        project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
        dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
        dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
        roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
        roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
        shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
        shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
        shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
        shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
        skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
        skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
        skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
        specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
        tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
        transmissionmap_fragment: "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",
        transmissionmap_pars_fragment: "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif",
        uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
        uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
        uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
        uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
        uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
        uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
        worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
        background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
        cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
        depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
        depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
        distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
        distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
        equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
        linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
        linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
        meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
        meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
        normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
        points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
        points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
        shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
    }
      , Kd = {
        common: {
            diffuse: {
                value: new $u(15658734)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new vh
            },
            uv2Transform: {
                value: new vh
            },
            alphaMap: {
                value: null
            }
        },
        specularmap: {
            specularMap: {
                value: null
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            refractionRatio: {
                value: .98
            },
            maxMipLevel: {
                value: 0
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalScale: {
                value: new gh(1,1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new $u(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            lightProbe: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {}
                }
            },
            directionalLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {}
                }
            },
            spotLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotShadowMap: {
                value: []
            },
            spotShadowMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {}
                }
            },
            pointLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            },
            ltc_1: {
                value: null
            },
            ltc_2: {
                value: null
            }
        },
        points: {
            diffuse: {
                value: new $u(15658734)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            uvTransform: {
                value: new vh
            }
        },
        sprite: {
            diffuse: {
                value: new $u(15658734)
            },
            opacity: {
                value: 1
            },
            center: {
                value: new gh(.5,.5)
            },
            rotation: {
                value: 0
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            uvTransform: {
                value: new vh
            }
        }
    }
      , tp = {
        basic: {
            uniforms: zd([Kd.common, Kd.specularmap, Kd.envmap, Kd.aomap, Kd.lightmap, Kd.fog]),
            vertexShader: $d.meshbasic_vert,
            fragmentShader: $d.meshbasic_frag
        },
        lambert: {
            uniforms: zd([Kd.common, Kd.specularmap, Kd.envmap, Kd.aomap, Kd.lightmap, Kd.emissivemap, Kd.fog, Kd.lights, {
                emissive: {
                    value: new $u(0)
                }
            }]),
            vertexShader: $d.meshlambert_vert,
            fragmentShader: $d.meshlambert_frag
        },
        phong: {
            uniforms: zd([Kd.common, Kd.specularmap, Kd.envmap, Kd.aomap, Kd.lightmap, Kd.emissivemap, Kd.bumpmap, Kd.normalmap, Kd.displacementmap, Kd.fog, Kd.lights, {
                emissive: {
                    value: new $u(0)
                },
                specular: {
                    value: new $u(1118481)
                },
                shininess: {
                    value: 30
                }
            }]),
            vertexShader: $d.meshphong_vert,
            fragmentShader: $d.meshphong_frag
        },
        standard: {
            uniforms: zd([Kd.common, Kd.envmap, Kd.aomap, Kd.lightmap, Kd.emissivemap, Kd.bumpmap, Kd.normalmap, Kd.displacementmap, Kd.roughnessmap, Kd.metalnessmap, Kd.fog, Kd.lights, {
                emissive: {
                    value: new $u(0)
                },
                roughness: {
                    value: 1
                },
                metalness: {
                    value: 0
                },
                envMapIntensity: {
                    value: 1
                }
            }]),
            vertexShader: $d.meshphysical_vert,
            fragmentShader: $d.meshphysical_frag
        },
        toon: {
            uniforms: zd([Kd.common, Kd.aomap, Kd.lightmap, Kd.emissivemap, Kd.bumpmap, Kd.normalmap, Kd.displacementmap, Kd.gradientmap, Kd.fog, Kd.lights, {
                emissive: {
                    value: new $u(0)
                }
            }]),
            vertexShader: $d.meshtoon_vert,
            fragmentShader: $d.meshtoon_frag
        },
        matcap: {
            uniforms: zd([Kd.common, Kd.bumpmap, Kd.normalmap, Kd.displacementmap, Kd.fog, {
                matcap: {
                    value: null
                }
            }]),
            vertexShader: $d.meshmatcap_vert,
            fragmentShader: $d.meshmatcap_frag
        },
        points: {
            uniforms: zd([Kd.points, Kd.fog]),
            vertexShader: $d.points_vert,
            fragmentShader: $d.points_frag
        },
        dashed: {
            uniforms: zd([Kd.common, Kd.fog, {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }]),
            vertexShader: $d.linedashed_vert,
            fragmentShader: $d.linedashed_frag
        },
        depth: {
            uniforms: zd([Kd.common, Kd.displacementmap]),
            vertexShader: $d.depth_vert,
            fragmentShader: $d.depth_frag
        },
        normal: {
            uniforms: zd([Kd.common, Kd.bumpmap, Kd.normalmap, Kd.displacementmap, {
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: $d.normal_vert,
            fragmentShader: $d.normal_frag
        },
        sprite: {
            uniforms: zd([Kd.sprite, Kd.fog]),
            vertexShader: $d.sprite_vert,
            fragmentShader: $d.sprite_frag
        },
        background: {
            uniforms: {
                uvTransform: {
                    value: new vh
                },
                t2D: {
                    value: null
                }
            },
            vertexShader: $d.background_vert,
            fragmentShader: $d.background_frag
        },
        cube: {
            uniforms: zd([Kd.envmap, {
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: $d.cube_vert,
            fragmentShader: $d.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: $d.equirect_vert,
            fragmentShader: $d.equirect_frag
        },
        distanceRGBA: {
            uniforms: zd([Kd.common, Kd.displacementmap, {
                referencePosition: {
                    value: new Eh
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1e3
                }
            }]),
            vertexShader: $d.distanceRGBA_vert,
            fragmentShader: $d.distanceRGBA_frag
        },
        shadow: {
            uniforms: zd([Kd.lights, Kd.fog, {
                color: {
                    value: new $u(0)
                },
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: $d.shadow_vert,
            fragmentShader: $d.shadow_frag
        }
    };
    function ep(t, e, i, n, r) {
        const s = new $u(0);
        let a, o, l = 0, c = null, h = 0, u = null;
        function d(t, e) {
            i.buffers.color.setClear(t.r, t.g, t.b, e, r)
        }
        return {
            getClearColor: function() {
                return s
            },
            setClearColor: function(t, e=1) {
                s.set(t),
                l = e,
                d(s, l)
            },
            getClearAlpha: function() {
                return l
            },
            setClearAlpha: function(t) {
                l = t,
                d(s, l)
            },
            render: function(i, r, p, f) {
                let m = !0 === r.isScene ? r.background : null;
                m && m.isTexture && (m = e.get(m));
                const g = t.xr
                  , v = g.getSession && g.getSession();
                v && "additive" === v.environmentBlendMode && (m = null),
                null === m ? d(s, l) : m && m.isColor && (d(m, 1),
                f = !0),
                (t.autoClear || f) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
                m && (m.isCubeTexture || m.mapping === vl) ? (void 0 === o && (o = new Id(new Nd(1,1,1),new Bd({
                    name: "BackgroundCubeMaterial",
                    uniforms: Od(tp.cube.uniforms),
                    vertexShader: tp.cube.vertexShader,
                    fragmentShader: tp.cube.fragmentShader,
                    side: Eo,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                })),
                o.geometry.deleteAttribute("normal"),
                o.geometry.deleteAttribute("uv"),
                o.onBeforeRender = function(t, e, i) {
                    this.matrixWorld.copyPosition(i.matrixWorld)
                }
                ,
                Object.defineProperty(o.material, "envMap", {
                    get: function() {
                        return this.uniforms.envMap.value
                    }
                }),
                n.update(o)),
                o.material.uniforms.envMap.value = m,
                o.material.uniforms.flipEnvMap.value = m.isCubeTexture && m._needsFlipEnvMap ? -1 : 1,
                c === m && h === m.version && u === t.toneMapping || (o.material.needsUpdate = !0,
                c = m,
                h = m.version,
                u = t.toneMapping),
                i.unshift(o, o.geometry, o.material, 0, 0, null)) : m && m.isTexture && (void 0 === a && (a = new Id(new Qd(2,2),new Bd({
                    name: "BackgroundMaterial",
                    uniforms: Od(tp.background.uniforms),
                    vertexShader: tp.background.vertexShader,
                    fragmentShader: tp.background.fragmentShader,
                    side: To,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                })),
                a.geometry.deleteAttribute("normal"),
                Object.defineProperty(a.material, "map", {
                    get: function() {
                        return this.uniforms.t2D.value
                    }
                }),
                n.update(a)),
                a.material.uniforms.t2D.value = m,
                !0 === m.matrixAutoUpdate && m.updateMatrix(),
                a.material.uniforms.uvTransform.value.copy(m.matrix),
                c === m && h === m.version && u === t.toneMapping || (a.material.needsUpdate = !0,
                c = m,
                h = m.version,
                u = t.toneMapping),
                i.unshift(a, a.geometry, a.material, 0, 0, null))
            }
        }
    }
    function ip(t, e, i, n) {
        const r = t.getParameter(34921)
          , s = n.isWebGL2 ? null : e.get("OES_vertex_array_object")
          , a = n.isWebGL2 || null !== s
          , o = {}
          , l = d(null);
        let c = l;
        function h(e) {
            return n.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e)
        }
        function u(e) {
            return n.isWebGL2 ? t.deleteVertexArray(e) : s.deleteVertexArrayOES(e)
        }
        function d(t) {
            const e = []
              , i = []
              , n = [];
            for (let t = 0; t < r; t++)
                e[t] = 0,
                i[t] = 0,
                n[t] = 0;
            return {
                geometry: null,
                program: null,
                wireframe: !1,
                newAttributes: e,
                enabledAttributes: i,
                attributeDivisors: n,
                object: t,
                attributes: {},
                index: null
            }
        }
        function p() {
            const t = c.newAttributes;
            for (let e = 0, i = t.length; e < i; e++)
                t[e] = 0
        }
        function f(t) {
            m(t, 0)
        }
        function m(i, r) {
            const s = c.newAttributes
              , a = c.enabledAttributes
              , o = c.attributeDivisors;
            if (s[i] = 1,
            0 === a[i] && (t.enableVertexAttribArray(i),
            a[i] = 1),
            o[i] !== r) {
                (n.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](i, r),
                o[i] = r
            }
        }
        function g() {
            const e = c.newAttributes
              , i = c.enabledAttributes;
            for (let n = 0, r = i.length; n < r; n++)
                i[n] !== e[n] && (t.disableVertexAttribArray(n),
                i[n] = 0)
        }
        function v(e, i, r, s, a, o) {
            !0 !== n.isWebGL2 || 5124 !== r && 5125 !== r ? t.vertexAttribPointer(e, i, r, s, a, o) : t.vertexAttribIPointer(e, i, r, a, o)
        }
        function y() {
            x(),
            c !== l && (c = l,
            h(c.object))
        }
        function x() {
            l.geometry = null,
            l.program = null,
            l.wireframe = !1
        }
        return {
            setup: function(r, l, u, y, x) {
                let _ = !1;
                if (a) {
                    const e = function(e, i, r) {
                        const a = !0 === r.wireframe;
                        let l = o[e.id];
                        void 0 === l && (l = {},
                        o[e.id] = l);
                        let c = l[i.id];
                        void 0 === c && (c = {},
                        l[i.id] = c);
                        let h = c[a];
                        void 0 === h && (h = d(n.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES()),
                        c[a] = h);
                        return h
                    }(y, u, l);
                    c !== e && (c = e,
                    h(c.object)),
                    _ = function(t, e) {
                        const i = c.attributes
                          , n = t.attributes;
                        let r = 0;
                        for (const t in n) {
                            const e = i[t]
                              , s = n[t];
                            if (void 0 === e)
                                return !0;
                            if (e.attribute !== s)
                                return !0;
                            if (e.data !== s.data)
                                return !0;
                            r++
                        }
                        return c.attributesNum !== r || c.index !== e
                    }(y, x),
                    _ && function(t, e) {
                        const i = {}
                          , n = t.attributes;
                        let r = 0;
                        for (const t in n) {
                            const e = n[t]
                              , s = {};
                            s.attribute = e,
                            e.data && (s.data = e.data),
                            i[t] = s,
                            r++
                        }
                        c.attributes = i,
                        c.attributesNum = r,
                        c.index = e
                    }(y, x)
                } else {
                    const t = !0 === l.wireframe;
                    c.geometry === y.id && c.program === u.id && c.wireframe === t || (c.geometry = y.id,
                    c.program = u.id,
                    c.wireframe = t,
                    _ = !0)
                }
                !0 === r.isInstancedMesh && (_ = !0),
                null !== x && i.update(x, 34963),
                _ && (!function(r, s, a, o) {
                    if (!1 === n.isWebGL2 && (r.isInstancedMesh || o.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays"))
                        return;
                    p();
                    const l = o.attributes
                      , c = a.getAttributes()
                      , h = s.defaultAttributeValues;
                    for (const e in c) {
                        const n = c[e];
                        if (n >= 0) {
                            const s = l[e];
                            if (void 0 !== s) {
                                const e = s.normalized
                                  , r = s.itemSize
                                  , a = i.get(s);
                                if (void 0 === a)
                                    continue;
                                const l = a.buffer
                                  , c = a.type
                                  , h = a.bytesPerElement;
                                if (s.isInterleavedBufferAttribute) {
                                    const i = s.data
                                      , a = i.stride
                                      , u = s.offset;
                                    i && i.isInstancedInterleavedBuffer ? (m(n, i.meshPerAttribute),
                                    void 0 === o._maxInstanceCount && (o._maxInstanceCount = i.meshPerAttribute * i.count)) : f(n),
                                    t.bindBuffer(34962, l),
                                    v(n, r, c, e, a * h, u * h)
                                } else
                                    s.isInstancedBufferAttribute ? (m(n, s.meshPerAttribute),
                                    void 0 === o._maxInstanceCount && (o._maxInstanceCount = s.meshPerAttribute * s.count)) : f(n),
                                    t.bindBuffer(34962, l),
                                    v(n, r, c, e, 0, 0)
                            } else if ("instanceMatrix" === e) {
                                const e = i.get(r.instanceMatrix);
                                if (void 0 === e)
                                    continue;
                                const s = e.buffer
                                  , a = e.type;
                                m(n + 0, 1),
                                m(n + 1, 1),
                                m(n + 2, 1),
                                m(n + 3, 1),
                                t.bindBuffer(34962, s),
                                t.vertexAttribPointer(n + 0, 4, a, !1, 64, 0),
                                t.vertexAttribPointer(n + 1, 4, a, !1, 64, 16),
                                t.vertexAttribPointer(n + 2, 4, a, !1, 64, 32),
                                t.vertexAttribPointer(n + 3, 4, a, !1, 64, 48)
                            } else if ("instanceColor" === e) {
                                const e = i.get(r.instanceColor);
                                if (void 0 === e)
                                    continue;
                                const s = e.buffer
                                  , a = e.type;
                                m(n, 1),
                                t.bindBuffer(34962, s),
                                t.vertexAttribPointer(n, 3, a, !1, 12, 0)
                            } else if (void 0 !== h) {
                                const i = h[e];
                                if (void 0 !== i)
                                    switch (i.length) {
                                    case 2:
                                        t.vertexAttrib2fv(n, i);
                                        break;
                                    case 3:
                                        t.vertexAttrib3fv(n, i);
                                        break;
                                    case 4:
                                        t.vertexAttrib4fv(n, i);
                                        break;
                                    default:
                                        t.vertexAttrib1fv(n, i)
                                    }
                            }
                        }
                    }
                    g()
                }(r, l, u, y),
                null !== x && t.bindBuffer(34963, i.get(x).buffer))
            },
            reset: y,
            resetDefaultState: x,
            dispose: function() {
                y();
                for (const t in o) {
                    const e = o[t];
                    for (const t in e) {
                        const i = e[t];
                        for (const t in i)
                            u(i[t].object),
                            delete i[t];
                        delete e[t]
                    }
                    delete o[t]
                }
            },
            releaseStatesOfGeometry: function(t) {
                if (void 0 === o[t.id])
                    return;
                const e = o[t.id];
                for (const t in e) {
                    const i = e[t];
                    for (const t in i)
                        u(i[t].object),
                        delete i[t];
                    delete e[t]
                }
                delete o[t.id]
            },
            releaseStatesOfProgram: function(t) {
                for (const e in o) {
                    const i = o[e];
                    if (void 0 === i[t.id])
                        continue;
                    const n = i[t.id];
                    for (const t in n)
                        u(n[t].object),
                        delete n[t];
                    delete i[t.id]
                }
            },
            initAttributes: p,
            enableAttribute: f,
            disableUnusedAttributes: g
        }
    }
    function np(t, e, i, n) {
        const r = n.isWebGL2;
        let s;
        this.setMode = function(t) {
            s = t
        }
        ,
        this.render = function(e, n) {
            t.drawArrays(s, e, n),
            i.update(n, s, 1)
        }
        ,
        this.renderInstances = function(n, a, o) {
            if (0 === o)
                return;
            let l, c;
            if (r)
                l = t,
                c = "drawArraysInstanced";
            else if (l = e.get("ANGLE_instanced_arrays"),
            c = "drawArraysInstancedANGLE",
            null === l)
                return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            l[c](s, n, a, o),
            i.update(a, s, o)
        }
    }
    function rp(t, e, i) {
        let n;
        function r(e) {
            if ("highp" === e) {
                if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0)
                    return "highp";
                e = "mediump"
            }
            return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
        }
        const s = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext;
        let a = void 0 !== i.precision ? i.precision : "highp";
        const o = r(a);
        o !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", o, "instead."),
        a = o);
        const l = !0 === i.logarithmicDepthBuffer
          , c = t.getParameter(34930)
          , h = t.getParameter(35660)
          , u = t.getParameter(3379)
          , d = t.getParameter(34076)
          , p = t.getParameter(34921)
          , f = t.getParameter(36347)
          , m = t.getParameter(36348)
          , g = t.getParameter(36349)
          , v = h > 0
          , y = s || e.has("OES_texture_float");
        return {
            isWebGL2: s,
            getMaxAnisotropy: function() {
                if (void 0 !== n)
                    return n;
                if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                    const i = e.get("EXT_texture_filter_anisotropic");
                    n = t.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                } else
                    n = 0;
                return n
            },
            getMaxPrecision: r,
            precision: a,
            logarithmicDepthBuffer: l,
            maxTextures: c,
            maxVertexTextures: h,
            maxTextureSize: u,
            maxCubemapSize: d,
            maxAttributes: p,
            maxVertexUniforms: f,
            maxVaryings: m,
            maxFragmentUniforms: g,
            vertexTextures: v,
            floatFragmentTextures: y,
            floatVertexTextures: v && y,
            maxSamples: s ? t.getParameter(36183) : 0
        }
    }
    function sp(t) {
        const e = this;
        let i = null
          , n = 0
          , r = !1
          , s = !1;
        const a = new Iu
          , o = new vh
          , l = {
            value: null,
            needsUpdate: !1
        };
        function c() {
            l.value !== i && (l.value = i,
            l.needsUpdate = n > 0),
            e.numPlanes = n,
            e.numIntersection = 0
        }
        function h(t, i, n, r) {
            const s = null !== t ? t.length : 0;
            let c = null;
            if (0 !== s) {
                if (c = l.value,
                !0 !== r || null === c) {
                    const e = n + 4 * s
                      , r = i.matrixWorldInverse;
                    o.getNormalMatrix(r),
                    (null === c || c.length < e) && (c = new Float32Array(e));
                    for (let e = 0, i = n; e !== s; ++e,
                    i += 4)
                        a.copy(t[e]).applyMatrix4(r, o),
                        a.normal.toArray(c, i),
                        c[i + 3] = a.constant
                }
                l.value = c,
                l.needsUpdate = !0
            }
            return e.numPlanes = s,
            e.numIntersection = 0,
            c
        }
        this.uniform = l,
        this.numPlanes = 0,
        this.numIntersection = 0,
        this.init = function(t, e, s) {
            const a = 0 !== t.length || e || 0 !== n || r;
            return r = e,
            i = h(t, s, 0),
            n = t.length,
            a
        }
        ,
        this.beginShadows = function() {
            s = !0,
            h(null)
        }
        ,
        this.endShadows = function() {
            s = !1,
            c()
        }
        ,
        this.setState = function(e, a, o) {
            const u = e.clippingPlanes
              , d = e.clipIntersection
              , p = e.clipShadows
              , f = t.get(e);
            if (!r || null === u || 0 === u.length || s && !p)
                s ? h(null) : c();
            else {
                const t = s ? 0 : n
                  , e = 4 * t;
                let r = f.clippingState || null;
                l.value = r,
                r = h(u, a, e, o);
                for (let t = 0; t !== e; ++t)
                    r[t] = i[t];
                f.clippingState = r,
                this.numIntersection = d ? this.numPlanes : 0,
                this.numPlanes += t
            }
        }
    }
    function ap(t) {
        let e = new WeakMap;
        function i(t, e) {
            return e === ml ? t.mapping = pl : e === gl && (t.mapping = fl),
            t
        }
        function n(t) {
            const i = t.target;
            i.removeEventListener("dispose", n);
            const r = e.get(i);
            void 0 !== r && (e.delete(i),
            r.dispose())
        }
        return {
            get: function(r) {
                if (r && r.isTexture) {
                    const s = r.mapping;
                    if (s === ml || s === gl) {
                        if (e.has(r)) {
                            return i(e.get(r).texture, r.mapping)
                        }
                        {
                            const s = r.image;
                            if (s && s.height > 0) {
                                const a = t.getRenderTarget()
                                  , o = new Wd(s.height / 2);
                                return o.fromEquirectangularTexture(t, r),
                                e.set(r, o),
                                t.setRenderTarget(a),
                                r.addEventListener("dispose", n),
                                i(o.texture, r.mapping)
                            }
                            return null
                        }
                    }
                }
                return r
            },
            dispose: function() {
                e = new WeakMap
            }
        }
    }
    function op(t) {
        const e = {};
        function i(i) {
            if (void 0 !== e[i])
                return e[i];
            let n;
            switch (i) {
            case "WEBGL_depth_texture":
                n = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                break;
            case "EXT_texture_filter_anisotropic":
                n = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                break;
            case "WEBGL_compressed_texture_s3tc":
                n = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                break;
            case "WEBGL_compressed_texture_pvrtc":
                n = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                break;
            default:
                n = t.getExtension(i)
            }
            return e[i] = n,
            n
        }
        return {
            has: function(t) {
                return null !== i(t)
            },
            init: function(t) {
                t.isWebGL2 ? i("EXT_color_buffer_float") : (i("WEBGL_depth_texture"),
                i("OES_texture_float"),
                i("OES_texture_half_float"),
                i("OES_texture_half_float_linear"),
                i("OES_standard_derivatives"),
                i("OES_element_index_uint"),
                i("OES_vertex_array_object"),
                i("ANGLE_instanced_arrays")),
                i("OES_texture_float_linear"),
                i("EXT_color_buffer_half_float")
            },
            get: function(t) {
                const e = i(t);
                return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."),
                e
            }
        }
    }
    function lp(t, e, i, n) {
        const r = {}
          , s = new WeakMap;
        function a(t) {
            const o = t.target;
            null !== o.index && e.remove(o.index);
            for (const t in o.attributes)
                e.remove(o.attributes[t]);
            o.removeEventListener("dispose", a),
            delete r[o.id];
            const l = s.get(o);
            l && (e.remove(l),
            s.delete(o)),
            n.releaseStatesOfGeometry(o),
            !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount,
            i.memory.geometries--
        }
        function o(t) {
            const i = []
              , n = t.index
              , r = t.attributes.position;
            let a = 0;
            if (null !== n) {
                const t = n.array;
                a = n.version;
                for (let e = 0, n = t.length; e < n; e += 3) {
                    const n = t[e + 0]
                      , r = t[e + 1]
                      , s = t[e + 2];
                    i.push(n, r, r, s, s, n)
                }
            } else {
                const t = r.array;
                a = r.version;
                for (let e = 0, n = t.length / 3 - 1; e < n; e += 3) {
                    const t = e + 0
                      , n = e + 1
                      , r = e + 2;
                    i.push(t, n, n, r, r, t)
                }
            }
            const o = new (ad(i) > 65535 ? rd : nd)(i,1);
            o.version = a;
            const l = s.get(t);
            l && e.remove(l),
            s.set(t, o)
        }
        return {
            get: function(t, e) {
                return !0 === r[e.id] || (e.addEventListener("dispose", a),
                r[e.id] = !0,
                i.memory.geometries++),
                e
            },
            update: function(t) {
                const i = t.attributes;
                for (const t in i)
                    e.update(i[t], 34962);
                const n = t.morphAttributes;
                for (const t in n) {
                    const i = n[t];
                    for (let t = 0, n = i.length; t < n; t++)
                        e.update(i[t], 34962)
                }
            },
            getWireframeAttribute: function(t) {
                const e = s.get(t);
                if (e) {
                    const i = t.index;
                    null !== i && e.version < i.version && o(t)
                } else
                    o(t);
                return s.get(t)
            }
        }
    }
    function cp(t, e, i, n) {
        const r = n.isWebGL2;
        let s, a, o;
        this.setMode = function(t) {
            s = t
        }
        ,
        this.setIndex = function(t) {
            a = t.type,
            o = t.bytesPerElement
        }
        ,
        this.render = function(e, n) {
            t.drawElements(s, n, a, e * o),
            i.update(n, s, 1)
        }
        ,
        this.renderInstances = function(n, l, c) {
            if (0 === c)
                return;
            let h, u;
            if (r)
                h = t,
                u = "drawElementsInstanced";
            else if (h = e.get("ANGLE_instanced_arrays"),
            u = "drawElementsInstancedANGLE",
            null === h)
                return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            h[u](s, l, a, n * o, c),
            i.update(l, s, c)
        }
    }
    function hp(t) {
        const e = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };
        return {
            memory: {
                geometries: 0,
                textures: 0
            },
            render: e,
            programs: null,
            autoReset: !0,
            reset: function() {
                e.frame++,
                e.calls = 0,
                e.triangles = 0,
                e.points = 0,
                e.lines = 0
            },
            update: function(t, i, n) {
                switch (e.calls++,
                i) {
                case 4:
                    e.triangles += n * (t / 3);
                    break;
                case 1:
                    e.lines += n * (t / 2);
                    break;
                case 3:
                    e.lines += n * (t - 1);
                    break;
                case 2:
                    e.lines += n * t;
                    break;
                case 0:
                    e.points += n * t;
                    break;
                default:
                    console.error("THREE.WebGLInfo: Unknown draw mode:", i)
                }
            }
        }
    }
    function up(t, e) {
        return t[0] - e[0]
    }
    function dp(t, e) {
        return Math.abs(e[1]) - Math.abs(t[1])
    }
    function pp(t) {
        const e = {}
          , i = new Float32Array(8)
          , n = [];
        for (let t = 0; t < 8; t++)
            n[t] = [t, 0];
        return {
            update: function(r, s, a, o) {
                const l = r.morphTargetInfluences
                  , c = void 0 === l ? 0 : l.length;
                let h = e[s.id];
                if (void 0 === h) {
                    h = [];
                    for (let t = 0; t < c; t++)
                        h[t] = [t, 0];
                    e[s.id] = h
                }
                for (let t = 0; t < c; t++) {
                    const e = h[t];
                    e[0] = t,
                    e[1] = l[t]
                }
                h.sort(dp);
                for (let t = 0; t < 8; t++)
                    t < c && h[t][1] ? (n[t][0] = h[t][0],
                    n[t][1] = h[t][1]) : (n[t][0] = Number.MAX_SAFE_INTEGER,
                    n[t][1] = 0);
                n.sort(up);
                const u = a.morphTargets && s.morphAttributes.position
                  , d = a.morphNormals && s.morphAttributes.normal;
                let p = 0;
                for (let t = 0; t < 8; t++) {
                    const e = n[t]
                      , r = e[0]
                      , a = e[1];
                    r !== Number.MAX_SAFE_INTEGER && a ? (u && s.getAttribute("morphTarget" + t) !== u[r] && s.setAttribute("morphTarget" + t, u[r]),
                    d && s.getAttribute("morphNormal" + t) !== d[r] && s.setAttribute("morphNormal" + t, d[r]),
                    i[t] = a,
                    p += a) : (u && !0 === s.hasAttribute("morphTarget" + t) && s.deleteAttribute("morphTarget" + t),
                    d && !0 === s.hasAttribute("morphNormal" + t) && s.deleteAttribute("morphNormal" + t),
                    i[t] = 0)
                }
                const f = s.morphTargetsRelative ? 1 : 1 - p;
                o.getUniforms().setValue(t, "morphTargetBaseInfluence", f),
                o.getUniforms().setValue(t, "morphTargetInfluences", i)
            }
        }
    }
    function fp(t, e, i, n) {
        let r = new WeakMap;
        function s(t) {
            const e = t.target;
            e.removeEventListener("dispose", s),
            i.remove(e.instanceMatrix),
            null !== e.instanceColor && i.remove(e.instanceColor)
        }
        return {
            update: function(t) {
                const a = n.render.frame
                  , o = t.geometry
                  , l = e.get(t, o);
                return r.get(l) !== a && (e.update(l),
                r.set(l, a)),
                t.isInstancedMesh && (!1 === t.hasEventListener("dispose", s) && t.addEventListener("dispose", s),
                i.update(t.instanceMatrix, 34962),
                null !== t.instanceColor && i.update(t.instanceColor, 34962)),
                l
            },
            dispose: function() {
                r = new WeakMap
            }
        }
    }
    tp.physical = {
        uniforms: zd([tp.standard.uniforms, {
            clearcoat: {
                value: 0
            },
            clearcoatMap: {
                value: null
            },
            clearcoatRoughness: {
                value: 0
            },
            clearcoatRoughnessMap: {
                value: null
            },
            clearcoatNormalScale: {
                value: new gh(1,1)
            },
            clearcoatNormalMap: {
                value: null
            },
            sheen: {
                value: new $u(0)
            },
            transmission: {
                value: 0
            },
            transmissionMap: {
                value: null
            }
        }]),
        vertexShader: $d.meshphysical_vert,
        fragmentShader: $d.meshphysical_frag
    };
    class mp extends wh {
        constructor(t=null, e=1, i=1, n=1) {
            super(null),
            this.image = {
                data: t,
                width: e,
                height: i,
                depth: n
            },
            this.magFilter = bl,
            this.minFilter = bl,
            this.wrapR = _l,
            this.generateMipmaps = !1,
            this.flipY = !1,
            this.unpackAlignment = 1,
            this.needsUpdate = !0
        }
    }
    mp.prototype.isDataTexture2DArray = !0;
    class gp extends wh {
        constructor(t=null, e=1, i=1, n=1) {
            super(null),
            this.image = {
                data: t,
                width: e,
                height: i,
                depth: n
            },
            this.magFilter = bl,
            this.minFilter = bl,
            this.wrapR = _l,
            this.generateMipmaps = !1,
            this.flipY = !1,
            this.unpackAlignment = 1,
            this.needsUpdate = !0
        }
    }
    gp.prototype.isDataTexture3D = !0;
    const vp = new wh
      , yp = new mp
      , xp = new gp
      , _p = new Vd
      , wp = []
      , bp = []
      , Mp = new Float32Array(16)
      , Sp = new Float32Array(9)
      , Tp = new Float32Array(4);
    function Ep(t, e, i) {
        const n = t[0];
        if (n <= 0 || n > 0)
            return t;
        const r = e * i;
        let s = wp[r];
        if (void 0 === s && (s = new Float32Array(r),
        wp[r] = s),
        0 !== e) {
            n.toArray(s, 0);
            for (let n = 1, r = 0; n !== e; ++n)
                r += i,
                t[n].toArray(s, r)
        }
        return s
    }
    function Lp(t, e) {
        if (t.length !== e.length)
            return !1;
        for (let i = 0, n = t.length; i < n; i++)
            if (t[i] !== e[i])
                return !1;
        return !0
    }
    function Ap(t, e) {
        for (let i = 0, n = e.length; i < n; i++)
            t[i] = e[i]
    }
    function Cp(t, e) {
        let i = bp[e];
        void 0 === i && (i = new Int32Array(e),
        bp[e] = i);
        for (let n = 0; n !== e; ++n)
            i[n] = t.allocateTextureUnit();
        return i
    }
    function Pp(t, e) {
        const i = this.cache;
        i[0] !== e && (t.uniform1f(this.addr, e),
        i[0] = e)
    }
    function Rp(t, e) {
        const i = this.cache;
        if (void 0 !== e.x)
            i[0] === e.x && i[1] === e.y || (t.uniform2f(this.addr, e.x, e.y),
            i[0] = e.x,
            i[1] = e.y);
        else {
            if (Lp(i, e))
                return;
            t.uniform2fv(this.addr, e),
            Ap(i, e)
        }
    }
    function Ip(t, e) {
        const i = this.cache;
        if (void 0 !== e.x)
            i[0] === e.x && i[1] === e.y && i[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z),
            i[0] = e.x,
            i[1] = e.y,
            i[2] = e.z);
        else if (void 0 !== e.r)
            i[0] === e.r && i[1] === e.g && i[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b),
            i[0] = e.r,
            i[1] = e.g,
            i[2] = e.b);
        else {
            if (Lp(i, e))
                return;
            t.uniform3fv(this.addr, e),
            Ap(i, e)
        }
    }
    function Dp(t, e) {
        const i = this.cache;
        if (void 0 !== e.x)
            i[0] === e.x && i[1] === e.y && i[2] === e.z && i[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
            i[0] = e.x,
            i[1] = e.y,
            i[2] = e.z,
            i[3] = e.w);
        else {
            if (Lp(i, e))
                return;
            t.uniform4fv(this.addr, e),
            Ap(i, e)
        }
    }
    function Np(t, e) {
        const i = this.cache
          , n = e.elements;
        if (void 0 === n) {
            if (Lp(i, e))
                return;
            t.uniformMatrix2fv(this.addr, !1, e),
            Ap(i, e)
        } else {
            if (Lp(i, n))
                return;
            Tp.set(n),
            t.uniformMatrix2fv(this.addr, !1, Tp),
            Ap(i, n)
        }
    }
    function Op(t, e) {
        const i = this.cache
          , n = e.elements;
        if (void 0 === n) {
            if (Lp(i, e))
                return;
            t.uniformMatrix3fv(this.addr, !1, e),
            Ap(i, e)
        } else {
            if (Lp(i, n))
                return;
            Sp.set(n),
            t.uniformMatrix3fv(this.addr, !1, Sp),
            Ap(i, n)
        }
    }
    function zp(t, e) {
        const i = this.cache
          , n = e.elements;
        if (void 0 === n) {
            if (Lp(i, e))
                return;
            t.uniformMatrix4fv(this.addr, !1, e),
            Ap(i, e)
        } else {
            if (Lp(i, n))
                return;
            Mp.set(n),
            t.uniformMatrix4fv(this.addr, !1, Mp),
            Ap(i, n)
        }
    }
    function kp(t, e) {
        const i = this.cache;
        i[0] !== e && (t.uniform1i(this.addr, e),
        i[0] = e)
    }
    function Bp(t, e) {
        const i = this.cache;
        Lp(i, e) || (t.uniform2iv(this.addr, e),
        Ap(i, e))
    }
    function Fp(t, e) {
        const i = this.cache;
        Lp(i, e) || (t.uniform3iv(this.addr, e),
        Ap(i, e))
    }
    function Hp(t, e) {
        const i = this.cache;
        Lp(i, e) || (t.uniform4iv(this.addr, e),
        Ap(i, e))
    }
    function Up(t, e) {
        const i = this.cache;
        i[0] !== e && (t.uniform1ui(this.addr, e),
        i[0] = e)
    }
    function Gp(t, e) {
        const i = this.cache;
        Lp(i, e) || (t.uniform2uiv(this.addr, e),
        Ap(i, e))
    }
    function Vp(t, e) {
        const i = this.cache;
        Lp(i, e) || (t.uniform3uiv(this.addr, e),
        Ap(i, e))
    }
    function Wp(t, e) {
        const i = this.cache;
        Lp(i, e) || (t.uniform4uiv(this.addr, e),
        Ap(i, e))
    }
    function qp(t, e, i) {
        const n = this.cache
          , r = i.allocateTextureUnit();
        n[0] !== r && (t.uniform1i(this.addr, r),
        n[0] = r),
        i.safeSetTexture2D(e || vp, r)
    }
    function jp(t, e, i) {
        const n = this.cache
          , r = i.allocateTextureUnit();
        n[0] !== r && (t.uniform1i(this.addr, r),
        n[0] = r),
        i.setTexture3D(e || xp, r)
    }
    function Yp(t, e, i) {
        const n = this.cache
          , r = i.allocateTextureUnit();
        n[0] !== r && (t.uniform1i(this.addr, r),
        n[0] = r),
        i.safeSetTextureCube(e || _p, r)
    }
    function Xp(t, e, i) {
        const n = this.cache
          , r = i.allocateTextureUnit();
        n[0] !== r && (t.uniform1i(this.addr, r),
        n[0] = r),
        i.setTexture2DArray(e || yp, r)
    }
    function Jp(t, e) {
        t.uniform1fv(this.addr, e)
    }
    function Zp(t, e) {
        const i = Ep(e, this.size, 2);
        t.uniform2fv(this.addr, i)
    }
    function Qp(t, e) {
        const i = Ep(e, this.size, 3);
        t.uniform3fv(this.addr, i)
    }
    function $p(t, e) {
        const i = Ep(e, this.size, 4);
        t.uniform4fv(this.addr, i)
    }
    function Kp(t, e) {
        const i = Ep(e, this.size, 4);
        t.uniformMatrix2fv(this.addr, !1, i)
    }
    function tf(t, e) {
        const i = Ep(e, this.size, 9);
        t.uniformMatrix3fv(this.addr, !1, i)
    }
    function ef(t, e) {
        const i = Ep(e, this.size, 16);
        t.uniformMatrix4fv(this.addr, !1, i)
    }
    function nf(t, e) {
        t.uniform1iv(this.addr, e)
    }
    function rf(t, e) {
        t.uniform2iv(this.addr, e)
    }
    function sf(t, e) {
        t.uniform3iv(this.addr, e)
    }
    function af(t, e) {
        t.uniform4iv(this.addr, e)
    }
    function of(t, e) {
        t.uniform1uiv(this.addr, e)
    }
    function lf(t, e) {
        t.uniform2uiv(this.addr, e)
    }
    function cf(t, e) {
        t.uniform3uiv(this.addr, e)
    }
    function hf(t, e) {
        t.uniform4uiv(this.addr, e)
    }
    function uf(t, e, i) {
        const n = e.length
          , r = Cp(i, n);
        t.uniform1iv(this.addr, r);
        for (let t = 0; t !== n; ++t)
            i.safeSetTexture2D(e[t] || vp, r[t])
    }
    function df(t, e, i) {
        const n = e.length
          , r = Cp(i, n);
        t.uniform1iv(this.addr, r);
        for (let t = 0; t !== n; ++t)
            i.safeSetTextureCube(e[t] || _p, r[t])
    }
    function pf(t, e, i) {
        this.id = t,
        this.addr = i,
        this.cache = [],
        this.setValue = function(t) {
            switch (t) {
            case 5126:
                return Pp;
            case 35664:
                return Rp;
            case 35665:
                return Ip;
            case 35666:
                return Dp;
            case 35674:
                return Np;
            case 35675:
                return Op;
            case 35676:
                return zp;
            case 5124:
            case 35670:
                return kp;
            case 35667:
            case 35671:
                return Bp;
            case 35668:
            case 35672:
                return Fp;
            case 35669:
            case 35673:
                return Hp;
            case 5125:
                return Up;
            case 36294:
                return Gp;
            case 36295:
                return Vp;
            case 36296:
                return Wp;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                return qp;
            case 35679:
            case 36299:
            case 36307:
                return jp;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                return Yp;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
                return Xp
            }
        }(e.type)
    }
    function ff(t, e, i) {
        this.id = t,
        this.addr = i,
        this.cache = [],
        this.size = e.size,
        this.setValue = function(t) {
            switch (t) {
            case 5126:
                return Jp;
            case 35664:
                return Zp;
            case 35665:
                return Qp;
            case 35666:
                return $p;
            case 35674:
                return Kp;
            case 35675:
                return tf;
            case 35676:
                return ef;
            case 5124:
            case 35670:
                return nf;
            case 35667:
            case 35671:
                return rf;
            case 35668:
            case 35672:
                return sf;
            case 35669:
            case 35673:
                return af;
            case 5125:
                return of;
            case 36294:
                return lf;
            case 36295:
                return cf;
            case 36296:
                return hf;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                return uf;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                return df
            }
        }(e.type)
    }
    function mf(t) {
        this.id = t,
        this.seq = [],
        this.map = {}
    }
    ff.prototype.updateCache = function(t) {
        const e = this.cache;
        t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)),
        Ap(e, t)
    }
    ,
    mf.prototype.setValue = function(t, e, i) {
        const n = this.seq;
        for (let r = 0, s = n.length; r !== s; ++r) {
            const s = n[r];
            s.setValue(t, e[s.id], i)
        }
    }
    ;
    const gf = /(\w+)(\])?(\[|\.)?/g;
    function vf(t, e) {
        t.seq.push(e),
        t.map[e.id] = e
    }
    function yf(t, e, i) {
        const n = t.name
          , r = n.length;
        for (gf.lastIndex = 0; ; ) {
            const s = gf.exec(n)
              , a = gf.lastIndex;
            let o = s[1];
            const l = "]" === s[2]
              , c = s[3];
            if (l && (o |= 0),
            void 0 === c || "[" === c && a + 2 === r) {
                vf(i, void 0 === c ? new pf(o,t,e) : new ff(o,t,e));
                break
            }
            {
                let t = i.map[o];
                void 0 === t && (t = new mf(o),
                vf(i, t)),
                i = t
            }
        }
    }
    function xf(t, e) {
        this.seq = [],
        this.map = {};
        const i = t.getProgramParameter(e, 35718);
        for (let n = 0; n < i; ++n) {
            const i = t.getActiveUniform(e, n);
            yf(i, t.getUniformLocation(e, i.name), this)
        }
    }
    function _f(t, e, i) {
        const n = t.createShader(e);
        return t.shaderSource(n, i),
        t.compileShader(n),
        n
    }
    xf.prototype.setValue = function(t, e, i, n) {
        const r = this.map[e];
        void 0 !== r && r.setValue(t, i, n)
    }
    ,
    xf.prototype.setOptional = function(t, e, i) {
        const n = e[i];
        void 0 !== n && this.setValue(t, i, n)
    }
    ,
    xf.upload = function(t, e, i, n) {
        for (let r = 0, s = e.length; r !== s; ++r) {
            const s = e[r]
              , a = i[s.id];
            !1 !== a.needsUpdate && s.setValue(t, a.value, n)
        }
    }
    ,
    xf.seqWithValue = function(t, e) {
        const i = [];
        for (let n = 0, r = t.length; n !== r; ++n) {
            const r = t[n];
            r.id in e && i.push(r)
        }
        return i
    }
    ;
    let wf = 0;
    function bf(t) {
        switch (t) {
        case jc:
            return ["Linear", "( value )"];
        case Yc:
            return ["sRGB", "( value )"];
        case Jc:
            return ["RGBE", "( value )"];
        case Qc:
            return ["RGBM", "( value, 7.0 )"];
        case $c:
            return ["RGBM", "( value, 16.0 )"];
        case Kc:
            return ["RGBD", "( value, 256.0 )"];
        case Xc:
            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
        case Zc:
            return ["LogLuv", "( value )"];
        default:
            return console.warn("THREE.WebGLProgram: Unsupported encoding:", t),
            ["Linear", "( value )"]
        }
    }
    function Mf(t, e, i) {
        const n = t.getShaderParameter(e, 35713)
          , r = t.getShaderInfoLog(e).trim();
        if (n && "" === r)
            return "";
        return "THREE.WebGLShader: gl.getShaderInfoLog() " + i + "\n" + r + function(t) {
            const e = t.split("\n");
            for (let t = 0; t < e.length; t++)
                e[t] = t + 1 + ": " + e[t];
            return e.join("\n")
        }(t.getShaderSource(e))
    }
    function Sf(t, e) {
        const i = bf(e);
        return "vec4 " + t + "( vec4 value ) { return " + i[0] + "ToLinear" + i[1] + "; }"
    }
    function Tf(t, e) {
        const i = bf(e);
        return "vec4 " + t + "( vec4 value ) { return LinearTo" + i[0] + i[1] + "; }"
    }
    function Ef(t, e) {
        let i;
        switch (e) {
        case ll:
            i = "Linear";
            break;
        case cl:
            i = "Reinhard";
            break;
        case hl:
            i = "OptimizedCineon";
            break;
        case ul:
            i = "ACESFilmic";
            break;
        case dl:
            i = "Custom";
            break;
        default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
            i = "Linear"
        }
        return "vec3 " + t + "( vec3 color ) { return " + i + "ToneMapping( color ); }"
    }
    function Lf(t) {
        return "" !== t
    }
    function Af(t, e) {
        return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
    }
    function Cf(t, e) {
        return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
    }
    const Pf = /^[ \t]*#include +<([\w\d./]+)>/gm;
    function Rf(t) {
        return t.replace(Pf, If)
    }
    function If(t, e) {
        const i = $d[e];
        if (void 0 === i)
            throw new Error("Can not resolve #include <" + e + ">");
        return Rf(i)
    }
    const Df = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g
      , Nf = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
    function Of(t) {
        return t.replace(Nf, kf).replace(Df, zf)
    }
    function zf(t, e, i, n) {
        return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),
        kf(t, e, i, n)
    }
    function kf(t, e, i, n) {
        let r = "";
        for (let t = parseInt(e); t < parseInt(i); t++)
            r += n.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);
        return r
    }
    function Bf(t) {
        let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
        return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"),
        e
    }
    function Ff(t, e, i, n) {
        const r = t.getContext()
          , s = i.defines;
        let a = i.vertexShader
          , o = i.fragmentShader;
        const l = function(t) {
            let e = "SHADOWMAP_TYPE_BASIC";
            return t.shadowMapType === bo ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === Mo ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === So && (e = "SHADOWMAP_TYPE_VSM"),
            e
        }(i)
          , c = function(t) {
            let e = "ENVMAP_TYPE_CUBE";
            if (t.envMap)
                switch (t.envMapMode) {
                case pl:
                case fl:
                    e = "ENVMAP_TYPE_CUBE";
                    break;
                case vl:
                case yl:
                    e = "ENVMAP_TYPE_CUBE_UV"
                }
            return e
        }(i)
          , h = function(t) {
            let e = "ENVMAP_MODE_REFLECTION";
            if (t.envMap)
                switch (t.envMapMode) {
                case fl:
                case yl:
                    e = "ENVMAP_MODE_REFRACTION"
                }
            return e
        }(i)
          , u = function(t) {
            let e = "ENVMAP_BLENDING_NONE";
            if (t.envMap)
                switch (t.combine) {
                case rl:
                    e = "ENVMAP_BLENDING_MULTIPLY";
                    break;
                case sl:
                    e = "ENVMAP_BLENDING_MIX";
                    break;
                case al:
                    e = "ENVMAP_BLENDING_ADD"
                }
            return e
        }(i)
          , d = t.gammaFactor > 0 ? t.gammaFactor : 1
          , p = i.isWebGL2 ? "" : function(t) {
            return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Lf).join("\n")
        }(i)
          , f = function(t) {
            const e = [];
            for (const i in t) {
                const n = t[i];
                !1 !== n && e.push("#define " + i + " " + n)
            }
            return e.join("\n")
        }(s)
          , m = r.createProgram();
        let g, v, y = i.glslVersion ? "#version " + i.glslVersion + "\n" : "";
        i.isRawShaderMaterial ? (g = [f].filter(Lf).join("\n"),
        g.length > 0 && (g += "\n"),
        v = [p, f].filter(Lf).join("\n"),
        v.length > 0 && (v += "\n")) : (g = [Bf(i), "#define SHADER_NAME " + i.shaderName, f, i.instancing ? "#define USE_INSTANCING" : "", i.instancingColor ? "#define USE_INSTANCING_COLOR" : "", i.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + d, "#define MAX_BONES " + i.maxBones, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + h : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMap && i.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i.normalMap && i.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.displacementMap && i.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.vertexTangents ? "#define USE_TANGENT" : "", i.vertexColors ? "#define USE_COLOR" : "", i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i.vertexUvs ? "#define USE_UV" : "", i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.skinning ? "#define USE_SKINNING" : "", i.useVertexTexture ? "#define BONE_TEXTURE" : "", i.morphTargets ? "#define USE_MORPHTARGETS" : "", i.morphNormals && !1 === i.flatShading ? "#define USE_MORPHNORMALS" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + l : "", i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Lf).join("\n"),
        v = [p, Bf(i), "#define SHADER_NAME " + i.shaderName, f, i.alphaTest ? "#define ALPHATEST " + i.alphaTest + (i.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + d, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.matcap ? "#define USE_MATCAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + c : "", i.envMap ? "#define " + h : "", i.envMap ? "#define " + u : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMap && i.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i.normalMap && i.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.sheen ? "#define USE_SHEEN" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.vertexTangents ? "#define USE_TANGENT" : "", i.vertexColors || i.instancingColor ? "#define USE_COLOR" : "", i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i.vertexUvs ? "#define USE_UV" : "", i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i.gradientMap ? "#define USE_GRADIENTMAP" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + l : "", i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", i.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (i.extensionShaderTextureLOD || i.envMap) && i.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", i.toneMapping !== ol ? "#define TONE_MAPPING" : "", i.toneMapping !== ol ? $d.tonemapping_pars_fragment : "", i.toneMapping !== ol ? Ef("toneMapping", i.toneMapping) : "", i.dithering ? "#define DITHERING" : "", $d.encodings_pars_fragment, i.map ? Sf("mapTexelToLinear", i.mapEncoding) : "", i.matcap ? Sf("matcapTexelToLinear", i.matcapEncoding) : "", i.envMap ? Sf("envMapTexelToLinear", i.envMapEncoding) : "", i.emissiveMap ? Sf("emissiveMapTexelToLinear", i.emissiveMapEncoding) : "", i.lightMap ? Sf("lightMapTexelToLinear", i.lightMapEncoding) : "", Tf("linearToOutputTexel", i.outputEncoding), i.depthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "", "\n"].filter(Lf).join("\n")),
        a = Rf(a),
        a = Af(a, i),
        a = Cf(a, i),
        o = Rf(o),
        o = Af(o, i),
        o = Cf(o, i),
        a = Of(a),
        o = Of(o),
        i.isWebGL2 && !0 !== i.isRawShaderMaterial && (y = "#version 300 es\n",
        g = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g,
        v = ["#define varying in", i.glslVersion === ah ? "" : "out highp vec4 pc_fragColor;", i.glslVersion === ah ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v);
        const x = y + v + o
          , _ = _f(r, 35633, y + g + a)
          , w = _f(r, 35632, x);
        if (r.attachShader(m, _),
        r.attachShader(m, w),
        void 0 !== i.index0AttributeName ? r.bindAttribLocation(m, 0, i.index0AttributeName) : !0 === i.morphTargets && r.bindAttribLocation(m, 0, "position"),
        r.linkProgram(m),
        t.debug.checkShaderErrors) {
            const t = r.getProgramInfoLog(m).trim()
              , e = r.getShaderInfoLog(_).trim()
              , i = r.getShaderInfoLog(w).trim();
            let n = !0
              , s = !0;
            if (!1 === r.getProgramParameter(m, 35714)) {
                n = !1;
                const e = Mf(r, _, "vertex")
                  , i = Mf(r, w, "fragment");
                console.error("THREE.WebGLProgram: shader error: ", r.getError(), "35715", r.getProgramParameter(m, 35715), "gl.getProgramInfoLog", t, e, i)
            } else
                "" !== t ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t) : "" !== e && "" !== i || (s = !1);
            s && (this.diagnostics = {
                runnable: n,
                programLog: t,
                vertexShader: {
                    log: e,
                    prefix: g
                },
                fragmentShader: {
                    log: i,
                    prefix: v
                }
            })
        }
        let b, M;
        return r.deleteShader(_),
        r.deleteShader(w),
        this.getUniforms = function() {
            return void 0 === b && (b = new xf(r,m)),
            b
        }
        ,
        this.getAttributes = function() {
            return void 0 === M && (M = function(t, e) {
                const i = {}
                  , n = t.getProgramParameter(e, 35721);
                for (let r = 0; r < n; r++) {
                    const n = t.getActiveAttrib(e, r).name;
                    i[n] = t.getAttribLocation(e, n)
                }
                return i
            }(r, m)),
            M
        }
        ,
        this.destroy = function() {
            n.releaseStatesOfProgram(this),
            r.deleteProgram(m),
            this.program = void 0
        }
        ,
        this.name = i.shaderName,
        this.id = wf++,
        this.cacheKey = e,
        this.usedTimes = 1,
        this.program = m,
        this.vertexShader = _,
        this.fragmentShader = w,
        this
    }
    function Hf(t, e, i, n, r, s) {
        const a = []
          , o = n.isWebGL2
          , l = n.logarithmicDepthBuffer
          , c = n.floatVertexTextures
          , h = n.maxVertexUniforms
          , u = n.vertexTextures;
        let d = n.precision;
        const p = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "toon",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite"
        }
          , f = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmissionMap"];
        function m(t) {
            let e;
            return t && t.isTexture ? e = t.encoding : t && t.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),
            e = t.texture.encoding) : e = jc,
            e
        }
        return {
            getParameters: function(r, a, f, g, v) {
                const y = g.fog
                  , x = r.isMeshStandardMaterial ? g.environment : null
                  , _ = e.get(r.envMap || x)
                  , w = p[r.type]
                  , b = v.isSkinnedMesh ? function(t) {
                    const e = t.skeleton.bones;
                    if (c)
                        return 1024;
                    {
                        const t = h
                          , i = Math.floor((t - 20) / 4)
                          , n = Math.min(i, e.length);
                        return n < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + n + "."),
                        0) : n
                    }
                }(v) : 0;
                let M, S;
                if (null !== r.precision && (d = n.getMaxPrecision(r.precision),
                d !== r.precision && console.warn("THREE.WebGLProgram.getParameters:", r.precision, "not supported, using", d, "instead.")),
                w) {
                    const t = tp[w];
                    M = t.vertexShader,
                    S = t.fragmentShader
                } else
                    M = r.vertexShader,
                    S = r.fragmentShader;
                const T = t.getRenderTarget();
                return {
                    isWebGL2: o,
                    shaderID: w,
                    shaderName: r.type,
                    vertexShader: M,
                    fragmentShader: S,
                    defines: r.defines,
                    isRawShaderMaterial: !0 === r.isRawShaderMaterial,
                    glslVersion: r.glslVersion,
                    precision: d,
                    instancing: !0 === v.isInstancedMesh,
                    instancingColor: !0 === v.isInstancedMesh && null !== v.instanceColor,
                    supportsVertexTextures: u,
                    outputEncoding: null !== T ? m(T.texture) : t.outputEncoding,
                    map: !!r.map,
                    mapEncoding: m(r.map),
                    matcap: !!r.matcap,
                    matcapEncoding: m(r.matcap),
                    envMap: !!_,
                    envMapMode: _ && _.mapping,
                    envMapEncoding: m(_),
                    envMapCubeUV: !!_ && (_.mapping === vl || _.mapping === yl),
                    lightMap: !!r.lightMap,
                    lightMapEncoding: m(r.lightMap),
                    aoMap: !!r.aoMap,
                    emissiveMap: !!r.emissiveMap,
                    emissiveMapEncoding: m(r.emissiveMap),
                    bumpMap: !!r.bumpMap,
                    normalMap: !!r.normalMap,
                    objectSpaceNormalMap: r.normalMapType === ih,
                    tangentSpaceNormalMap: r.normalMapType === eh,
                    clearcoatMap: !!r.clearcoatMap,
                    clearcoatRoughnessMap: !!r.clearcoatRoughnessMap,
                    clearcoatNormalMap: !!r.clearcoatNormalMap,
                    displacementMap: !!r.displacementMap,
                    roughnessMap: !!r.roughnessMap,
                    metalnessMap: !!r.metalnessMap,
                    specularMap: !!r.specularMap,
                    alphaMap: !!r.alphaMap,
                    gradientMap: !!r.gradientMap,
                    sheen: !!r.sheen,
                    transmissionMap: !!r.transmissionMap,
                    combine: r.combine,
                    vertexTangents: r.normalMap && r.vertexTangents,
                    vertexColors: r.vertexColors,
                    vertexAlphas: !0 === r.vertexColors && v.geometry && v.geometry.attributes.color && 4 === v.geometry.attributes.color.itemSize,
                    vertexUvs: !!(r.map || r.bumpMap || r.normalMap || r.specularMap || r.alphaMap || r.emissiveMap || r.roughnessMap || r.metalnessMap || r.clearcoatMap || r.clearcoatRoughnessMap || r.clearcoatNormalMap || r.displacementMap || r.transmissionMap),
                    uvsVertexOnly: !(r.map || r.bumpMap || r.normalMap || r.specularMap || r.alphaMap || r.emissiveMap || r.roughnessMap || r.metalnessMap || r.clearcoatNormalMap || r.transmissionMap || !r.displacementMap),
                    fog: !!y,
                    useFog: r.fog,
                    fogExp2: y && y.isFogExp2,
                    flatShading: !!r.flatShading,
                    sizeAttenuation: r.sizeAttenuation,
                    logarithmicDepthBuffer: l,
                    skinning: r.skinning && b > 0,
                    maxBones: b,
                    useVertexTexture: c,
                    morphTargets: r.morphTargets,
                    morphNormals: r.morphNormals,
                    numDirLights: a.directional.length,
                    numPointLights: a.point.length,
                    numSpotLights: a.spot.length,
                    numRectAreaLights: a.rectArea.length,
                    numHemiLights: a.hemi.length,
                    numDirLightShadows: a.directionalShadowMap.length,
                    numPointLightShadows: a.pointShadowMap.length,
                    numSpotLightShadows: a.spotShadowMap.length,
                    numClippingPlanes: s.numPlanes,
                    numClipIntersection: s.numIntersection,
                    dithering: r.dithering,
                    shadowMapEnabled: t.shadowMap.enabled && f.length > 0,
                    shadowMapType: t.shadowMap.type,
                    toneMapping: r.toneMapped ? t.toneMapping : ol,
                    physicallyCorrectLights: t.physicallyCorrectLights,
                    premultipliedAlpha: r.premultipliedAlpha,
                    alphaTest: r.alphaTest,
                    doubleSided: r.side === Lo,
                    flipSided: r.side === Eo,
                    depthPacking: void 0 !== r.depthPacking && r.depthPacking,
                    index0AttributeName: r.index0AttributeName,
                    extensionDerivatives: r.extensions && r.extensions.derivatives,
                    extensionFragDepth: r.extensions && r.extensions.fragDepth,
                    extensionDrawBuffers: r.extensions && r.extensions.drawBuffers,
                    extensionShaderTextureLOD: r.extensions && r.extensions.shaderTextureLOD,
                    rendererExtensionFragDepth: o || i.has("EXT_frag_depth"),
                    rendererExtensionDrawBuffers: o || i.has("WEBGL_draw_buffers"),
                    rendererExtensionShaderTextureLod: o || i.has("EXT_shader_texture_lod"),
                    customProgramCacheKey: r.customProgramCacheKey()
                }
            },
            getProgramCacheKey: function(e) {
                const i = [];
                if (e.shaderID ? i.push(e.shaderID) : (i.push(e.fragmentShader),
                i.push(e.vertexShader)),
                void 0 !== e.defines)
                    for (const t in e.defines)
                        i.push(t),
                        i.push(e.defines[t]);
                if (!1 === e.isRawShaderMaterial) {
                    for (let t = 0; t < f.length; t++)
                        i.push(e[f[t]]);
                    i.push(t.outputEncoding),
                    i.push(t.gammaFactor)
                }
                return i.push(e.customProgramCacheKey),
                i.join()
            },
            getUniforms: function(t) {
                const e = p[t.type];
                let i;
                if (e) {
                    const t = tp[e];
                    i = kd.clone(t.uniforms)
                } else
                    i = t.uniforms;
                return i
            },
            acquireProgram: function(e, i) {
                let n;
                for (let t = 0, e = a.length; t < e; t++) {
                    const e = a[t];
                    if (e.cacheKey === i) {
                        n = e,
                        ++n.usedTimes;
                        break
                    }
                }
                return void 0 === n && (n = new Ff(t,i,e,r),
                a.push(n)),
                n
            },
            releaseProgram: function(t) {
                if (0 == --t.usedTimes) {
                    const e = a.indexOf(t);
                    a[e] = a[a.length - 1],
                    a.pop(),
                    t.destroy()
                }
            },
            programs: a
        }
    }
    function Uf() {
        let t = new WeakMap;
        return {
            get: function(e) {
                let i = t.get(e);
                return void 0 === i && (i = {},
                t.set(e, i)),
                i
            },
            remove: function(e) {
                t.delete(e)
            },
            update: function(e, i, n) {
                t.get(e)[i] = n
            },
            dispose: function() {
                t = new WeakMap
            }
        }
    }
    function Gf(t, e) {
        return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
    }
    function Vf(t, e) {
        return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
    }
    function Wf(t) {
        const e = [];
        let i = 0;
        const n = []
          , r = []
          , s = {
            id: -1
        };
        function a(n, r, a, o, l, c) {
            let h = e[i];
            const u = t.get(a);
            return void 0 === h ? (h = {
                id: n.id,
                object: n,
                geometry: r,
                material: a,
                program: u.program || s,
                groupOrder: o,
                renderOrder: n.renderOrder,
                z: l,
                group: c
            },
            e[i] = h) : (h.id = n.id,
            h.object = n,
            h.geometry = r,
            h.material = a,
            h.program = u.program || s,
            h.groupOrder = o,
            h.renderOrder = n.renderOrder,
            h.z = l,
            h.group = c),
            i++,
            h
        }
        return {
            opaque: n,
            transparent: r,
            init: function() {
                i = 0,
                n.length = 0,
                r.length = 0
            },
            push: function(t, e, i, s, o, l) {
                const c = a(t, e, i, s, o, l);
                (!0 === i.transparent ? r : n).push(c)
            },
            unshift: function(t, e, i, s, o, l) {
                const c = a(t, e, i, s, o, l);
                (!0 === i.transparent ? r : n).unshift(c)
            },
            finish: function() {
                for (let t = i, n = e.length; t < n; t++) {
                    const i = e[t];
                    if (null === i.id)
                        break;
                    i.id = null,
                    i.object = null,
                    i.geometry = null,
                    i.material = null,
                    i.program = null,
                    i.group = null
                }
            },
            sort: function(t, e) {
                n.length > 1 && n.sort(t || Gf),
                r.length > 1 && r.sort(e || Vf)
            }
        }
    }
    function qf(t) {
        let e = new WeakMap;
        return {
            get: function(i, n) {
                let r;
                return !1 === e.has(i) ? (r = new Wf(t),
                e.set(i, [r])) : n >= e.get(i).length ? (r = new Wf(t),
                e.get(i).push(r)) : r = e.get(i)[n],
                r
            },
            dispose: function() {
                e = new WeakMap
            }
        }
    }
    function jf() {
        const t = {};
        return {
            get: function(e) {
                if (void 0 !== t[e.id])
                    return t[e.id];
                let i;
                switch (e.type) {
                case "DirectionalLight":
                    i = {
                        direction: new Eh,
                        color: new $u
                    };
                    break;
                case "SpotLight":
                    i = {
                        position: new Eh,
                        direction: new Eh,
                        color: new $u,
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0
                    };
                    break;
                case "PointLight":
                    i = {
                        position: new Eh,
                        color: new $u,
                        distance: 0,
                        decay: 0
                    };
                    break;
                case "HemisphereLight":
                    i = {
                        direction: new Eh,
                        skyColor: new $u,
                        groundColor: new $u
                    };
                    break;
                case "RectAreaLight":
                    i = {
                        color: new $u,
                        position: new Eh,
                        halfWidth: new Eh,
                        halfHeight: new Eh
                    }
                }
                return t[e.id] = i,
                i
            }
        }
    }
    let Yf = 0;
    function Xf(t, e) {
        return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
    }
    function Jf(t, e) {
        const i = new jf
          , n = function() {
            const t = {};
            return {
                get: function(e) {
                    if (void 0 !== t[e.id])
                        return t[e.id];
                    let i;
                    switch (e.type) {
                    case "DirectionalLight":
                    case "SpotLight":
                        i = {
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new gh
                        };
                        break;
                    case "PointLight":
                        i = {
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new gh,
                            shadowCameraNear: 1,
                            shadowCameraFar: 1e3
                        }
                    }
                    return t[e.id] = i,
                    i
                }
            }
        }()
          , r = {
            version: 0,
            hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadow: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: []
        };
        for (let t = 0; t < 9; t++)
            r.probe.push(new Eh);
        const s = new Eh
          , a = new nu
          , o = new nu;
        return {
            setup: function(s) {
                let a = 0
                  , o = 0
                  , l = 0;
                for (let t = 0; t < 9; t++)
                    r.probe[t].set(0, 0, 0);
                let c = 0
                  , h = 0
                  , u = 0
                  , d = 0
                  , p = 0
                  , f = 0
                  , m = 0
                  , g = 0;
                s.sort(Xf);
                for (let t = 0, e = s.length; t < e; t++) {
                    const e = s[t]
                      , v = e.color
                      , y = e.intensity
                      , x = e.distance
                      , _ = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                    if (e.isAmbientLight)
                        a += v.r * y,
                        o += v.g * y,
                        l += v.b * y;
                    else if (e.isLightProbe)
                        for (let t = 0; t < 9; t++)
                            r.probe[t].addScaledVector(e.sh.coefficients[t], y);
                    else if (e.isDirectionalLight) {
                        const t = i.get(e);
                        if (t.color.copy(e.color).multiplyScalar(e.intensity),
                        e.castShadow) {
                            const t = e.shadow
                              , i = n.get(e);
                            i.shadowBias = t.bias,
                            i.shadowNormalBias = t.normalBias,
                            i.shadowRadius = t.radius,
                            i.shadowMapSize = t.mapSize,
                            r.directionalShadow[c] = i,
                            r.directionalShadowMap[c] = _,
                            r.directionalShadowMatrix[c] = e.shadow.matrix,
                            f++
                        }
                        r.directional[c] = t,
                        c++
                    } else if (e.isSpotLight) {
                        const t = i.get(e);
                        if (t.position.setFromMatrixPosition(e.matrixWorld),
                        t.color.copy(v).multiplyScalar(y),
                        t.distance = x,
                        t.coneCos = Math.cos(e.angle),
                        t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)),
                        t.decay = e.decay,
                        e.castShadow) {
                            const t = e.shadow
                              , i = n.get(e);
                            i.shadowBias = t.bias,
                            i.shadowNormalBias = t.normalBias,
                            i.shadowRadius = t.radius,
                            i.shadowMapSize = t.mapSize,
                            r.spotShadow[u] = i,
                            r.spotShadowMap[u] = _,
                            r.spotShadowMatrix[u] = e.shadow.matrix,
                            g++
                        }
                        r.spot[u] = t,
                        u++
                    } else if (e.isRectAreaLight) {
                        const t = i.get(e);
                        t.color.copy(v).multiplyScalar(y),
                        t.halfWidth.set(.5 * e.width, 0, 0),
                        t.halfHeight.set(0, .5 * e.height, 0),
                        r.rectArea[d] = t,
                        d++
                    } else if (e.isPointLight) {
                        const t = i.get(e);
                        if (t.color.copy(e.color).multiplyScalar(e.intensity),
                        t.distance = e.distance,
                        t.decay = e.decay,
                        e.castShadow) {
                            const t = e.shadow
                              , i = n.get(e);
                            i.shadowBias = t.bias,
                            i.shadowNormalBias = t.normalBias,
                            i.shadowRadius = t.radius,
                            i.shadowMapSize = t.mapSize,
                            i.shadowCameraNear = t.camera.near,
                            i.shadowCameraFar = t.camera.far,
                            r.pointShadow[h] = i,
                            r.pointShadowMap[h] = _,
                            r.pointShadowMatrix[h] = e.shadow.matrix,
                            m++
                        }
                        r.point[h] = t,
                        h++
                    } else if (e.isHemisphereLight) {
                        const t = i.get(e);
                        t.skyColor.copy(e.color).multiplyScalar(y),
                        t.groundColor.copy(e.groundColor).multiplyScalar(y),
                        r.hemi[p] = t,
                        p++
                    }
                }
                d > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = Kd.LTC_FLOAT_1,
                r.rectAreaLTC2 = Kd.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = Kd.LTC_HALF_1,
                r.rectAreaLTC2 = Kd.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
                r.ambient[0] = a,
                r.ambient[1] = o,
                r.ambient[2] = l;
                const v = r.hash;
                v.directionalLength === c && v.pointLength === h && v.spotLength === u && v.rectAreaLength === d && v.hemiLength === p && v.numDirectionalShadows === f && v.numPointShadows === m && v.numSpotShadows === g || (r.directional.length = c,
                r.spot.length = u,
                r.rectArea.length = d,
                r.point.length = h,
                r.hemi.length = p,
                r.directionalShadow.length = f,
                r.directionalShadowMap.length = f,
                r.pointShadow.length = m,
                r.pointShadowMap.length = m,
                r.spotShadow.length = g,
                r.spotShadowMap.length = g,
                r.directionalShadowMatrix.length = f,
                r.pointShadowMatrix.length = m,
                r.spotShadowMatrix.length = g,
                v.directionalLength = c,
                v.pointLength = h,
                v.spotLength = u,
                v.rectAreaLength = d,
                v.hemiLength = p,
                v.numDirectionalShadows = f,
                v.numPointShadows = m,
                v.numSpotShadows = g,
                r.version = Yf++)
            },
            setupView: function(t, e) {
                let i = 0
                  , n = 0
                  , l = 0
                  , c = 0
                  , h = 0;
                const u = e.matrixWorldInverse;
                for (let e = 0, d = t.length; e < d; e++) {
                    const d = t[e];
                    if (d.isDirectionalLight) {
                        const t = r.directional[i];
                        t.direction.setFromMatrixPosition(d.matrixWorld),
                        s.setFromMatrixPosition(d.target.matrixWorld),
                        t.direction.sub(s),
                        t.direction.transformDirection(u),
                        i++
                    } else if (d.isSpotLight) {
                        const t = r.spot[l];
                        t.position.setFromMatrixPosition(d.matrixWorld),
                        t.position.applyMatrix4(u),
                        t.direction.setFromMatrixPosition(d.matrixWorld),
                        s.setFromMatrixPosition(d.target.matrixWorld),
                        t.direction.sub(s),
                        t.direction.transformDirection(u),
                        l++
                    } else if (d.isRectAreaLight) {
                        const t = r.rectArea[c];
                        t.position.setFromMatrixPosition(d.matrixWorld),
                        t.position.applyMatrix4(u),
                        o.identity(),
                        a.copy(d.matrixWorld),
                        a.premultiply(u),
                        o.extractRotation(a),
                        t.halfWidth.set(.5 * d.width, 0, 0),
                        t.halfHeight.set(0, .5 * d.height, 0),
                        t.halfWidth.applyMatrix4(o),
                        t.halfHeight.applyMatrix4(o),
                        c++
                    } else if (d.isPointLight) {
                        const t = r.point[n];
                        t.position.setFromMatrixPosition(d.matrixWorld),
                        t.position.applyMatrix4(u),
                        n++
                    } else if (d.isHemisphereLight) {
                        const t = r.hemi[h];
                        t.direction.setFromMatrixPosition(d.matrixWorld),
                        t.direction.transformDirection(u),
                        t.direction.normalize(),
                        h++
                    }
                }
            },
            state: r
        }
    }
    function Zf(t, e) {
        const i = new Jf(t,e)
          , n = []
          , r = [];
        return {
            init: function() {
                n.length = 0,
                r.length = 0
            },
            state: {
                lightsArray: n,
                shadowsArray: r,
                lights: i
            },
            setupLights: function() {
                i.setup(n)
            },
            setupLightsView: function(t) {
                i.setupView(n, t)
            },
            pushLight: function(t) {
                n.push(t)
            },
            pushShadow: function(t) {
                r.push(t)
            }
        }
    }
    function Qf(t, e) {
        let i = new WeakMap;
        return {
            get: function(n, r=0) {
                let s;
                return !1 === i.has(n) ? (s = new Zf(t,e),
                i.set(n, [s])) : r >= i.get(n).length ? (s = new Zf(t,e),
                i.get(n).push(s)) : s = i.get(n)[r],
                s
            },
            dispose: function() {
                i = new WeakMap
            }
        }
    }
    class $f extends qu {
        constructor(t) {
            super(),
            this.type = "MeshDepthMaterial",
            this.depthPacking = 3200,
            this.skinning = !1,
            this.morphTargets = !1,
            this.map = null,
            this.alphaMap = null,
            this.displacementMap = null,
            this.displacementScale = 1,
            this.displacementBias = 0,
            this.wireframe = !1,
            this.wireframeLinewidth = 1,
            this.fog = !1,
            this.setValues(t)
        }
        copy(t) {
            return super.copy(t),
            this.depthPacking = t.depthPacking,
            this.skinning = t.skinning,
            this.morphTargets = t.morphTargets,
            this.map = t.map,
            this.alphaMap = t.alphaMap,
            this.displacementMap = t.displacementMap,
            this.displacementScale = t.displacementScale,
            this.displacementBias = t.displacementBias,
            this.wireframe = t.wireframe,
            this.wireframeLinewidth = t.wireframeLinewidth,
            this
        }
    }
    $f.prototype.isMeshDepthMaterial = !0;
    class Kf extends qu {
        constructor(t) {
            super(),
            this.type = "MeshDistanceMaterial",
            this.referencePosition = new Eh,
            this.nearDistance = 1,
            this.farDistance = 1e3,
            this.skinning = !1,
            this.morphTargets = !1,
            this.map = null,
            this.alphaMap = null,
            this.displacementMap = null,
            this.displacementScale = 1,
            this.displacementBias = 0,
            this.fog = !1,
            this.setValues(t)
        }
        copy(t) {
            return super.copy(t),
            this.referencePosition.copy(t.referencePosition),
            this.nearDistance = t.nearDistance,
            this.farDistance = t.farDistance,
            this.skinning = t.skinning,
            this.morphTargets = t.morphTargets,
            this.map = t.map,
            this.alphaMap = t.alphaMap,
            this.displacementMap = t.displacementMap,
            this.displacementScale = t.displacementScale,
            this.displacementBias = t.displacementBias,
            this
        }
    }
    Kf.prototype.isMeshDistanceMaterial = !0;
    var tm = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
      , em = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";
    function im(t, e, i) {
        let n = new Xd;
        const r = new gh
          , s = new gh
          , a = new Mh
          , o = []
          , l = []
          , c = {}
          , h = i.maxTextureSize
          , u = {
            0: Eo,
            1: To,
            2: Lo
        }
          , d = new Bd({
            defines: {
                SAMPLE_RATE: 2 / 8,
                HALF_SAMPLE_RATE: 1 / 8
            },
            uniforms: {
                shadow_pass: {
                    value: null
                },
                resolution: {
                    value: new gh
                },
                radius: {
                    value: 4
                }
            },
            vertexShader: em,
            fragmentShader: tm
        })
          , p = d.clone();
        p.defines.HORIZONTAL_PASS = 1;
        const f = new fd;
        f.setAttribute("position", new id(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
        const m = new Id(f,d)
          , g = this;
        function v(i, n) {
            const r = e.update(m);
            d.uniforms.shadow_pass.value = i.map.texture,
            d.uniforms.resolution.value = i.mapSize,
            d.uniforms.radius.value = i.radius,
            t.setRenderTarget(i.mapPass),
            t.clear(),
            t.renderBufferDirect(n, null, r, d, m, null),
            p.uniforms.shadow_pass.value = i.mapPass.texture,
            p.uniforms.resolution.value = i.mapSize,
            p.uniforms.radius.value = i.radius,
            t.setRenderTarget(i.map),
            t.clear(),
            t.renderBufferDirect(n, null, r, p, m, null)
        }
        function y(t, e, i) {
            const n = t | e << 1 | i << 2;
            let r = o[n];
            return void 0 === r && (r = new $f({
                depthPacking: th,
                morphTargets: t,
                skinning: e
            }),
            o[n] = r),
            r
        }
        function x(t, e, i) {
            const n = t | e << 1 | i << 2;
            let r = l[n];
            return void 0 === r && (r = new Kf({
                morphTargets: t,
                skinning: e
            }),
            l[n] = r),
            r
        }
        function _(e, i, n, r, s, a, o) {
            let l = null
              , h = y
              , d = e.customDepthMaterial;
            if (!0 === r.isPointLight && (h = x,
            d = e.customDistanceMaterial),
            void 0 === d) {
                let t = !1;
                !0 === n.morphTargets && (t = i.morphAttributes && i.morphAttributes.position && i.morphAttributes.position.length > 0);
                let r = !1;
                !0 === e.isSkinnedMesh && (!0 === n.skinning ? r = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e));
                l = h(t, r, !0 === e.isInstancedMesh)
            } else
                l = d;
            if (t.localClippingEnabled && !0 === n.clipShadows && 0 !== n.clippingPlanes.length) {
                const t = l.uuid
                  , e = n.uuid;
                let i = c[t];
                void 0 === i && (i = {},
                c[t] = i);
                let r = i[e];
                void 0 === r && (r = l.clone(),
                i[e] = r),
                l = r
            }
            return l.visible = n.visible,
            l.wireframe = n.wireframe,
            l.side = o === So ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : u[n.side],
            l.clipShadows = n.clipShadows,
            l.clippingPlanes = n.clippingPlanes,
            l.clipIntersection = n.clipIntersection,
            l.wireframeLinewidth = n.wireframeLinewidth,
            l.linewidth = n.linewidth,
            !0 === r.isPointLight && !0 === l.isMeshDistanceMaterial && (l.referencePosition.setFromMatrixPosition(r.matrixWorld),
            l.nearDistance = s,
            l.farDistance = a),
            l
        }
        function w(i, r, s, a, o) {
            if (!1 === i.visible)
                return;
            if (i.layers.test(r.layers) && (i.isMesh || i.isLine || i.isPoints) && (i.castShadow || i.receiveShadow && o === So) && (!i.frustumCulled || n.intersectsObject(i))) {
                i.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, i.matrixWorld);
                const n = e.update(i)
                  , r = i.material;
                if (Array.isArray(r)) {
                    const e = n.groups;
                    for (let l = 0, c = e.length; l < c; l++) {
                        const c = e[l]
                          , h = r[c.materialIndex];
                        if (h && h.visible) {
                            const e = _(i, n, h, a, s.near, s.far, o);
                            t.renderBufferDirect(s, null, n, e, i, c)
                        }
                    }
                } else if (r.visible) {
                    const e = _(i, n, r, a, s.near, s.far, o);
                    t.renderBufferDirect(s, null, n, e, i, null)
                }
            }
            const l = i.children;
            for (let t = 0, e = l.length; t < e; t++)
                w(l[t], r, s, a, o)
        }
        this.enabled = !1,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this.type = bo,
        this.render = function(e, i, o) {
            if (!1 === g.enabled)
                return;
            if (!1 === g.autoUpdate && !1 === g.needsUpdate)
                return;
            if (0 === e.length)
                return;
            const l = t.getRenderTarget()
              , c = t.getActiveCubeFace()
              , u = t.getActiveMipmapLevel()
              , d = t.state;
            d.setBlending(Ao),
            d.buffers.color.setClear(1, 1, 1, 1),
            d.buffers.depth.setTest(!0),
            d.setScissorTest(!1);
            for (let l = 0, c = e.length; l < c; l++) {
                const c = e[l]
                  , u = c.shadow;
                if (void 0 === u) {
                    console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
                    continue
                }
                if (!1 === u.autoUpdate && !1 === u.needsUpdate)
                    continue;
                r.copy(u.mapSize);
                const p = u.getFrameExtents();
                if (r.multiply(p),
                s.copy(u.mapSize),
                (r.x > h || r.y > h) && (r.x > h && (s.x = Math.floor(h / p.x),
                r.x = s.x * p.x,
                u.mapSize.x = s.x),
                r.y > h && (s.y = Math.floor(h / p.y),
                r.y = s.y * p.y,
                u.mapSize.y = s.y)),
                null === u.map && !u.isPointLightShadow && this.type === So) {
                    const t = {
                        minFilter: Tl,
                        magFilter: Tl,
                        format: Gl
                    };
                    u.map = new Sh(r.x,r.y,t),
                    u.map.texture.name = c.name + ".shadowMap",
                    u.mapPass = new Sh(r.x,r.y,t),
                    u.camera.updateProjectionMatrix()
                }
                if (null === u.map) {
                    const t = {
                        minFilter: bl,
                        magFilter: bl,
                        format: Gl
                    };
                    u.map = new Sh(r.x,r.y,t),
                    u.map.texture.name = c.name + ".shadowMap",
                    u.camera.updateProjectionMatrix()
                }
                t.setRenderTarget(u.map),
                t.clear();
                const f = u.getViewportCount();
                for (let t = 0; t < f; t++) {
                    const e = u.getViewport(t);
                    a.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w),
                    d.viewport(a),
                    u.updateMatrices(c, t),
                    n = u.getFrustum(),
                    w(i, o, u.camera, c, this.type)
                }
                u.isPointLightShadow || this.type !== So || v(u, o),
                u.needsUpdate = !1
            }
            g.needsUpdate = !1,
            t.setRenderTarget(l, c, u)
        }
    }
    function nm(t, e, i) {
        const n = i.isWebGL2;
        const r = new function() {
            let e = !1;
            const i = new Mh;
            let n = null;
            const r = new Mh(0,0,0,0);
            return {
                setMask: function(i) {
                    n === i || e || (t.colorMask(i, i, i, i),
                    n = i)
                },
                setLocked: function(t) {
                    e = t
                },
                setClear: function(e, n, s, a, o) {
                    !0 === o && (e *= a,
                    n *= a,
                    s *= a),
                    i.set(e, n, s, a),
                    !1 === r.equals(i) && (t.clearColor(e, n, s, a),
                    r.copy(i))
                },
                reset: function() {
                    e = !1,
                    n = null,
                    r.set(-1, 0, 0, 0)
                }
            }
        }
          , s = new function() {
            let e = !1
              , i = null
              , n = null
              , r = null;
            return {
                setTest: function(t) {
                    t ? O(2929) : z(2929)
                },
                setMask: function(n) {
                    i === n || e || (t.depthMask(n),
                    i = n)
                },
                setFunc: function(e) {
                    if (n !== e) {
                        if (e)
                            switch (e) {
                            case Zo:
                                t.depthFunc(512);
                                break;
                            case Qo:
                                t.depthFunc(519);
                                break;
                            case $o:
                                t.depthFunc(513);
                                break;
                            case Ko:
                                t.depthFunc(515);
                                break;
                            case tl:
                                t.depthFunc(514);
                                break;
                            case el:
                                t.depthFunc(518);
                                break;
                            case il:
                                t.depthFunc(516);
                                break;
                            case nl:
                                t.depthFunc(517);
                                break;
                            default:
                                t.depthFunc(515)
                            }
                        else
                            t.depthFunc(515);
                        n = e
                    }
                },
                setLocked: function(t) {
                    e = t
                },
                setClear: function(e) {
                    r !== e && (t.clearDepth(e),
                    r = e)
                },
                reset: function() {
                    e = !1,
                    i = null,
                    n = null,
                    r = null
                }
            }
        }
          , a = new function() {
            let e = !1
              , i = null
              , n = null
              , r = null
              , s = null
              , a = null
              , o = null
              , l = null
              , c = null;
            return {
                setTest: function(t) {
                    e || (t ? O(2960) : z(2960))
                },
                setMask: function(n) {
                    i === n || e || (t.stencilMask(n),
                    i = n)
                },
                setFunc: function(e, i, a) {
                    n === e && r === i && s === a || (t.stencilFunc(e, i, a),
                    n = e,
                    r = i,
                    s = a)
                },
                setOp: function(e, i, n) {
                    a === e && o === i && l === n || (t.stencilOp(e, i, n),
                    a = e,
                    o = i,
                    l = n)
                },
                setLocked: function(t) {
                    e = t
                },
                setClear: function(e) {
                    c !== e && (t.clearStencil(e),
                    c = e)
                },
                reset: function() {
                    e = !1,
                    i = null,
                    n = null,
                    r = null,
                    s = null,
                    a = null,
                    o = null,
                    l = null,
                    c = null
                }
            }
        }
        ;
        let o = {}
          , l = null
          , c = {}
          , h = null
          , u = !1
          , d = null
          , p = null
          , f = null
          , m = null
          , g = null
          , v = null
          , y = null
          , x = !1
          , _ = null
          , w = null
          , b = null
          , M = null
          , S = null;
        const T = t.getParameter(35661);
        let E = !1
          , L = 0;
        const A = t.getParameter(7938);
        -1 !== A.indexOf("WebGL") ? (L = parseFloat(/^WebGL (\d)/.exec(A)[1]),
        E = L >= 1) : -1 !== A.indexOf("OpenGL ES") && (L = parseFloat(/^OpenGL ES (\d)/.exec(A)[1]),
        E = L >= 2);
        let C = null
          , P = {};
        const R = new Mh(0,0,t.canvas.width,t.canvas.height)
          , I = new Mh(0,0,t.canvas.width,t.canvas.height);
        function D(e, i, n) {
            const r = new Uint8Array(4)
              , s = t.createTexture();
            t.bindTexture(e, s),
            t.texParameteri(e, 10241, 9728),
            t.texParameteri(e, 10240, 9728);
            for (let e = 0; e < n; e++)
                t.texImage2D(i + e, 0, 6408, 1, 1, 0, 6408, 5121, r);
            return s
        }
        const N = {};
        function O(e) {
            !0 !== o[e] && (t.enable(e),
            o[e] = !0)
        }
        function z(e) {
            !1 !== o[e] && (t.disable(e),
            o[e] = !1)
        }
        N[3553] = D(3553, 3553, 1),
        N[34067] = D(34067, 34069, 6),
        r.setClear(0, 0, 0, 1),
        s.setClear(1),
        a.setClear(0),
        O(2929),
        s.setFunc(Ko),
        H(!1),
        U(_o),
        O(2884),
        F(Ao);
        const k = {
            [No]: 32774,
            [Oo]: 32778,
            [zo]: 32779
        };
        if (n)
            k[ko] = 32775,
            k[Bo] = 32776;
        else {
            const t = e.get("EXT_blend_minmax");
            null !== t && (k[ko] = t.MIN_EXT,
            k[Bo] = t.MAX_EXT)
        }
        const B = {
            [Fo]: 0,
            [Ho]: 1,
            [Uo]: 768,
            [Vo]: 770,
            [Jo]: 776,
            [Yo]: 774,
            [qo]: 772,
            [Go]: 769,
            [Wo]: 771,
            [Xo]: 775,
            [jo]: 773
        };
        function F(e, i, n, r, s, a, o, l) {
            if (e !== Ao) {
                if (!1 === u && (O(3042),
                u = !0),
                e === Do)
                    s = s || i,
                    a = a || n,
                    o = o || r,
                    i === p && s === g || (t.blendEquationSeparate(k[i], k[s]),
                    p = i,
                    g = s),
                    n === f && r === m && a === v && o === y || (t.blendFuncSeparate(B[n], B[r], B[a], B[o]),
                    f = n,
                    m = r,
                    v = a,
                    y = o),
                    d = e,
                    x = null;
                else if (e !== d || l !== x) {
                    if (p === No && g === No || (t.blendEquation(32774),
                    p = No,
                    g = No),
                    l)
                        switch (e) {
                        case Co:
                            t.blendFuncSeparate(1, 771, 1, 771);
                            break;
                        case Po:
                            t.blendFunc(1, 1);
                            break;
                        case Ro:
                            t.blendFuncSeparate(0, 0, 769, 771);
                            break;
                        case Io:
                            t.blendFuncSeparate(0, 768, 0, 770);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", e)
                        }
                    else
                        switch (e) {
                        case Co:
                            t.blendFuncSeparate(770, 771, 1, 771);
                            break;
                        case Po:
                            t.blendFunc(770, 1);
                            break;
                        case Ro:
                            t.blendFunc(0, 769);
                            break;
                        case Io:
                            t.blendFunc(0, 768);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", e)
                        }
                    f = null,
                    m = null,
                    v = null,
                    y = null,
                    d = e,
                    x = l
                }
            } else
                !0 === u && (z(3042),
                u = !1)
        }
        function H(e) {
            _ !== e && (e ? t.frontFace(2304) : t.frontFace(2305),
            _ = e)
        }
        function U(e) {
            e !== xo ? (O(2884),
            e !== w && (e === _o ? t.cullFace(1029) : e === wo ? t.cullFace(1028) : t.cullFace(1032))) : z(2884),
            w = e
        }
        function G(e, i, n) {
            e ? (O(32823),
            M === i && S === n || (t.polygonOffset(i, n),
            M = i,
            S = n)) : z(32823)
        }
        function V(e) {
            void 0 === e && (e = 33984 + T - 1),
            C !== e && (t.activeTexture(e),
            C = e)
        }
        return {
            buffers: {
                color: r,
                depth: s,
                stencil: a
            },
            enable: O,
            disable: z,
            bindFramebuffer: function(e, i) {
                null === i && null !== l && (i = l),
                c[e] !== i && (t.bindFramebuffer(e, i),
                c[e] = i,
                n && (36009 === e && (c[36160] = i),
                36160 === e && (c[36009] = i)))
            },
            bindXRFramebuffer: function(e) {
                e !== l && (t.bindFramebuffer(36160, e),
                l = e)
            },
            useProgram: function(e) {
                return h !== e && (t.useProgram(e),
                h = e,
                !0)
            },
            setBlending: F,
            setMaterial: function(t, e) {
                t.side === Lo ? z(2884) : O(2884);
                let i = t.side === Eo;
                e && (i = !i),
                H(i),
                t.blending === Co && !1 === t.transparent ? F(Ao) : F(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha),
                s.setFunc(t.depthFunc),
                s.setTest(t.depthTest),
                s.setMask(t.depthWrite),
                r.setMask(t.colorWrite);
                const n = t.stencilWrite;
                a.setTest(n),
                n && (a.setMask(t.stencilWriteMask),
                a.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
                a.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
                G(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits),
                !0 === t.alphaToCoverage ? O(32926) : z(32926)
            },
            setFlipSided: H,
            setCullFace: U,
            setLineWidth: function(e) {
                e !== b && (E && t.lineWidth(e),
                b = e)
            },
            setPolygonOffset: G,
            setScissorTest: function(t) {
                t ? O(3089) : z(3089)
            },
            activeTexture: V,
            bindTexture: function(e, i) {
                null === C && V();
                let n = P[C];
                void 0 === n && (n = {
                    type: void 0,
                    texture: void 0
                },
                P[C] = n),
                n.type === e && n.texture === i || (t.bindTexture(e, i || N[e]),
                n.type = e,
                n.texture = i)
            },
            unbindTexture: function() {
                const e = P[C];
                void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null),
                e.type = void 0,
                e.texture = void 0)
            },
            compressedTexImage2D: function() {
                try {
                    t.compressedTexImage2D.apply(t, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            },
            texImage2D: function() {
                try {
                    t.texImage2D.apply(t, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            },
            texImage3D: function() {
                try {
                    t.texImage3D.apply(t, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            },
            scissor: function(e) {
                !1 === R.equals(e) && (t.scissor(e.x, e.y, e.z, e.w),
                R.copy(e))
            },
            viewport: function(e) {
                !1 === I.equals(e) && (t.viewport(e.x, e.y, e.z, e.w),
                I.copy(e))
            },
            reset: function() {
                t.disable(3042),
                t.disable(2884),
                t.disable(2929),
                t.disable(32823),
                t.disable(3089),
                t.disable(2960),
                t.disable(32926),
                t.blendEquation(32774),
                t.blendFunc(1, 0),
                t.blendFuncSeparate(1, 0, 1, 0),
                t.colorMask(!0, !0, !0, !0),
                t.clearColor(0, 0, 0, 0),
                t.depthMask(!0),
                t.depthFunc(513),
                t.clearDepth(1),
                t.stencilMask(4294967295),
                t.stencilFunc(519, 0, 4294967295),
                t.stencilOp(7680, 7680, 7680),
                t.clearStencil(0),
                t.cullFace(1029),
                t.frontFace(2305),
                t.polygonOffset(0, 0),
                t.activeTexture(33984),
                t.bindFramebuffer(36160, null),
                !0 === n && (t.bindFramebuffer(36009, null),
                t.bindFramebuffer(36008, null)),
                t.useProgram(null),
                t.lineWidth(1),
                t.scissor(0, 0, t.canvas.width, t.canvas.height),
                t.viewport(0, 0, t.canvas.width, t.canvas.height),
                o = {},
                C = null,
                P = {},
                l = null,
                c = {},
                h = null,
                u = !1,
                d = null,
                p = null,
                f = null,
                m = null,
                g = null,
                v = null,
                y = null,
                x = !1,
                _ = null,
                w = null,
                b = null,
                M = null,
                S = null,
                R.set(0, 0, t.canvas.width, t.canvas.height),
                I.set(0, 0, t.canvas.width, t.canvas.height),
                r.reset(),
                s.reset(),
                a.reset()
            }
        }
    }
    function rm(t, e, i, n, r, s, a) {
        const o = r.isWebGL2
          , l = r.maxTextures
          , c = r.maxCubemapSize
          , h = r.maxTextureSize
          , u = r.maxSamples
          , d = new WeakMap;
        let p, f = !1;
        try {
            f = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1,1).getContext("2d")
        } catch (t) {}
        function m(t, e) {
            return f ? new OffscreenCanvas(t,e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
        }
        function g(t, e, i, n) {
            let r = 1;
            if ((t.width > n || t.height > n) && (r = n / Math.max(t.width, t.height)),
            r < 1 || !0 === e) {
                if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                    const n = e ? mh : Math.floor
                      , s = n(r * t.width)
                      , a = n(r * t.height);
                    void 0 === p && (p = m(s, a));
                    const o = i ? m(s, a) : p;
                    o.width = s,
                    o.height = a;
                    return o.getContext("2d").drawImage(t, 0, 0, s, a),
                    console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + s + "x" + a + ")."),
                    o
                }
                return "data"in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."),
                t
            }
            return t
        }
        function v(t) {
            return fh(t.width) && fh(t.height)
        }
        function y(t, e) {
            return t.generateMipmaps && e && t.minFilter !== bl && t.minFilter !== Tl
        }
        function x(e, i, r, s) {
            t.generateMipmap(e);
            n.get(i).__maxMipLevel = Math.log2(Math.max(r, s))
        }
        function _(i, n, r) {
            if (!1 === o)
                return n;
            if (null !== i) {
                if (void 0 !== t[i])
                    return t[i];
                console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + i + "'")
            }
            let s = n;
            return 6403 === n && (5126 === r && (s = 33326),
            5131 === r && (s = 33325),
            5121 === r && (s = 33321)),
            6407 === n && (5126 === r && (s = 34837),
            5131 === r && (s = 34843),
            5121 === r && (s = 32849)),
            6408 === n && (5126 === r && (s = 34836),
            5131 === r && (s = 34842),
            5121 === r && (s = 32856)),
            33325 !== s && 33326 !== s && 34842 !== s && 34836 !== s || e.get("EXT_color_buffer_float"),
            s
        }
        function w(t) {
            return t === bl || t === Ml || t === Sl ? 9728 : 9729
        }
        function b(e) {
            const i = e.target;
            i.removeEventListener("dispose", b),
            function(e) {
                const i = n.get(e);
                if (void 0 === i.__webglInit)
                    return;
                t.deleteTexture(i.__webglTexture),
                n.remove(e)
            }(i),
            i.isVideoTexture && d.delete(i),
            a.memory.textures--
        }
        function M(e) {
            const i = e.target;
            i.removeEventListener("dispose", M),
            function(e) {
                const i = e.texture
                  , r = n.get(e)
                  , s = n.get(i);
                if (!e)
                    return;
                void 0 !== s.__webglTexture && t.deleteTexture(s.__webglTexture);
                e.depthTexture && e.depthTexture.dispose();
                if (e.isWebGLCubeRenderTarget)
                    for (let e = 0; e < 6; e++)
                        t.deleteFramebuffer(r.__webglFramebuffer[e]),
                        r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[e]);
                else
                    t.deleteFramebuffer(r.__webglFramebuffer),
                    r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer),
                    r.__webglMultisampledFramebuffer && t.deleteFramebuffer(r.__webglMultisampledFramebuffer),
                    r.__webglColorRenderbuffer && t.deleteRenderbuffer(r.__webglColorRenderbuffer),
                    r.__webglDepthRenderbuffer && t.deleteRenderbuffer(r.__webglDepthRenderbuffer);
                n.remove(i),
                n.remove(e)
            }(i),
            a.memory.textures--
        }
        let S = 0;
        function T(t, e) {
            const r = n.get(t);
            if (t.isVideoTexture && function(t) {
                const e = a.render.frame;
                d.get(t) !== e && (d.set(t, e),
                t.update())
            }(t),
            t.version > 0 && r.__version !== t.version) {
                const i = t.image;
                if (void 0 === i)
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                else {
                    if (!1 !== i.complete)
                        return void R(r, t, e);
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                }
            }
            i.activeTexture(33984 + e),
            i.bindTexture(3553, r.__webglTexture)
        }
        function E(e, r) {
            const a = n.get(e);
            e.version > 0 && a.__version !== e.version ? function(e, n, r) {
                if (6 !== n.image.length)
                    return;
                P(e, n),
                i.activeTexture(33984 + r),
                i.bindTexture(34067, e.__webglTexture),
                t.pixelStorei(37440, n.flipY),
                t.pixelStorei(37441, n.premultiplyAlpha),
                t.pixelStorei(3317, n.unpackAlignment),
                t.pixelStorei(37443, 0);
                const a = n && (n.isCompressedTexture || n.image[0].isCompressedTexture)
                  , l = n.image[0] && n.image[0].isDataTexture
                  , h = [];
                for (let t = 0; t < 6; t++)
                    h[t] = a || l ? l ? n.image[t].image : n.image[t] : g(n.image[t], !1, !0, c);
                const u = h[0]
                  , d = v(u) || o
                  , p = s.convert(n.format)
                  , f = s.convert(n.type)
                  , m = _(n.internalFormat, p, f);
                let w;
                if (C(34067, n, d),
                a) {
                    for (let t = 0; t < 6; t++) {
                        w = h[t].mipmaps;
                        for (let e = 0; e < w.length; e++) {
                            const r = w[e];
                            n.format !== Gl && n.format !== Ul ? null !== p ? i.compressedTexImage2D(34069 + t, e, m, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : i.texImage2D(34069 + t, e, m, r.width, r.height, 0, p, f, r.data)
                        }
                    }
                    e.__maxMipLevel = w.length - 1
                } else {
                    w = n.mipmaps;
                    for (let t = 0; t < 6; t++)
                        if (l) {
                            i.texImage2D(34069 + t, 0, m, h[t].width, h[t].height, 0, p, f, h[t].data);
                            for (let e = 0; e < w.length; e++) {
                                const n = w[e].image[t].image;
                                i.texImage2D(34069 + t, e + 1, m, n.width, n.height, 0, p, f, n.data)
                            }
                        } else {
                            i.texImage2D(34069 + t, 0, m, p, f, h[t]);
                            for (let e = 0; e < w.length; e++) {
                                const n = w[e];
                                i.texImage2D(34069 + t, e + 1, m, p, f, n.image[t])
                            }
                        }
                    e.__maxMipLevel = w.length
                }
                y(n, d) && x(34067, n, u.width, u.height);
                e.__version = n.version,
                n.onUpdate && n.onUpdate(n)
            }(a, e, r) : (i.activeTexture(33984 + r),
            i.bindTexture(34067, a.__webglTexture))
        }
        const L = {
            [xl]: 10497,
            [_l]: 33071,
            [wl]: 33648
        }
          , A = {
            [bl]: 9728,
            [Ml]: 9984,
            [Sl]: 9986,
            [Tl]: 9729,
            [El]: 9985,
            [Ll]: 9987
        };
        function C(i, s, a) {
            if (a ? (t.texParameteri(i, 10242, L[s.wrapS]),
            t.texParameteri(i, 10243, L[s.wrapT]),
            32879 !== i && 35866 !== i || t.texParameteri(i, 32882, L[s.wrapR]),
            t.texParameteri(i, 10240, A[s.magFilter]),
            t.texParameteri(i, 10241, A[s.minFilter])) : (t.texParameteri(i, 10242, 33071),
            t.texParameteri(i, 10243, 33071),
            32879 !== i && 35866 !== i || t.texParameteri(i, 32882, 33071),
            s.wrapS === _l && s.wrapT === _l || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
            t.texParameteri(i, 10240, w(s.magFilter)),
            t.texParameteri(i, 10241, w(s.minFilter)),
            s.minFilter !== bl && s.minFilter !== Tl && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
            !0 === e.has("EXT_texture_filter_anisotropic")) {
                const a = e.get("EXT_texture_filter_anisotropic");
                if (s.type === Nl && !1 === e.has("OES_texture_float_linear"))
                    return;
                if (!1 === o && s.type === Ol && !1 === e.has("OES_texture_half_float_linear"))
                    return;
                (s.anisotropy > 1 || n.get(s).__currentAnisotropy) && (t.texParameterf(i, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())),
                n.get(s).__currentAnisotropy = s.anisotropy)
            }
        }
        function P(e, i) {
            void 0 === e.__webglInit && (e.__webglInit = !0,
            i.addEventListener("dispose", b),
            e.__webglTexture = t.createTexture(),
            a.memory.textures++)
        }
        function R(e, n, r) {
            let a = 3553;
            n.isDataTexture2DArray && (a = 35866),
            n.isDataTexture3D && (a = 32879),
            P(e, n),
            i.activeTexture(33984 + r),
            i.bindTexture(a, e.__webglTexture),
            t.pixelStorei(37440, n.flipY),
            t.pixelStorei(37441, n.premultiplyAlpha),
            t.pixelStorei(3317, n.unpackAlignment),
            t.pixelStorei(37443, 0);
            const l = function(t) {
                return !o && (t.wrapS !== _l || t.wrapT !== _l || t.minFilter !== bl && t.minFilter !== Tl)
            }(n) && !1 === v(n.image)
              , c = g(n.image, l, !1, h)
              , u = v(c) || o
              , d = s.convert(n.format);
            let p, f = s.convert(n.type), m = _(n.internalFormat, d, f);
            C(a, n, u);
            const w = n.mipmaps;
            if (n.isDepthTexture)
                m = 6402,
                o ? m = n.type === Nl ? 36012 : n.type === Dl ? 33190 : n.type === Fl ? 35056 : 33189 : n.type === Nl && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                n.format === ql && 6402 === m && n.type !== Rl && n.type !== Dl && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                n.type = Rl,
                f = s.convert(n.type)),
                n.format === jl && 6402 === m && (m = 34041,
                n.type !== Fl && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                n.type = Fl,
                f = s.convert(n.type))),
                i.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, null);
            else if (n.isDataTexture)
                if (w.length > 0 && u) {
                    for (let t = 0, e = w.length; t < e; t++)
                        p = w[t],
                        i.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data);
                    n.generateMipmaps = !1,
                    e.__maxMipLevel = w.length - 1
                } else
                    i.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, c.data),
                    e.__maxMipLevel = 0;
            else if (n.isCompressedTexture) {
                for (let t = 0, e = w.length; t < e; t++)
                    p = w[t],
                    n.format !== Gl && n.format !== Ul ? null !== d ? i.compressedTexImage2D(3553, t, m, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : i.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data);
                e.__maxMipLevel = w.length - 1
            } else if (n.isDataTexture2DArray)
                i.texImage3D(35866, 0, m, c.width, c.height, c.depth, 0, d, f, c.data),
                e.__maxMipLevel = 0;
            else if (n.isDataTexture3D)
                i.texImage3D(32879, 0, m, c.width, c.height, c.depth, 0, d, f, c.data),
                e.__maxMipLevel = 0;
            else if (w.length > 0 && u) {
                for (let t = 0, e = w.length; t < e; t++)
                    p = w[t],
                    i.texImage2D(3553, t, m, d, f, p);
                n.generateMipmaps = !1,
                e.__maxMipLevel = w.length - 1
            } else
                i.texImage2D(3553, 0, m, d, f, c),
                e.__maxMipLevel = 0;
            y(n, u) && x(a, n, c.width, c.height),
            e.__version = n.version,
            n.onUpdate && n.onUpdate(n)
        }
        function I(e, r, a, o) {
            const l = r.texture
              , c = s.convert(l.format)
              , h = s.convert(l.type)
              , u = _(l.internalFormat, c, h);
            32879 === o || 35866 === o ? i.texImage3D(o, 0, u, r.width, r.height, r.depth, 0, c, h, null) : i.texImage2D(o, 0, u, r.width, r.height, 0, c, h, null),
            i.bindFramebuffer(36160, e),
            t.framebufferTexture2D(36160, a, o, n.get(l).__webglTexture, 0),
            i.bindFramebuffer(36160, null)
        }
        function D(e, i, n) {
            if (t.bindRenderbuffer(36161, e),
            i.depthBuffer && !i.stencilBuffer) {
                let r = 33189;
                if (n) {
                    const e = i.depthTexture;
                    e && e.isDepthTexture && (e.type === Nl ? r = 36012 : e.type === Dl && (r = 33190));
                    const n = O(i);
                    t.renderbufferStorageMultisample(36161, n, r, i.width, i.height)
                } else
                    t.renderbufferStorage(36161, r, i.width, i.height);
                t.framebufferRenderbuffer(36160, 36096, 36161, e)
            } else if (i.depthBuffer && i.stencilBuffer) {
                if (n) {
                    const e = O(i);
                    t.renderbufferStorageMultisample(36161, e, 35056, i.width, i.height)
                } else
                    t.renderbufferStorage(36161, 34041, i.width, i.height);
                t.framebufferRenderbuffer(36160, 33306, 36161, e)
            } else {
                const e = i.texture
                  , r = s.convert(e.format)
                  , a = s.convert(e.type)
                  , o = _(e.internalFormat, r, a);
                if (n) {
                    const e = O(i);
                    t.renderbufferStorageMultisample(36161, e, o, i.width, i.height)
                } else
                    t.renderbufferStorage(36161, o, i.width, i.height)
            }
            t.bindRenderbuffer(36161, null)
        }
        function N(e) {
            const r = n.get(e)
              , s = !0 === e.isWebGLCubeRenderTarget;
            if (e.depthTexture) {
                if (s)
                    throw new Error("target.depthTexture not supported in Cube render targets");
                !function(e, r) {
                    if (r && r.isWebGLCubeRenderTarget)
                        throw new Error("Depth Texture with cube render targets is not supported");
                    if (i.bindFramebuffer(36160, e),
                    !r.depthTexture || !r.depthTexture.isDepthTexture)
                        throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    n.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width,
                    r.depthTexture.image.height = r.height,
                    r.depthTexture.needsUpdate = !0),
                    T(r.depthTexture, 0);
                    const s = n.get(r.depthTexture).__webglTexture;
                    if (r.depthTexture.format === ql)
                        t.framebufferTexture2D(36160, 36096, 3553, s, 0);
                    else {
                        if (r.depthTexture.format !== jl)
                            throw new Error("Unknown depthTexture format");
                        t.framebufferTexture2D(36160, 33306, 3553, s, 0)
                    }
                }(r.__webglFramebuffer, e)
            } else if (s) {
                r.__webglDepthbuffer = [];
                for (let n = 0; n < 6; n++)
                    i.bindFramebuffer(36160, r.__webglFramebuffer[n]),
                    r.__webglDepthbuffer[n] = t.createRenderbuffer(),
                    D(r.__webglDepthbuffer[n], e, !1)
            } else
                i.bindFramebuffer(36160, r.__webglFramebuffer),
                r.__webglDepthbuffer = t.createRenderbuffer(),
                D(r.__webglDepthbuffer, e, !1);
            i.bindFramebuffer(36160, null)
        }
        function O(t) {
            return o && t.isWebGLMultisampleRenderTarget ? Math.min(u, t.samples) : 0
        }
        let z = !1
          , k = !1;
        this.allocateTextureUnit = function() {
            const t = S;
            return t >= l && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + l),
            S += 1,
            t
        }
        ,
        this.resetTextureUnits = function() {
            S = 0
        }
        ,
        this.setTexture2D = T,
        this.setTexture2DArray = function(t, e) {
            const r = n.get(t);
            t.version > 0 && r.__version !== t.version ? R(r, t, e) : (i.activeTexture(33984 + e),
            i.bindTexture(35866, r.__webglTexture))
        }
        ,
        this.setTexture3D = function(t, e) {
            const r = n.get(t);
            t.version > 0 && r.__version !== t.version ? R(r, t, e) : (i.activeTexture(33984 + e),
            i.bindTexture(32879, r.__webglTexture))
        }
        ,
        this.setTextureCube = E,
        this.setupRenderTarget = function(e) {
            const r = e.texture
              , l = n.get(e)
              , c = n.get(r);
            e.addEventListener("dispose", M),
            c.__webglTexture = t.createTexture(),
            c.__version = r.version,
            a.memory.textures++;
            const h = !0 === e.isWebGLCubeRenderTarget
              , u = !0 === e.isWebGLMultisampleRenderTarget
              , d = r.isDataTexture3D || r.isDataTexture2DArray
              , p = v(e) || o;
            if (!o || r.format !== Ul || r.type !== Nl && r.type !== Ol || (r.format = Gl,
            console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),
            h) {
                l.__webglFramebuffer = [];
                for (let e = 0; e < 6; e++)
                    l.__webglFramebuffer[e] = t.createFramebuffer()
            } else if (l.__webglFramebuffer = t.createFramebuffer(),
            u)
                if (o) {
                    l.__webglMultisampledFramebuffer = t.createFramebuffer(),
                    l.__webglColorRenderbuffer = t.createRenderbuffer(),
                    t.bindRenderbuffer(36161, l.__webglColorRenderbuffer);
                    const n = s.convert(r.format)
                      , a = s.convert(r.type)
                      , o = _(r.internalFormat, n, a)
                      , c = O(e);
                    t.renderbufferStorageMultisample(36161, c, o, e.width, e.height),
                    i.bindFramebuffer(36160, l.__webglMultisampledFramebuffer),
                    t.framebufferRenderbuffer(36160, 36064, 36161, l.__webglColorRenderbuffer),
                    t.bindRenderbuffer(36161, null),
                    e.depthBuffer && (l.__webglDepthRenderbuffer = t.createRenderbuffer(),
                    D(l.__webglDepthRenderbuffer, e, !0)),
                    i.bindFramebuffer(36160, null)
                } else
                    console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
            if (h) {
                i.bindTexture(34067, c.__webglTexture),
                C(34067, r, p);
                for (let t = 0; t < 6; t++)
                    I(l.__webglFramebuffer[t], e, 36064, 34069 + t);
                y(r, p) && x(34067, r, e.width, e.height),
                i.bindTexture(34067, null)
            } else {
                let t = 3553;
                if (d)
                    if (o) {
                        t = r.isDataTexture3D ? 32879 : 35866
                    } else
                        console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
                i.bindTexture(t, c.__webglTexture),
                C(t, r, p),
                I(l.__webglFramebuffer, e, 36064, t),
                y(r, p) && x(3553, r, e.width, e.height),
                i.bindTexture(3553, null)
            }
            e.depthBuffer && N(e)
        }
        ,
        this.updateRenderTargetMipmap = function(t) {
            const e = t.texture;
            if (y(e, v(t) || o)) {
                const r = t.isWebGLCubeRenderTarget ? 34067 : 3553
                  , s = n.get(e).__webglTexture;
                i.bindTexture(r, s),
                x(r, e, t.width, t.height),
                i.bindTexture(r, null)
            }
        }
        ,
        this.updateMultisampleRenderTarget = function(e) {
            if (e.isWebGLMultisampleRenderTarget)
                if (o) {
                    const r = e.width
                      , s = e.height;
                    let a = 16384;
                    e.depthBuffer && (a |= 256),
                    e.stencilBuffer && (a |= 1024);
                    const o = n.get(e);
                    i.bindFramebuffer(36008, o.__webglMultisampledFramebuffer),
                    i.bindFramebuffer(36009, o.__webglFramebuffer),
                    t.blitFramebuffer(0, 0, r, s, 0, 0, r, s, a, 9728),
                    i.bindFramebuffer(36008, null),
                    i.bindFramebuffer(36009, o.__webglMultisampledFramebuffer)
                } else
                    console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
        }
        ,
        this.safeSetTexture2D = function(t, e) {
            t && t.isWebGLRenderTarget && (!1 === z && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),
            z = !0),
            t = t.texture),
            T(t, e)
        }
        ,
        this.safeSetTextureCube = function(t, e) {
            t && t.isWebGLCubeRenderTarget && (!1 === k && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),
            k = !0),
            t = t.texture),
            E(t, e)
        }
    }
    function sm(t, e, i) {
        const n = i.isWebGL2;
        return {
            convert: function(t) {
                let i;
                if (t === Al)
                    return 5121;
                if (t === zl)
                    return 32819;
                if (t === kl)
                    return 32820;
                if (t === Bl)
                    return 33635;
                if (t === Cl)
                    return 5120;
                if (t === Pl)
                    return 5122;
                if (t === Rl)
                    return 5123;
                if (t === Il)
                    return 5124;
                if (t === Dl)
                    return 5125;
                if (t === Nl)
                    return 5126;
                if (t === Ol)
                    return n ? 5131 : (i = e.get("OES_texture_half_float"),
                    null !== i ? i.HALF_FLOAT_OES : null);
                if (t === Hl)
                    return 6406;
                if (t === Ul)
                    return 6407;
                if (t === Gl)
                    return 6408;
                if (t === Vl)
                    return 6409;
                if (t === Wl)
                    return 6410;
                if (t === ql)
                    return 6402;
                if (t === jl)
                    return 34041;
                if (t === Yl)
                    return 6403;
                if (t === Xl)
                    return 36244;
                if (t === Jl)
                    return 33319;
                if (t === Zl)
                    return 33320;
                if (t === Ql)
                    return 36248;
                if (t === $l)
                    return 36249;
                if (t === Kl || t === tc || t === ec || t === ic) {
                    if (i = e.get("WEBGL_compressed_texture_s3tc"),
                    null === i)
                        return null;
                    if (t === Kl)
                        return i.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (t === tc)
                        return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (t === ec)
                        return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (t === ic)
                        return i.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                if (t === nc || t === rc || t === sc || t === ac) {
                    if (i = e.get("WEBGL_compressed_texture_pvrtc"),
                    null === i)
                        return null;
                    if (t === nc)
                        return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (t === rc)
                        return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (t === sc)
                        return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (t === ac)
                        return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                if (t === oc)
                    return i = e.get("WEBGL_compressed_texture_etc1"),
                    null !== i ? i.COMPRESSED_RGB_ETC1_WEBGL : null;
                if ((t === lc || t === cc) && (i = e.get("WEBGL_compressed_texture_etc"),
                null !== i)) {
                    if (t === lc)
                        return i.COMPRESSED_RGB8_ETC2;
                    if (t === cc)
                        return i.COMPRESSED_RGBA8_ETC2_EAC
                }
                return t === hc || t === uc || t === dc || t === pc || t === fc || t === mc || t === gc || t === vc || t === yc || t === xc || t === _c || t === wc || t === bc || t === Mc || t === Tc || t === Ec || t === Lc || t === Ac || t === Cc || t === Pc || t === Rc || t === Ic || t === Dc || t === Nc || t === Oc || t === zc || t === kc || t === Bc ? (i = e.get("WEBGL_compressed_texture_astc"),
                null !== i ? t : null) : t === Sc ? (i = e.get("EXT_texture_compression_bptc"),
                null !== i ? t : null) : t === Fl ? n ? 34042 : (i = e.get("WEBGL_depth_texture"),
                null !== i ? i.UNSIGNED_INT_24_8_WEBGL : null) : void 0
            }
        }
    }
    class am extends Hd {
        constructor(t=[]) {
            super(),
            this.cameras = t
        }
    }
    am.prototype.isArrayCamera = !0;
    class om extends Au {
        constructor() {
            super(),
            this.type = "Group"
        }
    }
    om.prototype.isGroup = !0;
    const lm = {
        type: "move"
    };
    class cm {
        constructor() {
            this._targetRay = null,
            this._grip = null,
            this._hand = null
        }
        getHandSpace() {
            return null === this._hand && (this._hand = new om,
            this._hand.matrixAutoUpdate = !1,
            this._hand.visible = !1,
            this._hand.joints = {},
            this._hand.inputState = {
                pinching: !1
            }),
            this._hand
        }
        getTargetRaySpace() {
            return null === this._targetRay && (this._targetRay = new om,
            this._targetRay.matrixAutoUpdate = !1,
            this._targetRay.visible = !1,
            this._targetRay.hasLinearVelocity = !1,
            this._targetRay.linearVelocity = new Eh,
            this._targetRay.hasAngularVelocity = !1,
            this._targetRay.angularVelocity = new Eh),
            this._targetRay
        }
        getGripSpace() {
            return null === this._grip && (this._grip = new om,
            this._grip.matrixAutoUpdate = !1,
            this._grip.visible = !1,
            this._grip.hasLinearVelocity = !1,
            this._grip.linearVelocity = new Eh,
            this._grip.hasAngularVelocity = !1,
            this._grip.angularVelocity = new Eh),
            this._grip
        }
        dispatchEvent(t) {
            return null !== this._targetRay && this._targetRay.dispatchEvent(t),
            null !== this._grip && this._grip.dispatchEvent(t),
            null !== this._hand && this._hand.dispatchEvent(t),
            this
        }
        disconnect(t) {
            return this.dispatchEvent({
                type: "disconnected",
                data: t
            }),
            null !== this._targetRay && (this._targetRay.visible = !1),
            null !== this._grip && (this._grip.visible = !1),
            null !== this._hand && (this._hand.visible = !1),
            this
        }
        update(t, e, i) {
            let n = null
              , r = null
              , s = null;
            const a = this._targetRay
              , o = this._grip
              , l = this._hand;
            if (t && "visible-blurred" !== e.session.visibilityState)
                if (null !== a && (n = e.getPose(t.targetRaySpace, i),
                null !== n && (a.matrix.fromArray(n.transform.matrix),
                a.matrix.decompose(a.position, a.rotation, a.scale),
                n.linearVelocity ? (a.hasLinearVelocity = !0,
                a.linearVelocity.copy(n.linearVelocity)) : a.hasLinearVelocity = !1,
                n.angularVelocity ? (a.hasAngularVelocity = !0,
                a.angularVelocity.copy(n.angularVelocity)) : a.hasAngularVelocity = !1,
                this.dispatchEvent(lm))),
                l && t.hand) {
                    s = !0;
                    for (const n of t.hand.values()) {
                        const t = e.getJointPose(n, i);
                        if (void 0 === l.joints[n.jointName]) {
                            const t = new om;
                            t.matrixAutoUpdate = !1,
                            t.visible = !1,
                            l.joints[n.jointName] = t,
                            l.add(t)
                        }
                        const r = l.joints[n.jointName];
                        null !== t && (r.matrix.fromArray(t.transform.matrix),
                        r.matrix.decompose(r.position, r.rotation, r.scale),
                        r.jointRadius = t.radius),
                        r.visible = null !== t
                    }
                    const n = l.joints["index-finger-tip"]
                      , r = l.joints["thumb-tip"]
                      , a = n.position.distanceTo(r.position)
                      , o = .02
                      , c = .005;
                    l.inputState.pinching && a > o + c ? (l.inputState.pinching = !1,
                    this.dispatchEvent({
                        type: "pinchend",
                        handedness: t.handedness,
                        target: this
                    })) : !l.inputState.pinching && a <= o - c && (l.inputState.pinching = !0,
                    this.dispatchEvent({
                        type: "pinchstart",
                        handedness: t.handedness,
                        target: this
                    }))
                } else
                    null !== o && t.gripSpace && (r = e.getPose(t.gripSpace, i),
                    null !== r && (o.matrix.fromArray(r.transform.matrix),
                    o.matrix.decompose(o.position, o.rotation, o.scale),
                    r.linearVelocity ? (o.hasLinearVelocity = !0,
                    o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1,
                    r.angularVelocity ? (o.hasAngularVelocity = !0,
                    o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1));
            return null !== a && (a.visible = null !== n),
            null !== o && (o.visible = null !== r),
            null !== l && (l.visible = null !== s),
            this
        }
    }
    class hm extends oh {
        constructor(t, e) {
            super();
            const i = this
              , n = t.state;
            let r = null
              , s = 1
              , a = null
              , o = "local-floor"
              , l = null;
            const c = []
              , h = new Map
              , u = new Hd;
            u.layers.enable(1),
            u.viewport = new Mh;
            const d = new Hd;
            d.layers.enable(2),
            d.viewport = new Mh;
            const p = [u, d]
              , f = new am;
            f.layers.enable(1),
            f.layers.enable(2);
            let m = null
              , g = null;
            function v(t) {
                const e = h.get(t.inputSource);
                e && e.dispatchEvent({
                    type: t.type,
                    data: t.inputSource
                })
            }
            function y() {
                h.forEach((function(t, e) {
                    t.disconnect(e)
                }
                )),
                h.clear(),
                m = null,
                g = null,
                n.bindXRFramebuffer(null),
                t.setRenderTarget(t.getRenderTarget()),
                S.stop(),
                i.isPresenting = !1,
                i.dispatchEvent({
                    type: "sessionend"
                })
            }
            function x(t) {
                const e = r.inputSources;
                for (let t = 0; t < c.length; t++)
                    h.set(e[t], c[t]);
                for (let e = 0; e < t.removed.length; e++) {
                    const i = t.removed[e]
                      , n = h.get(i);
                    n && (n.dispatchEvent({
                        type: "disconnected",
                        data: i
                    }),
                    h.delete(i))
                }
                for (let e = 0; e < t.added.length; e++) {
                    const i = t.added[e]
                      , n = h.get(i);
                    n && n.dispatchEvent({
                        type: "connected",
                        data: i
                    })
                }
            }
            this.enabled = !1,
            this.isPresenting = !1,
            this.getController = function(t) {
                let e = c[t];
                return void 0 === e && (e = new cm,
                c[t] = e),
                e.getTargetRaySpace()
            }
            ,
            this.getControllerGrip = function(t) {
                let e = c[t];
                return void 0 === e && (e = new cm,
                c[t] = e),
                e.getGripSpace()
            }
            ,
            this.getHand = function(t) {
                let e = c[t];
                return void 0 === e && (e = new cm,
                c[t] = e),
                e.getHandSpace()
            }
            ,
            this.setFramebufferScaleFactor = function(t) {
                s = t,
                !0 === i.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
            }
            ,
            this.setReferenceSpaceType = function(t) {
                o = t,
                !0 === i.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
            }
            ,
            this.getReferenceSpace = function() {
                return a
            }
            ,
            this.getSession = function() {
                return r
            }
            ,
            this.setSession = async function(t) {
                if (r = t,
                null !== r) {
                    r.addEventListener("select", v),
                    r.addEventListener("selectstart", v),
                    r.addEventListener("selectend", v),
                    r.addEventListener("squeeze", v),
                    r.addEventListener("squeezestart", v),
                    r.addEventListener("squeezeend", v),
                    r.addEventListener("end", y),
                    r.addEventListener("inputsourceschange", x);
                    const t = e.getContextAttributes();
                    !0 !== t.xrCompatible && await e.makeXRCompatible();
                    const n = {
                        antialias: t.antialias,
                        alpha: t.alpha,
                        depth: t.depth,
                        stencil: t.stencil,
                        framebufferScaleFactor: s
                    }
                      , l = new XRWebGLLayer(r,e,n);
                    r.updateRenderState({
                        baseLayer: l
                    }),
                    a = await r.requestReferenceSpace(o),
                    S.setContext(r),
                    S.start(),
                    i.isPresenting = !0,
                    i.dispatchEvent({
                        type: "sessionstart"
                    })
                }
            }
            ;
            const _ = new Eh
              , w = new Eh;
            function b(t, e) {
                null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
                t.matrixWorldInverse.copy(t.matrixWorld).invert()
            }
            this.getCamera = function(t) {
                f.near = d.near = u.near = t.near,
                f.far = d.far = u.far = t.far,
                m === f.near && g === f.far || (r.updateRenderState({
                    depthNear: f.near,
                    depthFar: f.far
                }),
                m = f.near,
                g = f.far);
                const e = t.parent
                  , i = f.cameras;
                b(f, e);
                for (let t = 0; t < i.length; t++)
                    b(i[t], e);
                t.matrixWorld.copy(f.matrixWorld),
                t.matrix.copy(f.matrix),
                t.matrix.decompose(t.position, t.quaternion, t.scale);
                const n = t.children;
                for (let t = 0, e = n.length; t < e; t++)
                    n[t].updateMatrixWorld(!0);
                return 2 === i.length ? function(t, e, i) {
                    _.setFromMatrixPosition(e.matrixWorld),
                    w.setFromMatrixPosition(i.matrixWorld);
                    const n = _.distanceTo(w)
                      , r = e.projectionMatrix.elements
                      , s = i.projectionMatrix.elements
                      , a = r[14] / (r[10] - 1)
                      , o = r[14] / (r[10] + 1)
                      , l = (r[9] + 1) / r[5]
                      , c = (r[9] - 1) / r[5]
                      , h = (r[8] - 1) / r[0]
                      , u = (s[8] + 1) / s[0]
                      , d = a * h
                      , p = a * u
                      , f = n / (-h + u)
                      , m = f * -h;
                    e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
                    t.translateX(m),
                    t.translateZ(f),
                    t.matrixWorld.compose(t.position, t.quaternion, t.scale),
                    t.matrixWorldInverse.copy(t.matrixWorld).invert();
                    const g = a + f
                      , v = o + f
                      , y = d - m
                      , x = p + (n - m)
                      , b = l * o / v * g
                      , M = c * o / v * g;
                    t.projectionMatrix.makePerspective(y, x, b, M, g, v)
                }(f, u, d) : f.projectionMatrix.copy(u.projectionMatrix),
                f
            }
            ;
            let M = null;
            const S = new Jd;
            S.setAnimationLoop((function(t, e) {
                if (l = e.getViewerPose(a),
                null !== l) {
                    const t = l.views
                      , e = r.renderState.baseLayer;
                    n.bindXRFramebuffer(e.framebuffer);
                    let i = !1;
                    t.length !== f.cameras.length && (f.cameras.length = 0,
                    i = !0);
                    for (let n = 0; n < t.length; n++) {
                        const r = t[n]
                          , s = e.getViewport(r)
                          , a = p[n];
                        a.matrix.fromArray(r.transform.matrix),
                        a.projectionMatrix.fromArray(r.projectionMatrix),
                        a.viewport.set(s.x, s.y, s.width, s.height),
                        0 === n && f.matrix.copy(a.matrix),
                        !0 === i && f.cameras.push(a)
                    }
                }
                const i = r.inputSources;
                for (let t = 0; t < c.length; t++) {
                    const n = c[t]
                      , r = i[t];
                    n.update(r, e, a)
                }
                M && M(t, e)
            }
            )),
            this.setAnimationLoop = function(t) {
                M = t
            }
            ,
            this.dispose = function() {}
        }
    }
    function um(t) {
        function e(e, i) {
            e.opacity.value = i.opacity,
            i.color && e.diffuse.value.copy(i.color),
            i.emissive && e.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity),
            i.map && (e.map.value = i.map),
            i.alphaMap && (e.alphaMap.value = i.alphaMap),
            i.specularMap && (e.specularMap.value = i.specularMap);
            const n = t.get(i).envMap;
            if (n) {
                e.envMap.value = n,
                e.flipEnvMap.value = n.isCubeTexture && n._needsFlipEnvMap ? -1 : 1,
                e.reflectivity.value = i.reflectivity,
                e.refractionRatio.value = i.refractionRatio;
                const r = t.get(n).__maxMipLevel;
                void 0 !== r && (e.maxMipLevel.value = r)
            }
            let r, s;
            i.lightMap && (e.lightMap.value = i.lightMap,
            e.lightMapIntensity.value = i.lightMapIntensity),
            i.aoMap && (e.aoMap.value = i.aoMap,
            e.aoMapIntensity.value = i.aoMapIntensity),
            i.map ? r = i.map : i.specularMap ? r = i.specularMap : i.displacementMap ? r = i.displacementMap : i.normalMap ? r = i.normalMap : i.bumpMap ? r = i.bumpMap : i.roughnessMap ? r = i.roughnessMap : i.metalnessMap ? r = i.metalnessMap : i.alphaMap ? r = i.alphaMap : i.emissiveMap ? r = i.emissiveMap : i.clearcoatMap ? r = i.clearcoatMap : i.clearcoatNormalMap ? r = i.clearcoatNormalMap : i.clearcoatRoughnessMap && (r = i.clearcoatRoughnessMap),
            void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture),
            !0 === r.matrixAutoUpdate && r.updateMatrix(),
            e.uvTransform.value.copy(r.matrix)),
            i.aoMap ? s = i.aoMap : i.lightMap && (s = i.lightMap),
            void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture),
            !0 === s.matrixAutoUpdate && s.updateMatrix(),
            e.uv2Transform.value.copy(s.matrix))
        }
        function i(e, i) {
            e.roughness.value = i.roughness,
            e.metalness.value = i.metalness,
            i.roughnessMap && (e.roughnessMap.value = i.roughnessMap),
            i.metalnessMap && (e.metalnessMap.value = i.metalnessMap),
            i.emissiveMap && (e.emissiveMap.value = i.emissiveMap),
            i.bumpMap && (e.bumpMap.value = i.bumpMap,
            e.bumpScale.value = i.bumpScale,
            i.side === Eo && (e.bumpScale.value *= -1)),
            i.normalMap && (e.normalMap.value = i.normalMap,
            e.normalScale.value.copy(i.normalScale),
            i.side === Eo && e.normalScale.value.negate()),
            i.displacementMap && (e.displacementMap.value = i.displacementMap,
            e.displacementScale.value = i.displacementScale,
            e.displacementBias.value = i.displacementBias);
            t.get(i).envMap && (e.envMapIntensity.value = i.envMapIntensity)
        }
        return {
            refreshFogUniforms: function(t, e) {
                t.fogColor.value.copy(e.color),
                e.isFog ? (t.fogNear.value = e.near,
                t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
            },
            refreshMaterialUniforms: function(t, n, r, s) {
                n.isMeshBasicMaterial ? e(t, n) : n.isMeshLambertMaterial ? (e(t, n),
                function(t, e) {
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                }(t, n)) : n.isMeshToonMaterial ? (e(t, n),
                function(t, e) {
                    e.gradientMap && (t.gradientMap.value = e.gradientMap);
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                    e.bumpMap && (t.bumpMap.value = e.bumpMap,
                    t.bumpScale.value = e.bumpScale,
                    e.side === Eo && (t.bumpScale.value *= -1));
                    e.normalMap && (t.normalMap.value = e.normalMap,
                    t.normalScale.value.copy(e.normalScale),
                    e.side === Eo && t.normalScale.value.negate());
                    e.displacementMap && (t.displacementMap.value = e.displacementMap,
                    t.displacementScale.value = e.displacementScale,
                    t.displacementBias.value = e.displacementBias)
                }(t, n)) : n.isMeshPhongMaterial ? (e(t, n),
                function(t, e) {
                    t.specular.value.copy(e.specular),
                    t.shininess.value = Math.max(e.shininess, 1e-4),
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                    e.bumpMap && (t.bumpMap.value = e.bumpMap,
                    t.bumpScale.value = e.bumpScale,
                    e.side === Eo && (t.bumpScale.value *= -1));
                    e.normalMap && (t.normalMap.value = e.normalMap,
                    t.normalScale.value.copy(e.normalScale),
                    e.side === Eo && t.normalScale.value.negate());
                    e.displacementMap && (t.displacementMap.value = e.displacementMap,
                    t.displacementScale.value = e.displacementScale,
                    t.displacementBias.value = e.displacementBias)
                }(t, n)) : n.isMeshStandardMaterial ? (e(t, n),
                n.isMeshPhysicalMaterial ? function(t, e) {
                    i(t, e),
                    t.reflectivity.value = e.reflectivity,
                    t.clearcoat.value = e.clearcoat,
                    t.clearcoatRoughness.value = e.clearcoatRoughness,
                    e.sheen && t.sheen.value.copy(e.sheen);
                    e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap);
                    e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap);
                    e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),
                    t.clearcoatNormalMap.value = e.clearcoatNormalMap,
                    e.side === Eo && t.clearcoatNormalScale.value.negate());
                    t.transmission.value = e.transmission,
                    e.transmissionMap && (t.transmissionMap.value = e.transmissionMap)
                }(t, n) : i(t, n)) : n.isMeshMatcapMaterial ? (e(t, n),
                function(t, e) {
                    e.matcap && (t.matcap.value = e.matcap);
                    e.bumpMap && (t.bumpMap.value = e.bumpMap,
                    t.bumpScale.value = e.bumpScale,
                    e.side === Eo && (t.bumpScale.value *= -1));
                    e.normalMap && (t.normalMap.value = e.normalMap,
                    t.normalScale.value.copy(e.normalScale),
                    e.side === Eo && t.normalScale.value.negate());
                    e.displacementMap && (t.displacementMap.value = e.displacementMap,
                    t.displacementScale.value = e.displacementScale,
                    t.displacementBias.value = e.displacementBias)
                }(t, n)) : n.isMeshDepthMaterial ? (e(t, n),
                function(t, e) {
                    e.displacementMap && (t.displacementMap.value = e.displacementMap,
                    t.displacementScale.value = e.displacementScale,
                    t.displacementBias.value = e.displacementBias)
                }(t, n)) : n.isMeshDistanceMaterial ? (e(t, n),
                function(t, e) {
                    e.displacementMap && (t.displacementMap.value = e.displacementMap,
                    t.displacementScale.value = e.displacementScale,
                    t.displacementBias.value = e.displacementBias);
                    t.referencePosition.value.copy(e.referencePosition),
                    t.nearDistance.value = e.nearDistance,
                    t.farDistance.value = e.farDistance
                }(t, n)) : n.isMeshNormalMaterial ? (e(t, n),
                function(t, e) {
                    e.bumpMap && (t.bumpMap.value = e.bumpMap,
                    t.bumpScale.value = e.bumpScale,
                    e.side === Eo && (t.bumpScale.value *= -1));
                    e.normalMap && (t.normalMap.value = e.normalMap,
                    t.normalScale.value.copy(e.normalScale),
                    e.side === Eo && t.normalScale.value.negate());
                    e.displacementMap && (t.displacementMap.value = e.displacementMap,
                    t.displacementScale.value = e.displacementScale,
                    t.displacementBias.value = e.displacementBias)
                }(t, n)) : n.isLineBasicMaterial ? (function(t, e) {
                    t.diffuse.value.copy(e.color),
                    t.opacity.value = e.opacity
                }(t, n),
                n.isLineDashedMaterial && function(t, e) {
                    t.dashSize.value = e.dashSize,
                    t.totalSize.value = e.dashSize + e.gapSize,
                    t.scale.value = e.scale
                }(t, n)) : n.isPointsMaterial ? function(t, e, i, n) {
                    t.diffuse.value.copy(e.color),
                    t.opacity.value = e.opacity,
                    t.size.value = e.size * i,
                    t.scale.value = .5 * n,
                    e.map && (t.map.value = e.map);
                    e.alphaMap && (t.alphaMap.value = e.alphaMap);
                    let r;
                    e.map ? r = e.map : e.alphaMap && (r = e.alphaMap);
                    void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(),
                    t.uvTransform.value.copy(r.matrix))
                }(t, n, r, s) : n.isSpriteMaterial ? function(t, e) {
                    t.diffuse.value.copy(e.color),
                    t.opacity.value = e.opacity,
                    t.rotation.value = e.rotation,
                    e.map && (t.map.value = e.map);
                    e.alphaMap && (t.alphaMap.value = e.alphaMap);
                    let i;
                    e.map ? i = e.map : e.alphaMap && (i = e.alphaMap);
                    void 0 !== i && (!0 === i.matrixAutoUpdate && i.updateMatrix(),
                    t.uvTransform.value.copy(i.matrix))
                }(t, n) : n.isShadowMaterial ? (t.color.value.copy(n.color),
                t.opacity.value = n.opacity) : n.isShaderMaterial && (n.uniformsNeedUpdate = !1)
            }
        }
    }
    function dm(t) {
        const e = void 0 !== (t = t || {}).canvas ? t.canvas : function() {
            const t = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
            return t.style.display = "block",
            t
        }()
          , i = void 0 !== t.context ? t.context : null
          , n = void 0 !== t.alpha && t.alpha
          , r = void 0 === t.depth || t.depth
          , s = void 0 === t.stencil || t.stencil
          , a = void 0 !== t.antialias && t.antialias
          , o = void 0 === t.premultipliedAlpha || t.premultipliedAlpha
          , l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer
          , c = void 0 !== t.powerPreference ? t.powerPreference : "default"
          , h = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
        let u = null
          , d = null;
        const p = []
          , f = [];
        this.domElement = e,
        this.debug = {
            checkShaderErrors: !0
        },
        this.autoClear = !0,
        this.autoClearColor = !0,
        this.autoClearDepth = !0,
        this.autoClearStencil = !0,
        this.sortObjects = !0,
        this.clippingPlanes = [],
        this.localClippingEnabled = !1,
        this.gammaFactor = 2,
        this.outputEncoding = jc,
        this.physicallyCorrectLights = !1,
        this.toneMapping = ol,
        this.toneMappingExposure = 1;
        const m = this;
        let g = !1
          , v = 0
          , y = 0
          , x = null
          , _ = -1
          , w = null;
        const b = new Mh
          , M = new Mh;
        let S = null
          , T = e.width
          , E = e.height
          , L = 1
          , A = null
          , C = null;
        const P = new Mh(0,0,T,E)
          , R = new Mh(0,0,T,E);
        let I = !1;
        const D = new Xd;
        let N = !1
          , O = !1;
        const z = new nu
          , k = new Eh
          , B = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0
        };
        function F() {
            return null === x ? L : 1
        }
        let H, U, G, V, W, q, j, Y, X, J, Z, Q, K, tt, et, it, nt, rt, st, at, ot, lt, ct = i;
        function ht(t, i) {
            for (let n = 0; n < t.length; n++) {
                const r = t[n]
                  , s = e.getContext(r, i);
                if (null !== s)
                    return s
            }
            return null
        }
        try {
            const t = {
                alpha: n,
                depth: r,
                stencil: s,
                antialias: a,
                premultipliedAlpha: o,
                preserveDrawingBuffer: l,
                powerPreference: c,
                failIfMajorPerformanceCaveat: h
            };
            if (e.addEventListener("webglcontextlost", pt, !1),
            e.addEventListener("webglcontextrestored", ft, !1),
            null === ct) {
                const e = ["webgl2", "webgl", "experimental-webgl"];
                if (!0 === m.isWebGL1Renderer && e.shift(),
                ct = ht(e, t),
                null === ct)
                    throw ht(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
            }
            void 0 === ct.getShaderPrecisionFormat && (ct.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            }
            )
        } catch (t) {
            throw console.error("THREE.WebGLRenderer: " + t.message),
            t
        }
        function ut() {
            H = new op(ct),
            U = new rp(ct,H,t),
            H.init(U),
            ot = new sm(ct,H,U),
            G = new nm(ct,H,U),
            V = new hp,
            W = new Uf,
            q = new rm(ct,H,G,W,U,ot,V),
            j = new ap(m),
            Y = new Zd(ct,U),
            lt = new ip(ct,H,Y,U),
            X = new lp(ct,Y,V,lt),
            J = new fp(ct,X,Y,V),
            rt = new pp(ct),
            et = new sp(W),
            Z = new Hf(m,j,H,U,lt,et),
            Q = new um(W),
            K = new qf(W),
            tt = new Qf(H,U),
            nt = new ep(m,j,G,J,o),
            it = new im(m,J,U),
            st = new np(ct,H,V,U),
            at = new cp(ct,H,V,U),
            V.programs = Z.programs,
            m.capabilities = U,
            m.extensions = H,
            m.properties = W,
            m.renderLists = K,
            m.shadowMap = it,
            m.state = G,
            m.info = V
        }
        ut();
        const dt = new hm(m,ct);
        function pt(t) {
            t.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            g = !0
        }
        function ft() {
            console.log("THREE.WebGLRenderer: Context Restored."),
            g = !1;
            const t = V.autoReset
              , e = it.enabled
              , i = it.autoUpdate
              , n = it.needsUpdate
              , r = it.type;
            ut(),
            V.autoReset = t,
            it.enabled = e,
            it.autoUpdate = i,
            it.needsUpdate = n,
            it.type = r
        }
        function mt(t) {
            const e = t.target;
            e.removeEventListener("dispose", mt),
            function(t) {
                (function(t) {
                    const e = W.get(t).programs;
                    void 0 !== e && e.forEach((function(t) {
                        Z.releaseProgram(t)
                    }
                    ))
                }
                )(t),
                W.remove(t)
            }(e)
        }
        this.xr = dt,
        this.getContext = function() {
            return ct
        }
        ,
        this.getContextAttributes = function() {
            return ct.getContextAttributes()
        }
        ,
        this.forceContextLoss = function() {
            const t = H.get("WEBGL_lose_context");
            t && t.loseContext()
        }
        ,
        this.forceContextRestore = function() {
            const t = H.get("WEBGL_lose_context");
            t && t.restoreContext()
        }
        ,
        this.getPixelRatio = function() {
            return L
        }
        ,
        this.setPixelRatio = function(t) {
            void 0 !== t && (L = t,
            this.setSize(T, E, !1))
        }
        ,
        this.getSize = function(t) {
            return void 0 === t && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),
            t = new gh),
            t.set(T, E)
        }
        ,
        this.setSize = function(t, i, n) {
            dt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (T = t,
            E = i,
            e.width = Math.floor(t * L),
            e.height = Math.floor(i * L),
            !1 !== n && (e.style.width = t + "px",
            e.style.height = i + "px"),
            this.setViewport(0, 0, t, i))
        }
        ,
        this.getDrawingBufferSize = function(t) {
            return void 0 === t && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),
            t = new gh),
            t.set(T * L, E * L).floor()
        }
        ,
        this.setDrawingBufferSize = function(t, i, n) {
            T = t,
            E = i,
            L = n,
            e.width = Math.floor(t * n),
            e.height = Math.floor(i * n),
            this.setViewport(0, 0, t, i)
        }
        ,
        this.getCurrentViewport = function(t) {
            return void 0 === t && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),
            t = new Mh),
            t.copy(b)
        }
        ,
        this.getViewport = function(t) {
            return t.copy(P)
        }
        ,
        this.setViewport = function(t, e, i, n) {
            t.isVector4 ? P.set(t.x, t.y, t.z, t.w) : P.set(t, e, i, n),
            G.viewport(b.copy(P).multiplyScalar(L).floor())
        }
        ,
        this.getScissor = function(t) {
            return t.copy(R)
        }
        ,
        this.setScissor = function(t, e, i, n) {
            t.isVector4 ? R.set(t.x, t.y, t.z, t.w) : R.set(t, e, i, n),
            G.scissor(M.copy(R).multiplyScalar(L).floor())
        }
        ,
        this.getScissorTest = function() {
            return I
        }
        ,
        this.setScissorTest = function(t) {
            G.setScissorTest(I = t)
        }
        ,
        this.setOpaqueSort = function(t) {
            A = t
        }
        ,
        this.setTransparentSort = function(t) {
            C = t
        }
        ,
        this.getClearColor = function(t) {
            return void 0 === t && (console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"),
            t = new $u),
            t.copy(nt.getClearColor())
        }
        ,
        this.setClearColor = function() {
            nt.setClearColor.apply(nt, arguments)
        }
        ,
        this.getClearAlpha = function() {
            return nt.getClearAlpha()
        }
        ,
        this.setClearAlpha = function() {
            nt.setClearAlpha.apply(nt, arguments)
        }
        ,
        this.clear = function(t, e, i) {
            let n = 0;
            (void 0 === t || t) && (n |= 16384),
            (void 0 === e || e) && (n |= 256),
            (void 0 === i || i) && (n |= 1024),
            ct.clear(n)
        }
        ,
        this.clearColor = function() {
            this.clear(!0, !1, !1)
        }
        ,
        this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }
        ,
        this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }
        ,
        this.dispose = function() {
            e.removeEventListener("webglcontextlost", pt, !1),
            e.removeEventListener("webglcontextrestored", ft, !1),
            K.dispose(),
            tt.dispose(),
            W.dispose(),
            j.dispose(),
            J.dispose(),
            lt.dispose(),
            dt.dispose(),
            dt.removeEventListener("sessionstart", vt),
            dt.removeEventListener("sessionend", yt),
            xt.stop()
        }
        ,
        this.renderBufferImmediate = function(t, e) {
            lt.initAttributes();
            const i = W.get(t);
            t.hasPositions && !i.position && (i.position = ct.createBuffer()),
            t.hasNormals && !i.normal && (i.normal = ct.createBuffer()),
            t.hasUvs && !i.uv && (i.uv = ct.createBuffer()),
            t.hasColors && !i.color && (i.color = ct.createBuffer());
            const n = e.getAttributes();
            t.hasPositions && (ct.bindBuffer(34962, i.position),
            ct.bufferData(34962, t.positionArray, 35048),
            lt.enableAttribute(n.position),
            ct.vertexAttribPointer(n.position, 3, 5126, !1, 0, 0)),
            t.hasNormals && (ct.bindBuffer(34962, i.normal),
            ct.bufferData(34962, t.normalArray, 35048),
            lt.enableAttribute(n.normal),
            ct.vertexAttribPointer(n.normal, 3, 5126, !1, 0, 0)),
            t.hasUvs && (ct.bindBuffer(34962, i.uv),
            ct.bufferData(34962, t.uvArray, 35048),
            lt.enableAttribute(n.uv),
            ct.vertexAttribPointer(n.uv, 2, 5126, !1, 0, 0)),
            t.hasColors && (ct.bindBuffer(34962, i.color),
            ct.bufferData(34962, t.colorArray, 35048),
            lt.enableAttribute(n.color),
            ct.vertexAttribPointer(n.color, 3, 5126, !1, 0, 0)),
            lt.disableUnusedAttributes(),
            ct.drawArrays(4, 0, t.count),
            t.count = 0
        }
        ,
        this.renderBufferDirect = function(t, e, i, n, r, s) {
            null === e && (e = B);
            const a = r.isMesh && r.matrixWorld.determinant() < 0
              , o = Tt(t, e, n, r);
            G.setMaterial(n, a);
            let l = i.index;
            const c = i.attributes.position;
            if (null === l) {
                if (void 0 === c || 0 === c.count)
                    return
            } else if (0 === l.count)
                return;
            let h, u = 1;
            !0 === n.wireframe && (l = X.getWireframeAttribute(i),
            u = 2),
            (n.morphTargets || n.morphNormals) && rt.update(r, i, n, o),
            lt.setup(r, n, o, i, l);
            let d = st;
            null !== l && (h = Y.get(l),
            d = at,
            d.setIndex(h));
            const p = null !== l ? l.count : c.count
              , f = i.drawRange.start * u
              , m = i.drawRange.count * u
              , g = null !== s ? s.start * u : 0
              , v = null !== s ? s.count * u : 1 / 0
              , y = Math.max(f, g)
              , x = Math.min(p, f + m, g + v) - 1
              , _ = Math.max(0, x - y + 1);
            if (0 !== _) {
                if (r.isMesh)
                    !0 === n.wireframe ? (G.setLineWidth(n.wireframeLinewidth * F()),
                    d.setMode(1)) : d.setMode(4);
                else if (r.isLine) {
                    let t = n.linewidth;
                    void 0 === t && (t = 1),
                    G.setLineWidth(t * F()),
                    r.isLineSegments ? d.setMode(1) : r.isLineLoop ? d.setMode(2) : d.setMode(3)
                } else
                    r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
                if (r.isInstancedMesh)
                    d.renderInstances(y, _, r.count);
                else if (i.isInstancedBufferGeometry) {
                    const t = Math.min(i.instanceCount, i._maxInstanceCount);
                    d.renderInstances(y, _, t)
                } else
                    d.render(y, _)
            }
        }
        ,
        this.compile = function(t, e) {
            d = tt.get(t),
            d.init(),
            t.traverseVisible((function(t) {
                t.isLight && t.layers.test(e.layers) && (d.pushLight(t),
                t.castShadow && d.pushShadow(t))
            }
            )),
            d.setupLights(),
            t.traverse((function(e) {
                const i = e.material;
                if (i)
                    if (Array.isArray(i))
                        for (let n = 0; n < i.length; n++) {
                            Mt(i[n], t, e)
                        }
                    else
                        Mt(i, t, e)
            }
            ))
        }
        ;
        let gt = null;
        function vt() {
            xt.stop()
        }
        function yt() {
            xt.start()
        }
        const xt = new Jd;
        function _t(t, e, i, n) {
            if (!1 === t.visible)
                return;
            if (t.layers.test(e.layers))
                if (t.isGroup)
                    i = t.renderOrder;
                else if (t.isLOD)
                    !0 === t.autoUpdate && t.update(e);
                else if (t.isLight)
                    d.pushLight(t),
                    t.castShadow && d.pushShadow(t);
                else if (t.isSprite) {
                    if (!t.frustumCulled || D.intersectsSprite(t)) {
                        n && k.setFromMatrixPosition(t.matrixWorld).applyMatrix4(z);
                        const e = J.update(t)
                          , r = t.material;
                        r.visible && u.push(t, e, r, i, k.z, null)
                    }
                } else if (t.isImmediateRenderObject)
                    n && k.setFromMatrixPosition(t.matrixWorld).applyMatrix4(z),
                    u.push(t, null, t.material, i, k.z, null);
                else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== V.render.frame && (t.skeleton.update(),
                t.skeleton.frame = V.render.frame),
                !t.frustumCulled || D.intersectsObject(t))) {
                    n && k.setFromMatrixPosition(t.matrixWorld).applyMatrix4(z);
                    const e = J.update(t)
                      , r = t.material;
                    if (Array.isArray(r)) {
                        const n = e.groups;
                        for (let s = 0, a = n.length; s < a; s++) {
                            const a = n[s]
                              , o = r[a.materialIndex];
                            o && o.visible && u.push(t, e, o, i, k.z, a)
                        }
                    } else
                        r.visible && u.push(t, e, r, i, k.z, null)
                }
            const r = t.children;
            for (let t = 0, s = r.length; t < s; t++)
                _t(r[t], e, i, n)
        }
        function wt(t, e, i) {
            const n = !0 === e.isScene ? e.overrideMaterial : null;
            for (let r = 0, s = t.length; r < s; r++) {
                const s = t[r]
                  , a = s.object
                  , o = s.geometry
                  , l = null === n ? s.material : n
                  , c = s.group;
                if (i.isArrayCamera) {
                    const t = i.cameras;
                    for (let i = 0, n = t.length; i < n; i++) {
                        const n = t[i];
                        a.layers.test(n.layers) && (G.viewport(b.copy(n.viewport)),
                        d.setupLightsView(n),
                        bt(a, e, n, o, l, c))
                    }
                } else
                    bt(a, e, i, o, l, c)
            }
        }
        function bt(t, e, i, n, r, s) {
            if (t.onBeforeRender(m, e, i, n, r, s),
            t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld),
            t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
            t.isImmediateRenderObject) {
                const n = Tt(i, e, r, t);
                G.setMaterial(r),
                lt.reset(),
                function(t, e) {
                    t.render((function(t) {
                        m.renderBufferImmediate(t, e)
                    }
                    ))
                }(t, n)
            } else
                m.renderBufferDirect(i, e, n, r, t, s);
            t.onAfterRender(m, e, i, n, r, s)
        }
        function Mt(t, e, i) {
            !0 !== e.isScene && (e = B);
            const n = W.get(t)
              , r = d.state.lights
              , s = d.state.shadowsArray
              , a = r.state.version
              , o = Z.getParameters(t, r.state, s, e, i)
              , l = Z.getProgramCacheKey(o);
            let c = n.programs;
            n.environment = t.isMeshStandardMaterial ? e.environment : null,
            n.fog = e.fog,
            n.envMap = j.get(t.envMap || n.environment),
            void 0 === c && (t.addEventListener("dispose", mt),
            c = new Map,
            n.programs = c);
            let h = c.get(l);
            if (void 0 !== h) {
                if (n.currentProgram === h && n.lightsStateVersion === a)
                    return St(t, o),
                    h
            } else
                o.uniforms = Z.getUniforms(t),
                t.onBuild(o, m),
                t.onBeforeCompile(o, m),
                h = Z.acquireProgram(o, l),
                c.set(l, h),
                n.uniforms = o.uniforms;
            const u = n.uniforms;
            (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (u.clippingPlanes = et.uniform),
            St(t, o),
            n.needsLights = function(t) {
                return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
            }(t),
            n.lightsStateVersion = a,
            n.needsLights && (u.ambientLightColor.value = r.state.ambient,
            u.lightProbe.value = r.state.probe,
            u.directionalLights.value = r.state.directional,
            u.directionalLightShadows.value = r.state.directionalShadow,
            u.spotLights.value = r.state.spot,
            u.spotLightShadows.value = r.state.spotShadow,
            u.rectAreaLights.value = r.state.rectArea,
            u.ltc_1.value = r.state.rectAreaLTC1,
            u.ltc_2.value = r.state.rectAreaLTC2,
            u.pointLights.value = r.state.point,
            u.pointLightShadows.value = r.state.pointShadow,
            u.hemisphereLights.value = r.state.hemi,
            u.directionalShadowMap.value = r.state.directionalShadowMap,
            u.directionalShadowMatrix.value = r.state.directionalShadowMatrix,
            u.spotShadowMap.value = r.state.spotShadowMap,
            u.spotShadowMatrix.value = r.state.spotShadowMatrix,
            u.pointShadowMap.value = r.state.pointShadowMap,
            u.pointShadowMatrix.value = r.state.pointShadowMatrix);
            const p = h.getUniforms()
              , f = xf.seqWithValue(p.seq, u);
            return n.currentProgram = h,
            n.uniformsList = f,
            h
        }
        function St(t, e) {
            const i = W.get(t);
            i.outputEncoding = e.outputEncoding,
            i.instancing = e.instancing,
            i.numClippingPlanes = e.numClippingPlanes,
            i.numIntersection = e.numClipIntersection,
            i.vertexAlphas = e.vertexAlphas
        }
        function Tt(t, e, i, n) {
            !0 !== e.isScene && (e = B),
            q.resetTextureUnits();
            const r = e.fog
              , s = i.isMeshStandardMaterial ? e.environment : null
              , a = null === x ? m.outputEncoding : x.texture.encoding
              , o = j.get(i.envMap || s)
              , l = !0 === i.vertexColors && n.geometry && n.geometry.attributes.color && 4 === n.geometry.attributes.color.itemSize
              , c = W.get(i)
              , h = d.state.lights;
            if (!0 === N && (!0 === O || t !== w)) {
                const e = t === w && i.id === _;
                et.setState(i, t, e)
            }
            let u = !1;
            i.version === c.__version ? c.needsLights && c.lightsStateVersion !== h.state.version || c.outputEncoding !== a || n.isInstancedMesh && !1 === c.instancing ? u = !0 : n.isInstancedMesh || !0 !== c.instancing ? c.envMap !== o || i.fog && c.fog !== r ? u = !0 : void 0 === c.numClippingPlanes || c.numClippingPlanes === et.numPlanes && c.numIntersection === et.numIntersection ? c.vertexAlphas !== l && (u = !0) : u = !0 : u = !0 : (u = !0,
            c.__version = i.version);
            let p = c.currentProgram;
            !0 === u && (p = Mt(i, e, n));
            let f = !1
              , g = !1
              , v = !1;
            const y = p.getUniforms()
              , b = c.uniforms;
            if (G.useProgram(p.program) && (f = !0,
            g = !0,
            v = !0),
            i.id !== _ && (_ = i.id,
            g = !0),
            f || w !== t) {
                if (y.setValue(ct, "projectionMatrix", t.projectionMatrix),
                U.logarithmicDepthBuffer && y.setValue(ct, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)),
                w !== t && (w = t,
                g = !0,
                v = !0),
                i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshStandardMaterial || i.envMap) {
                    const e = y.map.cameraPosition;
                    void 0 !== e && e.setValue(ct, k.setFromMatrixPosition(t.matrixWorld))
                }
                (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && y.setValue(ct, "isOrthographic", !0 === t.isOrthographicCamera),
                (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.isShadowMaterial || i.skinning) && y.setValue(ct, "viewMatrix", t.matrixWorldInverse)
            }
            if (i.skinning) {
                y.setOptional(ct, n, "bindMatrix"),
                y.setOptional(ct, n, "bindMatrixInverse");
                const t = n.skeleton;
                if (t) {
                    const e = t.bones;
                    if (U.floatVertexTextures) {
                        if (null === t.boneTexture) {
                            let i = Math.sqrt(4 * e.length);
                            M = i,
                            i = Math.pow(2, Math.ceil(Math.log(M) / Math.LN2)),
                            i = Math.max(i, 4);
                            const n = new Float32Array(i * i * 4);
                            n.set(t.boneMatrices);
                            const r = new qd(n,i,i,Gl,Nl);
                            t.boneMatrices = n,
                            t.boneTexture = r,
                            t.boneTextureSize = i
                        }
                        y.setValue(ct, "boneTexture", t.boneTexture, q),
                        y.setValue(ct, "boneTextureSize", t.boneTextureSize)
                    } else
                        y.setOptional(ct, t, "boneMatrices")
                }
            }
            var M;
            return (g || c.receiveShadow !== n.receiveShadow) && (c.receiveShadow = n.receiveShadow,
            y.setValue(ct, "receiveShadow", n.receiveShadow)),
            g && (y.setValue(ct, "toneMappingExposure", m.toneMappingExposure),
            c.needsLights && function(t, e) {
                t.ambientLightColor.needsUpdate = e,
                t.lightProbe.needsUpdate = e,
                t.directionalLights.needsUpdate = e,
                t.directionalLightShadows.needsUpdate = e,
                t.pointLights.needsUpdate = e,
                t.pointLightShadows.needsUpdate = e,
                t.spotLights.needsUpdate = e,
                t.spotLightShadows.needsUpdate = e,
                t.rectAreaLights.needsUpdate = e,
                t.hemisphereLights.needsUpdate = e
            }(b, v),
            r && i.fog && Q.refreshFogUniforms(b, r),
            Q.refreshMaterialUniforms(b, i, L, E),
            xf.upload(ct, c.uniformsList, b, q)),
            i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (xf.upload(ct, c.uniformsList, b, q),
            i.uniformsNeedUpdate = !1),
            i.isSpriteMaterial && y.setValue(ct, "center", n.center),
            y.setValue(ct, "modelViewMatrix", n.modelViewMatrix),
            y.setValue(ct, "normalMatrix", n.normalMatrix),
            y.setValue(ct, "modelMatrix", n.matrixWorld),
            p
        }
        xt.setAnimationLoop((function(t) {
            gt && gt(t)
        }
        )),
        "undefined" != typeof window && xt.setContext(window),
        this.setAnimationLoop = function(t) {
            gt = t,
            dt.setAnimationLoop(t),
            null === t ? xt.stop() : xt.start()
        }
        ,
        dt.addEventListener("sessionstart", vt),
        dt.addEventListener("sessionend", yt),
        this.render = function(t, e) {
            let i, n;
            if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),
            i = arguments[2]),
            void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),
            n = arguments[3]),
            void 0 !== e && !0 !== e.isCamera)
                return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            if (!0 === g)
                return;
            !0 === t.autoUpdate && t.updateMatrixWorld(),
            null === e.parent && e.updateMatrixWorld(),
            !0 === dt.enabled && !0 === dt.isPresenting && (e = dt.getCamera(e)),
            !0 === t.isScene && t.onBeforeRender(m, t, e, i || x),
            d = tt.get(t, f.length),
            d.init(),
            f.push(d),
            z.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
            D.setFromProjectionMatrix(z),
            O = this.localClippingEnabled,
            N = et.init(this.clippingPlanes, O, e),
            u = K.get(t, p.length),
            u.init(),
            p.push(u),
            _t(t, e, 0, m.sortObjects),
            u.finish(),
            !0 === m.sortObjects && u.sort(A, C),
            !0 === N && et.beginShadows();
            const r = d.state.shadowsArray;
            it.render(r, t, e),
            d.setupLights(),
            d.setupLightsView(e),
            !0 === N && et.endShadows(),
            !0 === this.info.autoReset && this.info.reset(),
            void 0 !== i && this.setRenderTarget(i),
            nt.render(u, t, e, n);
            const s = u.opaque
              , a = u.transparent;
            s.length > 0 && wt(s, t, e),
            a.length > 0 && wt(a, t, e),
            null !== x && (q.updateRenderTargetMipmap(x),
            q.updateMultisampleRenderTarget(x)),
            !0 === t.isScene && t.onAfterRender(m, t, e),
            G.buffers.depth.setTest(!0),
            G.buffers.depth.setMask(!0),
            G.buffers.color.setMask(!0),
            G.setPolygonOffset(!1),
            lt.resetDefaultState(),
            _ = -1,
            w = null,
            f.pop(),
            d = f.length > 0 ? f[f.length - 1] : null,
            p.pop(),
            u = p.length > 0 ? p[p.length - 1] : null
        }
        ,
        this.getActiveCubeFace = function() {
            return v
        }
        ,
        this.getActiveMipmapLevel = function() {
            return y
        }
        ,
        this.getRenderTarget = function() {
            return x
        }
        ,
        this.setRenderTarget = function(t, e=0, i=0) {
            x = t,
            v = e,
            y = i,
            t && void 0 === W.get(t).__webglFramebuffer && q.setupRenderTarget(t);
            let n = null
              , r = !1
              , s = !1;
            if (t) {
                const i = t.texture;
                (i.isDataTexture3D || i.isDataTexture2DArray) && (s = !0);
                const a = W.get(t).__webglFramebuffer;
                t.isWebGLCubeRenderTarget ? (n = a[e],
                r = !0) : n = t.isWebGLMultisampleRenderTarget ? W.get(t).__webglMultisampledFramebuffer : a,
                b.copy(t.viewport),
                M.copy(t.scissor),
                S = t.scissorTest
            } else
                b.copy(P).multiplyScalar(L).floor(),
                M.copy(R).multiplyScalar(L).floor(),
                S = I;
            if (G.bindFramebuffer(36160, n),
            G.viewport(b),
            G.scissor(M),
            G.setScissorTest(S),
            r) {
                const n = W.get(t.texture);
                ct.framebufferTexture2D(36160, 36064, 34069 + e, n.__webglTexture, i)
            } else if (s) {
                const n = W.get(t.texture)
                  , r = e || 0;
                ct.framebufferTextureLayer(36160, 36064, n.__webglTexture, i || 0, r)
            }
        }
        ,
        this.readRenderTargetPixels = function(t, e, i, n, r, s, a) {
            if (!t || !t.isWebGLRenderTarget)
                return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            let o = W.get(t).__webglFramebuffer;
            if (t.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]),
            o) {
                G.bindFramebuffer(36160, o);
                try {
                    const a = t.texture
                      , o = a.format
                      , l = a.type;
                    if (o !== Gl && ot.convert(o) !== ct.getParameter(35739))
                        return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                    const c = l === Ol && (H.has("EXT_color_buffer_half_float") || U.isWebGL2 && H.has("EXT_color_buffer_float"));
                    if (!(l === Al || ot.convert(l) === ct.getParameter(35738) || l === Nl && (U.isWebGL2 || H.has("OES_texture_float") || H.has("WEBGL_color_buffer_float")) || c))
                        return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                    36053 === ct.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - n && i >= 0 && i <= t.height - r && ct.readPixels(e, i, n, r, ot.convert(o), ot.convert(l), s) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                } finally {
                    const t = null !== x ? W.get(x).__webglFramebuffer : null;
                    G.bindFramebuffer(36160, t)
                }
            }
        }
        ,
        this.copyFramebufferToTexture = function(t, e, i=0) {
            const n = Math.pow(2, -i)
              , r = Math.floor(e.image.width * n)
              , s = Math.floor(e.image.height * n)
              , a = ot.convert(e.format);
            q.setTexture2D(e, 0),
            ct.copyTexImage2D(3553, i, a, t.x, t.y, r, s, 0),
            G.unbindTexture()
        }
        ,
        this.copyTextureToTexture = function(t, e, i, n=0) {
            const r = e.image.width
              , s = e.image.height
              , a = ot.convert(i.format)
              , o = ot.convert(i.type);
            q.setTexture2D(i, 0),
            ct.pixelStorei(37440, i.flipY),
            ct.pixelStorei(37441, i.premultiplyAlpha),
            ct.pixelStorei(3317, i.unpackAlignment),
            e.isDataTexture ? ct.texSubImage2D(3553, n, t.x, t.y, r, s, a, o, e.image.data) : e.isCompressedTexture ? ct.compressedTexSubImage2D(3553, n, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, a, e.mipmaps[0].data) : ct.texSubImage2D(3553, n, t.x, t.y, a, o, e.image),
            0 === n && i.generateMipmaps && ct.generateMipmap(3553),
            G.unbindTexture()
        }
        ,
        this.copyTextureToTexture3D = function(t, e, i, n, r=0) {
            if (m.isWebGL1Renderer)
                return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
            const {width: s, height: a, data: o} = i.image
              , l = ot.convert(n.format)
              , c = ot.convert(n.type);
            let h;
            if (n.isDataTexture3D)
                q.setTexture3D(n, 0),
                h = 32879;
            else {
                if (!n.isDataTexture2DArray)
                    return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                q.setTexture2DArray(n, 0),
                h = 35866
            }
            ct.pixelStorei(37440, n.flipY),
            ct.pixelStorei(37441, n.premultiplyAlpha),
            ct.pixelStorei(3317, n.unpackAlignment);
            const u = ct.getParameter(3314)
              , d = ct.getParameter(32878)
              , p = ct.getParameter(3316)
              , f = ct.getParameter(3315)
              , g = ct.getParameter(32877);
            ct.pixelStorei(3314, s),
            ct.pixelStorei(32878, a),
            ct.pixelStorei(3316, t.min.x),
            ct.pixelStorei(3315, t.min.y),
            ct.pixelStorei(32877, t.min.z),
            ct.texSubImage3D(h, r, e.x, e.y, e.z, t.max.x - t.min.x + 1, t.max.y - t.min.y + 1, t.max.z - t.min.z + 1, l, c, o),
            ct.pixelStorei(3314, u),
            ct.pixelStorei(32878, d),
            ct.pixelStorei(3316, p),
            ct.pixelStorei(3315, f),
            ct.pixelStorei(32877, g),
            0 === r && n.generateMipmaps && ct.generateMipmap(h),
            G.unbindTexture()
        }
        ,
        this.initTexture = function(t) {
            q.setTexture2D(t, 0),
            G.unbindTexture()
        }
        ,
        this.resetState = function() {
            v = 0,
            y = 0,
            x = null,
            G.reset(),
            lt.reset()
        }
        ,
        "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    (class extends dm {
    }
    ).prototype.isWebGL1Renderer = !0;
    class pm extends Au {
        constructor() {
            super(),
            this.type = "Scene",
            this.background = null,
            this.environment = null,
            this.fog = null,
            this.overrideMaterial = null,
            this.autoUpdate = !0,
            "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                detail: this
            }))
        }
        copy(t, e) {
            return super.copy(t, e),
            null !== t.background && (this.background = t.background.clone()),
            null !== t.environment && (this.environment = t.environment.clone()),
            null !== t.fog && (this.fog = t.fog.clone()),
            null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()),
            this.autoUpdate = t.autoUpdate,
            this.matrixAutoUpdate = t.matrixAutoUpdate,
            this
        }
        toJSON(t) {
            const e = super.toJSON(t);
            return null !== this.background && (e.object.background = this.background.toJSON(t)),
            null !== this.environment && (e.object.environment = this.environment.toJSON(t)),
            null !== this.fog && (e.object.fog = this.fog.toJSON()),
            e
        }
    }
    pm.prototype.isScene = !0;
    class fm {
        constructor(t, e) {
            this.array = t,
            this.stride = e,
            this.count = void 0 !== t ? t.length / e : 0,
            this.usage = rh,
            this.updateRange = {
                offset: 0,
                count: -1
            },
            this.version = 0,
            this.uuid = uh(),
            this.onUploadCallback = function() {}
        }
        set needsUpdate(t) {
            !0 === t && this.version++
        }
        setUsage(t) {
            return this.usage = t,
            this
        }
        copy(t) {
            return this.array = new t.array.constructor(t.array),
            this.count = t.count,
            this.stride = t.stride,
            this.usage = t.usage,
            this
        }
        copyAt(t, e, i) {
            t *= this.stride,
            i *= e.stride;
            for (let n = 0, r = this.stride; n < r; n++)
                this.array[t + n] = e.array[i + n];
            return this
        }
        set(t, e=0) {
            return this.array.set(t, e),
            this
        }
        clone(t) {
            void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
            void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = uh()),
            void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
            const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid])
              , i = new fm(e,this.stride);
            return i.setUsage(this.usage),
            i
        }
        onUpload(t) {
            return this.onUploadCallback = t,
            this
        }
        toJSON(t) {
            return void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
            void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = uh()),
            void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))),
            {
                uuid: this.uuid,
                buffer: this.array.buffer._uuid,
                type: this.array.constructor.name,
                stride: this.stride
            }
        }
    }
    fm.prototype.isInterleavedBuffer = !0;
    const mm = new Eh;
    class gm {
        constructor(t, e, i, n) {
            this.name = "",
            this.data = t,
            this.itemSize = e,
            this.offset = i,
            this.normalized = !0 === n
        }
        get count() {
            return this.data.count
        }
        get array() {
            return this.data.array
        }
        set needsUpdate(t) {
            this.data.needsUpdate = t
        }
        applyMatrix4(t) {
            for (let e = 0, i = this.data.count; e < i; e++)
                mm.x = this.getX(e),
                mm.y = this.getY(e),
                mm.z = this.getZ(e),
                mm.applyMatrix4(t),
                this.setXYZ(e, mm.x, mm.y, mm.z);
            return this
        }
        applyNormalMatrix(t) {
            for (let e = 0, i = this.count; e < i; e++)
                mm.x = this.getX(e),
                mm.y = this.getY(e),
                mm.z = this.getZ(e),
                mm.applyNormalMatrix(t),
                this.setXYZ(e, mm.x, mm.y, mm.z);
            return this
        }
        transformDirection(t) {
            for (let e = 0, i = this.count; e < i; e++)
                mm.x = this.getX(e),
                mm.y = this.getY(e),
                mm.z = this.getZ(e),
                mm.transformDirection(t),
                this.setXYZ(e, mm.x, mm.y, mm.z);
            return this
        }
        setX(t, e) {
            return this.data.array[t * this.data.stride + this.offset] = e,
            this
        }
        setY(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 1] = e,
            this
        }
        setZ(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 2] = e,
            this
        }
        setW(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 3] = e,
            this
        }
        getX(t) {
            return this.data.array[t * this.data.stride + this.offset]
        }
        getY(t) {
            return this.data.array[t * this.data.stride + this.offset + 1]
        }
        getZ(t) {
            return this.data.array[t * this.data.stride + this.offset + 2]
        }
        getW(t) {
            return this.data.array[t * this.data.stride + this.offset + 3]
        }
        setXY(t, e, i) {
            return t = t * this.data.stride + this.offset,
            this.data.array[t + 0] = e,
            this.data.array[t + 1] = i,
            this
        }
        setXYZ(t, e, i, n) {
            return t = t * this.data.stride + this.offset,
            this.data.array[t + 0] = e,
            this.data.array[t + 1] = i,
            this.data.array[t + 2] = n,
            this
        }
        setXYZW(t, e, i, n, r) {
            return t = t * this.data.stride + this.offset,
            this.data.array[t + 0] = e,
            this.data.array[t + 1] = i,
            this.data.array[t + 2] = n,
            this.data.array[t + 3] = r,
            this
        }
        clone(t) {
            if (void 0 === t) {
                console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
                const t = [];
                for (let e = 0; e < this.count; e++) {
                    const i = e * this.data.stride + this.offset;
                    for (let e = 0; e < this.itemSize; e++)
                        t.push(this.data.array[i + e])
                }
                return new id(new this.array.constructor(t),this.itemSize,this.normalized)
            }
            return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
            void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
            new gm(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
        }
        toJSON(t) {
            if (void 0 === t) {
                console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
                const t = [];
                for (let e = 0; e < this.count; e++) {
                    const i = e * this.data.stride + this.offset;
                    for (let e = 0; e < this.itemSize; e++)
                        t.push(this.data.array[i + e])
                }
                return {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: t,
                    normalized: this.normalized
                }
            }
            return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
            void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
            {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            }
        }
    }
    gm.prototype.isInterleavedBufferAttribute = !0;
    class vm extends qu {
        constructor(t) {
            super(),
            this.type = "SpriteMaterial",
            this.color = new $u(16777215),
            this.map = null,
            this.alphaMap = null,
            this.rotation = 0,
            this.sizeAttenuation = !0,
            this.transparent = !0,
            this.setValues(t)
        }
        copy(t) {
            return super.copy(t),
            this.color.copy(t.color),
            this.map = t.map,
            this.alphaMap = t.alphaMap,
            this.rotation = t.rotation,
            this.sizeAttenuation = t.sizeAttenuation,
            this
        }
    }
    let ym;
    vm.prototype.isSpriteMaterial = !0;
    const xm = new Eh
      , _m = new Eh
      , wm = new Eh
      , bm = new gh
      , Mm = new gh
      , Sm = new nu
      , Tm = new Eh
      , Em = new Eh
      , Lm = new Eh
      , Am = new gh
      , Cm = new gh
      , Pm = new gh;
    function Rm(t, e, i, n, r, s) {
        bm.subVectors(t, i).addScalar(.5).multiply(n),
        void 0 !== r ? (Mm.x = s * bm.x - r * bm.y,
        Mm.y = r * bm.x + s * bm.y) : Mm.copy(bm),
        t.copy(e),
        t.x += Mm.x,
        t.y += Mm.y,
        t.applyMatrix4(Sm)
    }
    (class extends Au {
        constructor(t) {
            if (super(),
            this.type = "Sprite",
            void 0 === ym) {
                ym = new fd;
                const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1])
                  , e = new fm(t,5);
                ym.setIndex([0, 1, 2, 0, 2, 3]),
                ym.setAttribute("position", new gm(e,3,0,!1)),
                ym.setAttribute("uv", new gm(e,2,3,!1))
            }
            this.geometry = ym,
            this.material = void 0 !== t ? t : new vm,
            this.center = new gh(.5,.5)
        }
        raycast(t, e) {
            null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
            _m.setFromMatrixScale(this.matrixWorld),
            Sm.copy(t.camera.matrixWorld),
            this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld),
            wm.setFromMatrixPosition(this.modelViewMatrix),
            t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && _m.multiplyScalar(-wm.z);
            const i = this.material.rotation;
            let n, r;
            0 !== i && (r = Math.cos(i),
            n = Math.sin(i));
            const s = this.center;
            Rm(Tm.set(-.5, -.5, 0), wm, s, _m, n, r),
            Rm(Em.set(.5, -.5, 0), wm, s, _m, n, r),
            Rm(Lm.set(.5, .5, 0), wm, s, _m, n, r),
            Am.set(0, 0),
            Cm.set(1, 0),
            Pm.set(1, 1);
            let a = t.ray.intersectTriangle(Tm, Em, Lm, !1, xm);
            if (null === a && (Rm(Em.set(-.5, .5, 0), wm, s, _m, n, r),
            Cm.set(0, 1),
            a = t.ray.intersectTriangle(Tm, Lm, Em, !1, xm),
            null === a))
                return;
            const o = t.ray.origin.distanceTo(xm);
            o < t.near || o > t.far || e.push({
                distance: o,
                point: xm.clone(),
                uv: Vu.getUV(xm, Tm, Em, Lm, Am, Cm, Pm, new gh),
                face: null,
                object: this
            })
        }
        copy(t) {
            return super.copy(t),
            void 0 !== t.center && this.center.copy(t.center),
            this.material = t.material,
            this
        }
    }
    ).prototype.isSprite = !0;
    const Im = new Eh
      , Dm = new Mh
      , Nm = new Mh
      , Om = new Eh
      , zm = new nu;
    class km extends Id {
        constructor(t, e) {
            super(t, e),
            this.type = "SkinnedMesh",
            this.bindMode = "attached",
            this.bindMatrix = new nu,
            this.bindMatrixInverse = new nu
        }
        copy(t) {
            return super.copy(t),
            this.bindMode = t.bindMode,
            this.bindMatrix.copy(t.bindMatrix),
            this.bindMatrixInverse.copy(t.bindMatrixInverse),
            this.skeleton = t.skeleton,
            this
        }
        bind(t, e) {
            this.skeleton = t,
            void 0 === e && (this.updateMatrixWorld(!0),
            this.skeleton.calculateInverses(),
            e = this.matrixWorld),
            this.bindMatrix.copy(e),
            this.bindMatrixInverse.copy(e).invert()
        }
        pose() {
            this.skeleton.pose()
        }
        normalizeSkinWeights() {
            const t = new Mh
              , e = this.geometry.attributes.skinWeight;
            for (let i = 0, n = e.count; i < n; i++) {
                t.x = e.getX(i),
                t.y = e.getY(i),
                t.z = e.getZ(i),
                t.w = e.getW(i);
                const n = 1 / t.manhattanLength();
                n !== 1 / 0 ? t.multiplyScalar(n) : t.set(1, 0, 0, 0),
                e.setXYZW(i, t.x, t.y, t.z, t.w)
            }
        }
        updateMatrixWorld(t) {
            super.updateMatrixWorld(t),
            "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
        }
        boneTransform(t, e) {
            const i = this.skeleton
              , n = this.geometry;
            Dm.fromBufferAttribute(n.attributes.skinIndex, t),
            Nm.fromBufferAttribute(n.attributes.skinWeight, t),
            Im.fromBufferAttribute(n.attributes.position, t).applyMatrix4(this.bindMatrix),
            e.set(0, 0, 0);
            for (let t = 0; t < 4; t++) {
                const n = Nm.getComponent(t);
                if (0 !== n) {
                    const r = Dm.getComponent(t);
                    zm.multiplyMatrices(i.bones[r].matrixWorld, i.boneInverses[r]),
                    e.addScaledVector(Om.copy(Im).applyMatrix4(zm), n)
                }
            }
            return e.applyMatrix4(this.bindMatrixInverse)
        }
    }
    km.prototype.isSkinnedMesh = !0;
    (class extends Au {
        constructor() {
            super(),
            this.type = "Bone"
        }
    }
    ).prototype.isBone = !0;
    const Bm = new nu
      , Fm = new nu
      , Hm = []
      , Um = new Id;
    (class extends Id {
        constructor(t, e, i) {
            super(t, e),
            this.instanceMatrix = new id(new Float32Array(16 * i),16),
            this.instanceColor = null,
            this.count = i,
            this.frustumCulled = !1
        }
        copy(t) {
            return super.copy(t),
            this.instanceMatrix.copy(t.instanceMatrix),
            null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()),
            this.count = t.count,
            this
        }
        getColorAt(t, e) {
            e.fromArray(this.instanceColor.array, 3 * t)
        }
        getMatrixAt(t, e) {
            e.fromArray(this.instanceMatrix.array, 16 * t)
        }
        raycast(t, e) {
            const i = this.matrixWorld
              , n = this.count;
            if (Um.geometry = this.geometry,
            Um.material = this.material,
            void 0 !== Um.material)
                for (let r = 0; r < n; r++) {
                    this.getMatrixAt(r, Bm),
                    Fm.multiplyMatrices(i, Bm),
                    Um.matrixWorld = Fm,
                    Um.raycast(t, Hm);
                    for (let t = 0, i = Hm.length; t < i; t++) {
                        const i = Hm[t];
                        i.instanceId = r,
                        i.object = this,
                        e.push(i)
                    }
                    Hm.length = 0
                }
        }
        setColorAt(t, e) {
            null === this.instanceColor && (this.instanceColor = new id(new Float32Array(3 * this.count),3)),
            e.toArray(this.instanceColor.array, 3 * t)
        }
        setMatrixAt(t, e) {
            e.toArray(this.instanceMatrix.array, 16 * t)
        }
        updateMorphTargets() {}
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }
    ).prototype.isInstancedMesh = !0;
    class Gm extends qu {
        constructor(t) {
            super(),
            this.type = "LineBasicMaterial",
            this.color = new $u(16777215),
            this.linewidth = 1,
            this.linecap = "round",
            this.linejoin = "round",
            this.morphTargets = !1,
            this.setValues(t)
        }
        copy(t) {
            return super.copy(t),
            this.color.copy(t.color),
            this.linewidth = t.linewidth,
            this.linecap = t.linecap,
            this.linejoin = t.linejoin,
            this.morphTargets = t.morphTargets,
            this
        }
    }
    Gm.prototype.isLineBasicMaterial = !0;
    const Vm = new Eh
      , Wm = new Eh
      , qm = new nu
      , jm = new iu
      , Ym = new Xh;
    class Xm extends Au {
        constructor(t=new fd, e=new Gm) {
            super(),
            this.type = "Line",
            this.geometry = t,
            this.material = e,
            this.updateMorphTargets()
        }
        copy(t) {
            return super.copy(t),
            this.material = t.material,
            this.geometry = t.geometry,
            this
        }
        computeLineDistances() {
            const t = this.geometry;
            if (t.isBufferGeometry)
                if (null === t.index) {
                    const e = t.attributes.position
                      , i = [0];
                    for (let t = 1, n = e.count; t < n; t++)
                        Vm.fromBufferAttribute(e, t - 1),
                        Wm.fromBufferAttribute(e, t),
                        i[t] = i[t - 1],
                        i[t] += Vm.distanceTo(Wm);
                    t.setAttribute("lineDistance", new sd(i,1))
                } else
                    console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            else
                t.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
            return this
        }
        raycast(t, e) {
            const i = this.geometry
              , n = this.matrixWorld
              , r = t.params.Line.threshold
              , s = i.drawRange;
            if (null === i.boundingSphere && i.computeBoundingSphere(),
            Ym.copy(i.boundingSphere),
            Ym.applyMatrix4(n),
            Ym.radius += r,
            !1 === t.ray.intersectsSphere(Ym))
                return;
            qm.copy(n).invert(),
            jm.copy(t.ray).applyMatrix4(qm);
            const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
              , o = a * a
              , l = new Eh
              , c = new Eh
              , h = new Eh
              , u = new Eh
              , d = this.isLineSegments ? 2 : 1;
            if (i.isBufferGeometry) {
                const n = i.index
                  , r = i.attributes.position;
                if (null !== n) {
                    for (let i = Math.max(0, s.start), a = Math.min(n.count, s.start + s.count) - 1; i < a; i += d) {
                        const s = n.getX(i)
                          , a = n.getX(i + 1);
                        l.fromBufferAttribute(r, s),
                        c.fromBufferAttribute(r, a);
                        if (jm.distanceSqToSegment(l, c, u, h) > o)
                            continue;
                        u.applyMatrix4(this.matrixWorld);
                        const d = t.ray.origin.distanceTo(u);
                        d < t.near || d > t.far || e.push({
                            distance: d,
                            point: h.clone().applyMatrix4(this.matrixWorld),
                            index: i,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
                } else {
                    for (let i = Math.max(0, s.start), n = Math.min(r.count, s.start + s.count) - 1; i < n; i += d) {
                        l.fromBufferAttribute(r, i),
                        c.fromBufferAttribute(r, i + 1);
                        if (jm.distanceSqToSegment(l, c, u, h) > o)
                            continue;
                        u.applyMatrix4(this.matrixWorld);
                        const n = t.ray.origin.distanceTo(u);
                        n < t.near || n > t.far || e.push({
                            distance: n,
                            point: h.clone().applyMatrix4(this.matrixWorld),
                            index: i,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
                }
            } else
                i.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
        }
        updateMorphTargets() {
            const t = this.geometry;
            if (t.isBufferGeometry) {
                const e = t.morphAttributes
                  , i = Object.keys(e);
                if (i.length > 0) {
                    const t = e[i[0]];
                    if (void 0 !== t) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let e = 0, i = t.length; e < i; e++) {
                            const i = t[e].name || String(e);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[i] = e
                        }
                    }
                }
            } else {
                const e = t.morphTargets;
                void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        }
    }
    Xm.prototype.isLine = !0;
    const Jm = new Eh
      , Zm = new Eh;
    class Qm extends Xm {
        constructor(t, e) {
            super(t, e),
            this.type = "LineSegments"
        }
        computeLineDistances() {
            const t = this.geometry;
            if (t.isBufferGeometry)
                if (null === t.index) {
                    const e = t.attributes.position
                      , i = [];
                    for (let t = 0, n = e.count; t < n; t += 2)
                        Jm.fromBufferAttribute(e, t),
                        Zm.fromBufferAttribute(e, t + 1),
                        i[t] = 0 === t ? 0 : i[t - 1],
                        i[t + 1] = i[t] + Jm.distanceTo(Zm);
                    t.setAttribute("lineDistance", new sd(i,1))
                } else
                    console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            else
                t.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
            return this
        }
    }
    Qm.prototype.isLineSegments = !0;
    (class extends Xm {
        constructor(t, e) {
            super(t, e),
            this.type = "LineLoop"
        }
    }
    ).prototype.isLineLoop = !0;
    class $m extends qu {
        constructor(t) {
            super(),
            this.type = "PointsMaterial",
            this.color = new $u(16777215),
            this.map = null,
            this.alphaMap = null,
            this.size = 1,
            this.sizeAttenuation = !0,
            this.morphTargets = !1,
            this.setValues(t)
        }
        copy(t) {
            return super.copy(t),
            this.color.copy(t.color),
            this.map = t.map,
            this.alphaMap = t.alphaMap,
            this.size = t.size,
            this.sizeAttenuation = t.sizeAttenuation,
            this.morphTargets = t.morphTargets,
            this
        }
    }
    $m.prototype.isPointsMaterial = !0;
    const Km = new nu
      , tg = new iu
      , eg = new Xh
      , ig = new Eh;
    function ng(t, e, i, n, r, s, a) {
        const o = tg.distanceSqToPoint(t);
        if (o < i) {
            const i = new Eh;
            tg.closestPointToPoint(t, i),
            i.applyMatrix4(n);
            const l = r.ray.origin.distanceTo(i);
            if (l < r.near || l > r.far)
                return;
            s.push({
                distance: l,
                distanceToRay: Math.sqrt(o),
                point: i,
                index: e,
                face: null,
                object: a
            })
        }
    }
    (class extends Au {
        constructor(t=new fd, e=new $m) {
            super(),
            this.type = "Points",
            this.geometry = t,
            this.material = e,
            this.updateMorphTargets()
        }
        copy(t) {
            return super.copy(t),
            this.material = t.material,
            this.geometry = t.geometry,
            this
        }
        raycast(t, e) {
            const i = this.geometry
              , n = this.matrixWorld
              , r = t.params.Points.threshold
              , s = i.drawRange;
            if (null === i.boundingSphere && i.computeBoundingSphere(),
            eg.copy(i.boundingSphere),
            eg.applyMatrix4(n),
            eg.radius += r,
            !1 === t.ray.intersectsSphere(eg))
                return;
            Km.copy(n).invert(),
            tg.copy(t.ray).applyMatrix4(Km);
            const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
              , o = a * a;
            if (i.isBufferGeometry) {
                const r = i.index
                  , a = i.attributes.position;
                if (null !== r) {
                    for (let i = Math.max(0, s.start), l = Math.min(r.count, s.start + s.count); i < l; i++) {
                        const s = r.getX(i);
                        ig.fromBufferAttribute(a, s),
                        ng(ig, s, o, n, t, e, this)
                    }
                } else {
                    for (let i = Math.max(0, s.start), r = Math.min(a.count, s.start + s.count); i < r; i++)
                        ig.fromBufferAttribute(a, i),
                        ng(ig, i, o, n, t, e, this)
                }
            } else
                console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
        }
        updateMorphTargets() {
            const t = this.geometry;
            if (t.isBufferGeometry) {
                const e = t.morphAttributes
                  , i = Object.keys(e);
                if (i.length > 0) {
                    const t = e[i[0]];
                    if (void 0 !== t) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let e = 0, i = t.length; e < i; e++) {
                            const i = t[e].name || String(e);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[i] = e
                        }
                    }
                }
            } else {
                const e = t.morphTargets;
                void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        }
    }
    ).prototype.isPoints = !0;
    (class extends wh {
        constructor(t, e, i, n, r, s, a, o, l) {
            super(t, e, i, n, r, s, a, o, l),
            this.format = void 0 !== a ? a : Ul,
            this.minFilter = void 0 !== s ? s : Tl,
            this.magFilter = void 0 !== r ? r : Tl,
            this.generateMipmaps = !1;
            const c = this;
            "requestVideoFrameCallback"in t && t.requestVideoFrameCallback((function e() {
                c.needsUpdate = !0,
                t.requestVideoFrameCallback(e)
            }
            ))
        }
        clone() {
            return new this.constructor(this.image).copy(this)
        }
        update() {
            const t = this.image;
            !1 === "requestVideoFrameCallback"in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
        }
    }
    ).prototype.isVideoTexture = !0;
    (class extends wh {
        constructor(t, e, i, n, r, s, a, o, l, c, h, u) {
            super(null, s, a, o, l, c, n, r, h, u),
            this.image = {
                width: e,
                height: i
            },
            this.mipmaps = t,
            this.flipY = !1,
            this.generateMipmaps = !1
        }
    }
    ).prototype.isCompressedTexture = !0;
    (class extends wh {
        constructor(t, e, i, n, r, s, a, o, l) {
            super(t, e, i, n, r, s, a, o, l),
            this.needsUpdate = !0
        }
    }
    ).prototype.isCanvasTexture = !0;
    (class extends wh {
        constructor(t, e, i, n, r, s, a, o, l, c) {
            if ((c = void 0 !== c ? c : ql) !== ql && c !== jl)
                throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
            void 0 === i && c === ql && (i = Rl),
            void 0 === i && c === jl && (i = Fl),
            super(null, n, r, s, a, o, c, i, l),
            this.image = {
                width: t,
                height: e
            },
            this.magFilter = void 0 !== a ? a : bl,
            this.minFilter = void 0 !== o ? o : bl,
            this.flipY = !1,
            this.generateMipmaps = !1
        }
    }
    ).prototype.isDepthTexture = !0;
    const rg = function(t, e, i) {
        i = i || 2;
        const n = e && e.length
          , r = n ? e[0] * i : t.length;
        let s = sg(t, 0, r, i, !0);
        const a = [];
        if (!s || s.next === s.prev)
            return a;
        let o, l, c, h, u, d, p;
        if (n && (s = function(t, e, i, n) {
            const r = [];
            let s, a, o, l, c;
            for (s = 0,
            a = e.length; s < a; s++)
                o = e[s] * n,
                l = s < a - 1 ? e[s + 1] * n : t.length,
                c = sg(t, o, l, n, !1),
                c === c.next && (c.steiner = !0),
                r.push(gg(c));
            for (r.sort(dg),
            s = 0; s < r.length; s++)
                pg(r[s], i),
                i = ag(i, i.next);
            return i
        }(t, e, s, i)),
        t.length > 80 * i) {
            o = c = t[0],
            l = h = t[1];
            for (let e = i; e < r; e += i)
                u = t[e],
                d = t[e + 1],
                u < o && (o = u),
                d < l && (l = d),
                u > c && (c = u),
                d > h && (h = d);
            p = Math.max(c - o, h - l),
            p = 0 !== p ? 1 / p : 0
        }
        return og(s, a, i, o, l, p),
        a
    };
    function sg(t, e, i, n, r) {
        let s, a;
        if (r === function(t, e, i, n) {
            let r = 0;
            for (let s = e, a = i - n; s < i; s += n)
                r += (t[a] - t[s]) * (t[s + 1] + t[a + 1]),
                a = s;
            return r
        }(t, e, i, n) > 0)
            for (s = e; s < i; s += n)
                a = Eg(s, t[s], t[s + 1], a);
        else
            for (s = i - n; s >= e; s -= n)
                a = Eg(s, t[s], t[s + 1], a);
        return a && _g(a, a.next) && (Lg(a),
        a = a.next),
        a
    }
    function ag(t, e) {
        if (!t)
            return t;
        e || (e = t);
        let i, n = t;
        do {
            if (i = !1,
            n.steiner || !_g(n, n.next) && 0 !== xg(n.prev, n, n.next))
                n = n.next;
            else {
                if (Lg(n),
                n = e = n.prev,
                n === n.next)
                    break;
                i = !0
            }
        } while (i || n !== e);
        return e
    }
    function og(t, e, i, n, r, s, a) {
        if (!t)
            return;
        !a && s && function(t, e, i, n) {
            let r = t;
            do {
                null === r.z && (r.z = mg(r.x, r.y, e, i, n)),
                r.prevZ = r.prev,
                r.nextZ = r.next,
                r = r.next
            } while (r !== t);
            r.prevZ.nextZ = null,
            r.prevZ = null,
            function(t) {
                let e, i, n, r, s, a, o, l, c = 1;
                do {
                    for (i = t,
                    t = null,
                    s = null,
                    a = 0; i; ) {
                        for (a++,
                        n = i,
                        o = 0,
                        e = 0; e < c && (o++,
                        n = n.nextZ,
                        n); e++)
                            ;
                        for (l = c; o > 0 || l > 0 && n; )
                            0 !== o && (0 === l || !n || i.z <= n.z) ? (r = i,
                            i = i.nextZ,
                            o--) : (r = n,
                            n = n.nextZ,
                            l--),
                            s ? s.nextZ = r : t = r,
                            r.prevZ = s,
                            s = r;
                        i = n
                    }
                    s.nextZ = null,
                    c *= 2
                } while (a > 1)
            }(r)
        }(t, n, r, s);
        let o, l, c = t;
        for (; t.prev !== t.next; )
            if (o = t.prev,
            l = t.next,
            s ? cg(t, n, r, s) : lg(t))
                e.push(o.i / i),
                e.push(t.i / i),
                e.push(l.i / i),
                Lg(t),
                t = l.next,
                c = l.next;
            else if ((t = l) === c) {
                a ? 1 === a ? og(t = hg(ag(t), e, i), e, i, n, r, s, 2) : 2 === a && ug(t, e, i, n, r, s) : og(ag(t), e, i, n, r, s, 1);
                break
            }
    }
    function lg(t) {
        const e = t.prev
          , i = t
          , n = t.next;
        if (xg(e, i, n) >= 0)
            return !1;
        let r = t.next.next;
        for (; r !== t.prev; ) {
            if (vg(e.x, e.y, i.x, i.y, n.x, n.y, r.x, r.y) && xg(r.prev, r, r.next) >= 0)
                return !1;
            r = r.next
        }
        return !0
    }
    function cg(t, e, i, n) {
        const r = t.prev
          , s = t
          , a = t.next;
        if (xg(r, s, a) >= 0)
            return !1;
        const o = r.x < s.x ? r.x < a.x ? r.x : a.x : s.x < a.x ? s.x : a.x
          , l = r.y < s.y ? r.y < a.y ? r.y : a.y : s.y < a.y ? s.y : a.y
          , c = r.x > s.x ? r.x > a.x ? r.x : a.x : s.x > a.x ? s.x : a.x
          , h = r.y > s.y ? r.y > a.y ? r.y : a.y : s.y > a.y ? s.y : a.y
          , u = mg(o, l, e, i, n)
          , d = mg(c, h, e, i, n);
        let p = t.prevZ
          , f = t.nextZ;
        for (; p && p.z >= u && f && f.z <= d; ) {
            if (p !== t.prev && p !== t.next && vg(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) && xg(p.prev, p, p.next) >= 0)
                return !1;
            if (p = p.prevZ,
            f !== t.prev && f !== t.next && vg(r.x, r.y, s.x, s.y, a.x, a.y, f.x, f.y) && xg(f.prev, f, f.next) >= 0)
                return !1;
            f = f.nextZ
        }
        for (; p && p.z >= u; ) {
            if (p !== t.prev && p !== t.next && vg(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) && xg(p.prev, p, p.next) >= 0)
                return !1;
            p = p.prevZ
        }
        for (; f && f.z <= d; ) {
            if (f !== t.prev && f !== t.next && vg(r.x, r.y, s.x, s.y, a.x, a.y, f.x, f.y) && xg(f.prev, f, f.next) >= 0)
                return !1;
            f = f.nextZ
        }
        return !0
    }
    function hg(t, e, i) {
        let n = t;
        do {
            const r = n.prev
              , s = n.next.next;
            !_g(r, s) && wg(r, n, n.next, s) && Sg(r, s) && Sg(s, r) && (e.push(r.i / i),
            e.push(n.i / i),
            e.push(s.i / i),
            Lg(n),
            Lg(n.next),
            n = t = s),
            n = n.next
        } while (n !== t);
        return ag(n)
    }
    function ug(t, e, i, n, r, s) {
        let a = t;
        do {
            let t = a.next.next;
            for (; t !== a.prev; ) {
                if (a.i !== t.i && yg(a, t)) {
                    let o = Tg(a, t);
                    return a = ag(a, a.next),
                    o = ag(o, o.next),
                    og(a, e, i, n, r, s),
                    void og(o, e, i, n, r, s)
                }
                t = t.next
            }
            a = a.next
        } while (a !== t)
    }
    function dg(t, e) {
        return t.x - e.x
    }
    function pg(t, e) {
        if (e = function(t, e) {
            let i = e;
            const n = t.x
              , r = t.y;
            let s, a = -1 / 0;
            do {
                if (r <= i.y && r >= i.next.y && i.next.y !== i.y) {
                    const t = i.x + (r - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
                    if (t <= n && t > a) {
                        if (a = t,
                        t === n) {
                            if (r === i.y)
                                return i;
                            if (r === i.next.y)
                                return i.next
                        }
                        s = i.x < i.next.x ? i : i.next
                    }
                }
                i = i.next
            } while (i !== e);
            if (!s)
                return null;
            if (n === a)
                return s;
            const o = s
              , l = s.x
              , c = s.y;
            let h, u = 1 / 0;
            i = s;
            do {
                n >= i.x && i.x >= l && n !== i.x && vg(r < c ? n : a, r, l, c, r < c ? a : n, r, i.x, i.y) && (h = Math.abs(r - i.y) / (n - i.x),
                Sg(i, t) && (h < u || h === u && (i.x > s.x || i.x === s.x && fg(s, i))) && (s = i,
                u = h)),
                i = i.next
            } while (i !== o);
            return s
        }(t, e),
        e) {
            const i = Tg(e, t);
            ag(e, e.next),
            ag(i, i.next)
        }
    }
    function fg(t, e) {
        return xg(t.prev, t, e.prev) < 0 && xg(e.next, t, t.next) < 0
    }
    function mg(t, e, i, n, r) {
        return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
    }
    function gg(t) {
        let e = t
          , i = t;
        do {
            (e.x < i.x || e.x === i.x && e.y < i.y) && (i = e),
            e = e.next
        } while (e !== t);
        return i
    }
    function vg(t, e, i, n, r, s, a, o) {
        return (r - a) * (e - o) - (t - a) * (s - o) >= 0 && (t - a) * (n - o) - (i - a) * (e - o) >= 0 && (i - a) * (s - o) - (r - a) * (n - o) >= 0
    }
    function yg(t, e) {
        return t.next.i !== e.i && t.prev.i !== e.i && !function(t, e) {
            let i = t;
            do {
                if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && wg(i, i.next, t, e))
                    return !0;
                i = i.next
            } while (i !== t);
            return !1
        }(t, e) && (Sg(t, e) && Sg(e, t) && function(t, e) {
            let i = t
              , n = !1;
            const r = (t.x + e.x) / 2
              , s = (t.y + e.y) / 2;
            do {
                i.y > s != i.next.y > s && i.next.y !== i.y && r < (i.next.x - i.x) * (s - i.y) / (i.next.y - i.y) + i.x && (n = !n),
                i = i.next
            } while (i !== t);
            return n
        }(t, e) && (xg(t.prev, t, e.prev) || xg(t, e.prev, e)) || _g(t, e) && xg(t.prev, t, t.next) > 0 && xg(e.prev, e, e.next) > 0)
    }
    function xg(t, e, i) {
        return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
    }
    function _g(t, e) {
        return t.x === e.x && t.y === e.y
    }
    function wg(t, e, i, n) {
        const r = Mg(xg(t, e, i))
          , s = Mg(xg(t, e, n))
          , a = Mg(xg(i, n, t))
          , o = Mg(xg(i, n, e));
        return r !== s && a !== o || (!(0 !== r || !bg(t, i, e)) || (!(0 !== s || !bg(t, n, e)) || (!(0 !== a || !bg(i, t, n)) || !(0 !== o || !bg(i, e, n)))))
    }
    function bg(t, e, i) {
        return e.x <= Math.max(t.x, i.x) && e.x >= Math.min(t.x, i.x) && e.y <= Math.max(t.y, i.y) && e.y >= Math.min(t.y, i.y)
    }
    function Mg(t) {
        return t > 0 ? 1 : t < 0 ? -1 : 0
    }
    function Sg(t, e) {
        return xg(t.prev, t, t.next) < 0 ? xg(t, e, t.next) >= 0 && xg(t, t.prev, e) >= 0 : xg(t, e, t.prev) < 0 || xg(t, t.next, e) < 0
    }
    function Tg(t, e) {
        const i = new Ag(t.i,t.x,t.y)
          , n = new Ag(e.i,e.x,e.y)
          , r = t.next
          , s = e.prev;
        return t.next = e,
        e.prev = t,
        i.next = r,
        r.prev = i,
        n.next = i,
        i.prev = n,
        s.next = n,
        n.prev = s,
        n
    }
    function Eg(t, e, i, n) {
        const r = new Ag(t,e,i);
        return n ? (r.next = n.next,
        r.prev = n,
        n.next.prev = r,
        n.next = r) : (r.prev = r,
        r.next = r),
        r
    }
    function Lg(t) {
        t.next.prev = t.prev,
        t.prev.next = t.next,
        t.prevZ && (t.prevZ.nextZ = t.nextZ),
        t.nextZ && (t.nextZ.prevZ = t.prevZ)
    }
    function Ag(t, e, i) {
        this.i = t,
        this.x = e,
        this.y = i,
        this.prev = null,
        this.next = null,
        this.z = null,
        this.prevZ = null,
        this.nextZ = null,
        this.steiner = !1
    }
    class Cg {
        static area(t) {
            const e = t.length;
            let i = 0;
            for (let n = e - 1, r = 0; r < e; n = r++)
                i += t[n].x * t[r].y - t[r].x * t[n].y;
            return .5 * i
        }
        static isClockWise(t) {
            return Cg.area(t) < 0
        }
        static triangulateShape(t, e) {
            const i = []
              , n = []
              , r = [];
            Pg(t),
            Rg(i, t);
            let s = t.length;
            e.forEach(Pg);
            for (let t = 0; t < e.length; t++)
                n.push(s),
                s += e[t].length,
                Rg(i, e[t]);
            const a = rg(i, n);
            for (let t = 0; t < a.length; t += 3)
                r.push(a.slice(t, t + 3));
            return r
        }
    }
    function Pg(t) {
        const e = t.length;
        e > 2 && t[e - 1].equals(t[0]) && t.pop()
    }
    function Rg(t, e) {
        for (let i = 0; i < e.length; i++)
            t.push(e[i].x),
            t.push(e[i].y)
    }
    class Ig extends fd {
        constructor(t, e) {
            super(),
            this.type = "ExtrudeGeometry",
            this.parameters = {
                shapes: t,
                options: e
            },
            t = Array.isArray(t) ? t : [t];
            const i = this
              , n = []
              , r = [];
            for (let e = 0, i = t.length; e < i; e++) {
                s(t[e])
            }
            function s(t) {
                const s = []
                  , a = void 0 !== e.curveSegments ? e.curveSegments : 12
                  , o = void 0 !== e.steps ? e.steps : 1;
                let l = void 0 !== e.depth ? e.depth : 100
                  , c = void 0 === e.bevelEnabled || e.bevelEnabled
                  , h = void 0 !== e.bevelThickness ? e.bevelThickness : 6
                  , u = void 0 !== e.bevelSize ? e.bevelSize : h - 2
                  , d = void 0 !== e.bevelOffset ? e.bevelOffset : 0
                  , p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
                const f = e.extrudePath
                  , m = void 0 !== e.UVGenerator ? e.UVGenerator : Dg;
                void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),
                l = e.amount);
                let g, v, y, x, _, w = !1;
                f && (g = f.getSpacedPoints(o),
                w = !0,
                c = !1,
                v = f.computeFrenetFrames(o, !1),
                y = new Eh,
                x = new Eh,
                _ = new Eh),
                c || (p = 0,
                h = 0,
                u = 0,
                d = 0);
                const b = t.extractPoints(a);
                let M = b.shape;
                const S = b.holes;
                if (!Cg.isClockWise(M)) {
                    M = M.reverse();
                    for (let t = 0, e = S.length; t < e; t++) {
                        const e = S[t];
                        Cg.isClockWise(e) && (S[t] = e.reverse())
                    }
                }
                const T = Cg.triangulateShape(M, S)
                  , E = M;
                for (let t = 0, e = S.length; t < e; t++) {
                    const e = S[t];
                    M = M.concat(e)
                }
                function L(t, e, i) {
                    return e || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                    e.clone().multiplyScalar(i).add(t)
                }
                const A = M.length
                  , C = T.length;
                function P(t, e, i) {
                    let n, r, s;
                    const a = t.x - e.x
                      , o = t.y - e.y
                      , l = i.x - t.x
                      , c = i.y - t.y
                      , h = a * a + o * o
                      , u = a * c - o * l;
                    if (Math.abs(u) > Number.EPSILON) {
                        const u = Math.sqrt(h)
                          , d = Math.sqrt(l * l + c * c)
                          , p = e.x - o / u
                          , f = e.y + a / u
                          , m = ((i.x - c / d - p) * c - (i.y + l / d - f) * l) / (a * c - o * l);
                        n = p + a * m - t.x,
                        r = f + o * m - t.y;
                        const g = n * n + r * r;
                        if (g <= 2)
                            return new gh(n,r);
                        s = Math.sqrt(g / 2)
                    } else {
                        let t = !1;
                        a > Number.EPSILON ? l > Number.EPSILON && (t = !0) : a < -Number.EPSILON ? l < -Number.EPSILON && (t = !0) : Math.sign(o) === Math.sign(c) && (t = !0),
                        t ? (n = -o,
                        r = a,
                        s = Math.sqrt(h)) : (n = a,
                        r = o,
                        s = Math.sqrt(h / 2))
                    }
                    return new gh(n / s,r / s)
                }
                const R = [];
                for (let t = 0, e = E.length, i = e - 1, n = t + 1; t < e; t++,
                i++,
                n++)
                    i === e && (i = 0),
                    n === e && (n = 0),
                    R[t] = P(E[t], E[i], E[n]);
                const I = [];
                let D, N = R.concat();
                for (let t = 0, e = S.length; t < e; t++) {
                    const e = S[t];
                    D = [];
                    for (let t = 0, i = e.length, n = i - 1, r = t + 1; t < i; t++,
                    n++,
                    r++)
                        n === i && (n = 0),
                        r === i && (r = 0),
                        D[t] = P(e[t], e[n], e[r]);
                    I.push(D),
                    N = N.concat(D)
                }
                for (let t = 0; t < p; t++) {
                    const e = t / p
                      , i = h * Math.cos(e * Math.PI / 2)
                      , n = u * Math.sin(e * Math.PI / 2) + d;
                    for (let t = 0, e = E.length; t < e; t++) {
                        const e = L(E[t], R[t], n);
                        k(e.x, e.y, -i)
                    }
                    for (let t = 0, e = S.length; t < e; t++) {
                        const e = S[t];
                        D = I[t];
                        for (let t = 0, r = e.length; t < r; t++) {
                            const r = L(e[t], D[t], n);
                            k(r.x, r.y, -i)
                        }
                    }
                }
                const O = u + d;
                for (let t = 0; t < A; t++) {
                    const e = c ? L(M[t], N[t], O) : M[t];
                    w ? (x.copy(v.normals[0]).multiplyScalar(e.x),
                    y.copy(v.binormals[0]).multiplyScalar(e.y),
                    _.copy(g[0]).add(x).add(y),
                    k(_.x, _.y, _.z)) : k(e.x, e.y, 0)
                }
                for (let t = 1; t <= o; t++)
                    for (let e = 0; e < A; e++) {
                        const i = c ? L(M[e], N[e], O) : M[e];
                        w ? (x.copy(v.normals[t]).multiplyScalar(i.x),
                        y.copy(v.binormals[t]).multiplyScalar(i.y),
                        _.copy(g[t]).add(x).add(y),
                        k(_.x, _.y, _.z)) : k(i.x, i.y, l / o * t)
                    }
                for (let t = p - 1; t >= 0; t--) {
                    const e = t / p
                      , i = h * Math.cos(e * Math.PI / 2)
                      , n = u * Math.sin(e * Math.PI / 2) + d;
                    for (let t = 0, e = E.length; t < e; t++) {
                        const e = L(E[t], R[t], n);
                        k(e.x, e.y, l + i)
                    }
                    for (let t = 0, e = S.length; t < e; t++) {
                        const e = S[t];
                        D = I[t];
                        for (let t = 0, r = e.length; t < r; t++) {
                            const r = L(e[t], D[t], n);
                            w ? k(r.x, r.y + g[o - 1].y, g[o - 1].x + i) : k(r.x, r.y, l + i)
                        }
                    }
                }
                function z(t, e) {
                    let i = t.length;
                    for (; --i >= 0; ) {
                        const n = i;
                        let r = i - 1;
                        r < 0 && (r = t.length - 1);
                        for (let t = 0, i = o + 2 * p; t < i; t++) {
                            const i = A * t
                              , s = A * (t + 1);
                            F(e + n + i, e + r + i, e + r + s, e + n + s)
                        }
                    }
                }
                function k(t, e, i) {
                    s.push(t),
                    s.push(e),
                    s.push(i)
                }
                function B(t, e, r) {
                    H(t),
                    H(e),
                    H(r);
                    const s = n.length / 3
                      , a = m.generateTopUV(i, n, s - 3, s - 2, s - 1);
                    U(a[0]),
                    U(a[1]),
                    U(a[2])
                }
                function F(t, e, r, s) {
                    H(t),
                    H(e),
                    H(s),
                    H(e),
                    H(r),
                    H(s);
                    const a = n.length / 3
                      , o = m.generateSideWallUV(i, n, a - 6, a - 3, a - 2, a - 1);
                    U(o[0]),
                    U(o[1]),
                    U(o[3]),
                    U(o[1]),
                    U(o[2]),
                    U(o[3])
                }
                function H(t) {
                    n.push(s[3 * t + 0]),
                    n.push(s[3 * t + 1]),
                    n.push(s[3 * t + 2])
                }
                function U(t) {
                    r.push(t.x),
                    r.push(t.y)
                }
                !function() {
                    const t = n.length / 3;
                    if (c) {
                        let t = 0
                          , e = A * t;
                        for (let t = 0; t < C; t++) {
                            const i = T[t];
                            B(i[2] + e, i[1] + e, i[0] + e)
                        }
                        t = o + 2 * p,
                        e = A * t;
                        for (let t = 0; t < C; t++) {
                            const i = T[t];
                            B(i[0] + e, i[1] + e, i[2] + e)
                        }
                    } else {
                        for (let t = 0; t < C; t++) {
                            const e = T[t];
                            B(e[2], e[1], e[0])
                        }
                        for (let t = 0; t < C; t++) {
                            const e = T[t];
                            B(e[0] + A * o, e[1] + A * o, e[2] + A * o)
                        }
                    }
                    i.addGroup(t, n.length / 3 - t, 0)
                }(),
                function() {
                    const t = n.length / 3;
                    let e = 0;
                    z(E, e),
                    e += E.length;
                    for (let t = 0, i = S.length; t < i; t++) {
                        const i = S[t];
                        z(i, e),
                        e += i.length
                    }
                    i.addGroup(t, n.length / 3 - t, 1)
                }()
            }
            this.setAttribute("position", new sd(n,3)),
            this.setAttribute("uv", new sd(r,2)),
            this.computeVertexNormals()
        }
        toJSON() {
            const t = fd.prototype.toJSON.call(this);
            return function(t, e, i) {
                if (i.shapes = [],
                Array.isArray(t))
                    for (let e = 0, n = t.length; e < n; e++) {
                        const n = t[e];
                        i.shapes.push(n.uuid)
                    }
                else
                    i.shapes.push(t.uuid);
                void 0 !== e.extrudePath && (i.options.extrudePath = e.extrudePath.toJSON());
                return i
            }(this.parameters.shapes, this.parameters.options, t)
        }
    }
    const Dg = {
        generateTopUV: function(t, e, i, n, r) {
            const s = e[3 * i]
              , a = e[3 * i + 1]
              , o = e[3 * n]
              , l = e[3 * n + 1]
              , c = e[3 * r]
              , h = e[3 * r + 1];
            return [new gh(s,a), new gh(o,l), new gh(c,h)]
        },
        generateSideWallUV: function(t, e, i, n, r, s) {
            const a = e[3 * i]
              , o = e[3 * i + 1]
              , l = e[3 * i + 2]
              , c = e[3 * n]
              , h = e[3 * n + 1]
              , u = e[3 * n + 2]
              , d = e[3 * r]
              , p = e[3 * r + 1]
              , f = e[3 * r + 2]
              , m = e[3 * s]
              , g = e[3 * s + 1]
              , v = e[3 * s + 2];
            return Math.abs(o - h) < .01 ? [new gh(a,1 - l), new gh(c,1 - u), new gh(d,1 - f), new gh(m,1 - v)] : [new gh(o,1 - l), new gh(h,1 - u), new gh(p,1 - f), new gh(g,1 - v)]
        }
    };
    class Ng extends fd {
        constructor(t, e=12) {
            super(),
            this.type = "ShapeGeometry",
            this.parameters = {
                shapes: t,
                curveSegments: e
            };
            const i = []
              , n = []
              , r = []
              , s = [];
            let a = 0
              , o = 0;
            if (!1 === Array.isArray(t))
                l(t);
            else
                for (let e = 0; e < t.length; e++)
                    l(t[e]),
                    this.addGroup(a, o, e),
                    a += o,
                    o = 0;
            function l(t) {
                const a = n.length / 3
                  , l = t.extractPoints(e);
                let c = l.shape;
                const h = l.holes;
                !1 === Cg.isClockWise(c) && (c = c.reverse());
                for (let t = 0, e = h.length; t < e; t++) {
                    const e = h[t];
                    !0 === Cg.isClockWise(e) && (h[t] = e.reverse())
                }
                const u = Cg.triangulateShape(c, h);
                for (let t = 0, e = h.length; t < e; t++) {
                    const e = h[t];
                    c = c.concat(e)
                }
                for (let t = 0, e = c.length; t < e; t++) {
                    const e = c[t];
                    n.push(e.x, e.y, 0),
                    r.push(0, 0, 1),
                    s.push(e.x, e.y)
                }
                for (let t = 0, e = u.length; t < e; t++) {
                    const e = u[t]
                      , n = e[0] + a
                      , r = e[1] + a
                      , s = e[2] + a;
                    i.push(n, r, s),
                    o += 3
                }
            }
            this.setIndex(i),
            this.setAttribute("position", new sd(n,3)),
            this.setAttribute("normal", new sd(r,3)),
            this.setAttribute("uv", new sd(s,2))
        }
        toJSON() {
            const t = fd.prototype.toJSON.call(this);
            return function(t, e) {
                if (e.shapes = [],
                Array.isArray(t))
                    for (let i = 0, n = t.length; i < n; i++) {
                        const n = t[i];
                        e.shapes.push(n.uuid)
                    }
                else
                    e.shapes.push(t.uuid);
                return e
            }(this.parameters.shapes, t)
        }
    }
    (class extends qu {
        constructor(t) {
            super(),
            this.type = "ShadowMaterial",
            this.color = new $u(0),
            this.transparent = !0,
            this.setValues(t)
        }
        copy(t) {
            return super.copy(t),
            this.color.copy(t.color),
            this
        }
    }
    ).prototype.isShadowMaterial = !0;
    class Og extends Bd {
        constructor(t) {
            super(t),
            this.type = "RawShaderMaterial"
        }
    }
    Og.prototype.isRawShaderMaterial = !0;
    class zg extends qu {
        constructor(t) {
            super(),
            this.defines = {
                STANDARD: ""
            },
            this.type = "MeshStandardMaterial",
            this.color = new $u(16777215),
            this.roughness = 1,
            this.metalness = 0,
            this.map = null,
            this.lightMap = null,
            this.lightMapIntensity = 1,
            this.aoMap = null,
            this.aoMapIntensity = 1,
            this.emissive = new $u(0),
            this.emissiveIntensity = 1,
            this.emissiveMap = null,
            this.bumpMap = null,
            this.bumpScale = 1,
            this.normalMap = null,
            this.normalMapType = eh,
            this.normalScale = new gh(1,1),
            this.displacementMap = null,
            this.displacementScale = 1,
            this.displacementBias = 0,
            this.roughnessMap = null,
            this.metalnessMap = null,
            this.alphaMap = null,
            this.envMap = null,
            this.envMapIntensity = 1,
            this.refractionRatio = .98,
            this.wireframe = !1,
            this.wireframeLinewidth = 1,
            this.wireframeLinecap = "round",
            this.wireframeLinejoin = "round",
            this.skinning = !1,
            this.morphTargets = !1,
            this.morphNormals = !1,
            this.flatShading = !1,
            this.vertexTangents = !1,
            this.setValues(t)
        }
        copy(t) {
            return super.copy(t),
            this.defines = {
                STANDARD: ""
            },
            this.color.copy(t.color),
            this.roughness = t.roughness,
            this.metalness = t.metalness,
            this.map = t.map,
            this.lightMap = t.lightMap,
            this.lightMapIntensity = t.lightMapIntensity,
            this.aoMap = t.aoMap,
            this.aoMapIntensity = t.aoMapIntensity,
            this.emissive.copy(t.emissive),
            this.emissiveMap = t.emissiveMap,
            this.emissiveIntensity = t.emissiveIntensity,
            this.bumpMap = t.bumpMap,
            this.bumpScale = t.bumpScale,
            this.normalMap = t.normalMap,
            this.normalMapType = t.normalMapType,
            this.normalScale.copy(t.normalScale),
            this.displacementMap = t.displacementMap,
            this.displacementScale = t.displacementScale,
            this.displacementBias = t.displacementBias,
            this.roughnessMap = t.roughnessMap,
            this.metalnessMap = t.metalnessMap,
            this.alphaMap = t.alphaMap,
            this.envMap = t.envMap,
            this.envMapIntensity = t.envMapIntensity,
            this.refractionRatio = t.refractionRatio,
            this.wireframe = t.wireframe,
            this.wireframeLinewidth = t.wireframeLinewidth,
            this.wireframeLinecap = t.wireframeLinecap,
            this.wireframeLinejoin = t.wireframeLinejoin,
            this.skinning = t.skinning,
            this.morphTargets = t.morphTargets,
            this.morphNormals = t.morphNormals,
            this.flatShading = t.flatShading,
            this.vertexTangents = t.vertexTangents,
            this
        }
    }
    zg.prototype.isMeshStandardMaterial = !0;
    (class extends zg {
        constructor(t) {
            super(),
            this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            },
            this.type = "MeshPhysicalMaterial",
            this.clearcoat = 0,
            this.clearcoatMap = null,
            this.clearcoatRoughness = 0,
            this.clearcoatRoughnessMap = null,
            this.clearcoatNormalScale = new gh(1,1),
            this.clearcoatNormalMap = null,
            this.reflectivity = .5,
            Object.defineProperty(this, "ior", {
                get: function() {
                    return (1 + .4 * this.reflectivity) / (1 - .4 * this.reflectivity)
                },
                set: function(t) {
                    this.reflectivity = dh(2.5 * (t - 1) / (t + 1), 0, 1)
                }
            }),
            this.sheen = null,
            this.transmission = 0,
            this.transmissionMap = null,
            this.setValues(t)
        }
        copy(t) {
            return super.copy(t),
            this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            },
            this.clearcoat = t.clearcoat,
            this.clearcoatMap = t.clearcoatMap,
            this.clearcoatRoughness = t.clearcoatRoughness,
            this.clearcoatRoughnessMap = t.clearcoatRoughnessMap,
            this.clearcoatNormalMap = t.clearcoatNormalMap,
            this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
            this.reflectivity = t.reflectivity,
            t.sheen ? this.sheen = (this.sheen || new $u).copy(t.sheen) : this.sheen = null,
            this.transmission = t.transmission,
            this.transmissionMap = t.transmissionMap,
            this
        }
    }
    ).prototype.isMeshPhysicalMaterial = !0;
    (class extends qu {
        constructor(t) {
            super(),
            this.type = "MeshPhongMaterial",
            this.color = new $u(16777215),
            this.specular = new $u(1118481),
            this.shininess = 30,
            this.map = null,
            this.lightMap = null,
            this.lightMapIntensity = 1,
            this.aoMap = null,
            this.aoMapIntensity = 1,
            this.emissive = new $u(0),
            this.emissiveIntensity = 1,
            this.emissiveMap = null,
            this.bumpMap = null,
            this.bumpScale = 1,
            this.normalMap = null,
            this.normalMapType = eh,
            this.normalScale = new gh(1,1),
            this.displacementMap = null,
            this.displacementScale = 1,
            this.displacementBias = 0,
            this.specularMap = null,
            this.alphaMap = null,
            this.envMap = null,
            this.combine = rl,
            this.reflectivity = 1,
            this.refractionRatio = .98,
            this.wireframe = !1,
            this.wireframeLinewidth = 1,
            this.wireframeLinecap = "round",
            this.wireframeLinejoin = "round",
            this.skinning = !1,
            this.morphTargets = !1,
            this.morphNormals = !1,
            this.flatShading = !1,
            this.setValues(t)
        }
        copy(t) {
            return super.copy(t),
            this.color.copy(t.color),
            this.specular.copy(t.specular),
            this.shininess = t.shininess,
            this.map = t.map,
            this.lightMap = t.lightMap,
            this.lightMapIntensity = t.lightMapIntensity,
            this.aoMap = t.aoMap,
            this.aoMapIntensity = t.aoMapIntensity,
            this.emissive.copy(t.emissive),
            this.emissiveMap = t.emissiveMap,
            this.emissiveIntensity = t.emissiveIntensity,
            this.bumpMap = t.bumpMap,
            this.bumpScale = t.bumpScale,
            this.normalMap = t.normalMap,
            this.normalMapType = t.normalMapType,
            this.normalScale.copy(t.normalScale),
            this.displacementMap = t.displacementMap,
            this.displacementScale = t.displacementScale,
            this.displacementBias = t.displacementBias,
            this.specularMap = t.specularMap,
            this.alphaMap = t.alphaMap,
            this.envMap = t.envMap,
            this.combine = t.combine,
            this.reflectivity = t.reflectivity,
            this.refractionRatio = t.refractionRatio,
            this.wireframe = t.wireframe,
            this.wireframeLinewidth = t.wireframeLinewidth,
            this.wireframeLinecap = t.wireframeLinecap,
            this.wireframeLinejoin = t.wireframeLinejoin,
            this.skinning = t.skinning,
            this.morphTargets = t.morphTargets,
            this.morphNormals = t.morphNormals,
            this.flatShading = t.flatShading,
            this
        }
    }
    ).prototype.isMeshPhongMaterial = !0;
    (class extends qu {
        constructor(t) {
            super(),
            this.defines = {
                TOON: ""
            },
            this.type = "MeshToonMaterial",
            this.color = new $u(16777215),
            this.map = null,
            this.gradientMap = null,
            this.lightMap = null,
            this.lightMapIntensity = 1,
            this.aoMap = null,
            this.aoMapIntensity = 1,
            this.emissive = new $u(0),
            this.emissiveIntensity = 1,
            this.emissiveMap = null,
            this.bumpMap = null,
            this.bumpScale = 1,
            this.normalMap = null,
            this.normalMapType = eh,
            this.normalScale = new gh(1,1),
            this.displacementMap = null,
            this.displacementScale = 1,
            this.displacementBias = 0,
            this.alphaMap = null,
            this.wireframe = !1,
            this.wireframeLinewidth = 1,
            this.wireframeLinecap = "round",
            this.wireframeLinejoin = "round",
            this.skinning = !1,
            this.morphTargets = !1,
            this.morphNormals = !1,
            this.setValues(t)
        }
        copy(t) {
            return super.copy(t),
            this.color.copy(t.color),
            this.map = t.map,
            this.gradientMap = t.gradientMap,
            this.lightMap = t.lightMap,
            this.lightMapIntensity = t.lightMapIntensity,
            this.aoMap = t.aoMap,
            this.aoMapIntensity = t.aoMapIntensity,
            this.emissive.copy(t.emissive),
            this.emissiveMap = t.emissiveMap,
            this.emissiveIntensity = t.emissiveIntensity,
            this.bumpMap = t.bumpMap,
            this.bumpScale = t.bumpScale,
            this.normalMap = t.normalMap,
            this.normalMapType = t.normalMapType,
            this.normalScale.copy(t.normalScale),
            this.displacementMap = t.displacementMap,
            this.displacementScale = t.displacementScale,
            this.displacementBias = t.displacementBias,
            this.alphaMap = t.alphaMap,
            this.wireframe = t.wireframe,
            this.wireframeLinewidth = t.wireframeLinewidth,
            this.wireframeLinecap = t.wireframeLinecap,
            this.wireframeLinejoin = t.wireframeLinejoin,
            this.skinning = t.skinning,
            this.morphTargets = t.morphTargets,
            this.morphNormals = t.morphNormals,
            this
        }
    }
    ).prototype.isMeshToonMaterial = !0;
    (class extends qu {
        constructor(t) {
            super(),
            this.type = "MeshNormalMaterial",
            this.bumpMap = null,
            this.bumpScale = 1,
            this.normalMap = null,
            this.normalMapType = eh,
            this.normalScale = new gh(1,1),
            this.displacementMap = null,
            this.displacementScale = 1,
            this.displacementBias = 0,
            this.wireframe = !1,
            this.wireframeLinewidth = 1,
            this.fog = !1,
            this.skinning = !1,
            this.morphTargets = !1,
            this.morphNormals = !1,
            this.flatShading = !1,
            this.setValues(t)
        }
        copy(t) {
            return super.copy(t),
            this.bumpMap = t.bumpMap,
            this.bumpScale = t.bumpScale,
            this.normalMap = t.normalMap,
            this.normalMapType = t.normalMapType,
            this.normalScale.copy(t.normalScale),
            this.displacementMap = t.displacementMap,
            this.displacementScale = t.displacementScale,
            this.displacementBias = t.displacementBias,
            this.wireframe = t.wireframe,
            this.wireframeLinewidth = t.wireframeLinewidth,
            this.skinning = t.skinning,
            this.morphTargets = t.morphTargets,
            this.morphNormals = t.morphNormals,
            this.flatShading = t.flatShading,
            this
        }
    }
    ).prototype.isMeshNormalMaterial = !0;
    (class extends qu {
        constructor(t) {
            super(),
            this.type = "MeshLambertMaterial",
            this.color = new $u(16777215),
            this.map = null,
            this.lightMap = null,
            this.lightMapIntensity = 1,
            this.aoMap = null,
            this.aoMapIntensity = 1,
            this.emissive = new $u(0),
            this.emissiveIntensity = 1,
            this.emissiveMap = null,
            this.specularMap = null,
            this.alphaMap = null,
            this.envMap = null,
            this.combine = rl,
            this.reflectivity = 1,
            this.refractionRatio = .98,
            this.wireframe = !1,
            this.wireframeLinewidth = 1,
            this.wireframeLinecap = "round",
            this.wireframeLinejoin = "round",
            this.skinning = !1,
            this.morphTargets = !1,
            this.morphNormals = !1,
            this.setValues(t)
        }
        copy(t) {
            return super.copy(t),
            this.color.copy(t.color),
            this.map = t.map,
            this.lightMap = t.lightMap,
            this.lightMapIntensity = t.lightMapIntensity,
            this.aoMap = t.aoMap,
            this.aoMapIntensity = t.aoMapIntensity,
            this.emissive.copy(t.emissive),
            this.emissiveMap = t.emissiveMap,
            this.emissiveIntensity = t.emissiveIntensity,
            this.specularMap = t.specularMap,
            this.alphaMap = t.alphaMap,
            this.envMap = t.envMap,
            this.combine = t.combine,
            this.reflectivity = t.reflectivity,
            this.refractionRatio = t.refractionRatio,
            this.wireframe = t.wireframe,
            this.wireframeLinewidth = t.wireframeLinewidth,
            this.wireframeLinecap = t.wireframeLinecap,
            this.wireframeLinejoin = t.wireframeLinejoin,
            this.skinning = t.skinning,
            this.morphTargets = t.morphTargets,
            this.morphNormals = t.morphNormals,
            this
        }
    }
    ).prototype.isMeshLambertMaterial = !0;
    (class extends qu {
        constructor(t) {
            super(),
            this.defines = {
                MATCAP: ""
            },
            this.type = "MeshMatcapMaterial",
            this.color = new $u(16777215),
            this.matcap = null,
            this.map = null,
            this.bumpMap = null,
            this.bumpScale = 1,
            this.normalMap = null,
            this.normalMapType = eh,
            this.normalScale = new gh(1,1),
            this.displacementMap = null,
            this.displacementScale = 1,
            this.displacementBias = 0,
            this.alphaMap = null,
            this.skinning = !1,
            this.morphTargets = !1,
            this.morphNormals = !1,
            this.flatShading = !1,
            this.setValues(t)
        }
        copy(t) {
            return super.copy(t),
            this.defines = {
                MATCAP: ""
            },
            this.color.copy(t.color),
            this.matcap = t.matcap,
            this.map = t.map,
            this.bumpMap = t.bumpMap,
            this.bumpScale = t.bumpScale,
            this.normalMap = t.normalMap,
            this.normalMapType = t.normalMapType,
            this.normalScale.copy(t.normalScale),
            this.displacementMap = t.displacementMap,
            this.displacementScale = t.displacementScale,
            this.displacementBias = t.displacementBias,
            this.alphaMap = t.alphaMap,
            this.skinning = t.skinning,
            this.morphTargets = t.morphTargets,
            this.morphNormals = t.morphNormals,
            this.flatShading = t.flatShading,
            this
        }
    }
    ).prototype.isMeshMatcapMaterial = !0;
    (class extends Gm {
        constructor(t) {
            super(),
            this.type = "LineDashedMaterial",
            this.scale = 1,
            this.dashSize = 3,
            this.gapSize = 1,
            this.setValues(t)
        }
        copy(t) {
            return super.copy(t),
            this.scale = t.scale,
            this.dashSize = t.dashSize,
            this.gapSize = t.gapSize,
            this
        }
    }
    ).prototype.isLineDashedMaterial = !0;
    const kg = {
        arraySlice: function(t, e, i) {
            return kg.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== i ? i : t.length)) : t.slice(e, i)
        },
        convertArray: function(t, e, i) {
            return !t || !i && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
        },
        isTypedArray: function(t) {
            return ArrayBuffer.isView(t) && !(t instanceof DataView)
        },
        getKeyframeOrder: function(t) {
            const e = t.length
              , i = new Array(e);
            for (let t = 0; t !== e; ++t)
                i[t] = t;
            return i.sort((function(e, i) {
                return t[e] - t[i]
            }
            )),
            i
        },
        sortedArray: function(t, e, i) {
            const n = t.length
              , r = new t.constructor(n);
            for (let s = 0, a = 0; a !== n; ++s) {
                const n = i[s] * e;
                for (let i = 0; i !== e; ++i)
                    r[a++] = t[n + i]
            }
            return r
        },
        flattenJSON: function(t, e, i, n) {
            let r = 1
              , s = t[0];
            for (; void 0 !== s && void 0 === s[n]; )
                s = t[r++];
            if (void 0 === s)
                return;
            let a = s[n];
            if (void 0 !== a)
                if (Array.isArray(a))
                    do {
                        a = s[n],
                        void 0 !== a && (e.push(s.time),
                        i.push.apply(i, a)),
                        s = t[r++]
                    } while (void 0 !== s);
                else if (void 0 !== a.toArray)
                    do {
                        a = s[n],
                        void 0 !== a && (e.push(s.time),
                        a.toArray(i, i.length)),
                        s = t[r++]
                    } while (void 0 !== s);
                else
                    do {
                        a = s[n],
                        void 0 !== a && (e.push(s.time),
                        i.push(a)),
                        s = t[r++]
                    } while (void 0 !== s)
        },
        subclip: function(t, e, i, n, r=30) {
            const s = t.clone();
            s.name = e;
            const a = [];
            for (let t = 0; t < s.tracks.length; ++t) {
                const e = s.tracks[t]
                  , o = e.getValueSize()
                  , l = []
                  , c = [];
                for (let t = 0; t < e.times.length; ++t) {
                    const s = e.times[t] * r;
                    if (!(s < i || s >= n)) {
                        l.push(e.times[t]);
                        for (let i = 0; i < o; ++i)
                            c.push(e.values[t * o + i])
                    }
                }
                0 !== l.length && (e.times = kg.convertArray(l, e.times.constructor),
                e.values = kg.convertArray(c, e.values.constructor),
                a.push(e))
            }
            s.tracks = a;
            let o = 1 / 0;
            for (let t = 0; t < s.tracks.length; ++t)
                o > s.tracks[t].times[0] && (o = s.tracks[t].times[0]);
            for (let t = 0; t < s.tracks.length; ++t)
                s.tracks[t].shift(-1 * o);
            return s.resetDuration(),
            s
        },
        makeClipAdditive: function(t, e=0, i=t, n=30) {
            n <= 0 && (n = 30);
            const r = i.tracks.length
              , s = e / n;
            for (let e = 0; e < r; ++e) {
                const n = i.tracks[e]
                  , r = n.ValueTypeName;
                if ("bool" === r || "string" === r)
                    continue;
                const a = t.tracks.find((function(t) {
                    return t.name === n.name && t.ValueTypeName === r
                }
                ));
                if (void 0 === a)
                    continue;
                let o = 0;
                const l = n.getValueSize();
                n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (o = l / 3);
                let c = 0;
                const h = a.getValueSize();
                a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = h / 3);
                const u = n.times.length - 1;
                let d;
                if (s <= n.times[0]) {
                    const t = o
                      , e = l - o;
                    d = kg.arraySlice(n.values, t, e)
                } else if (s >= n.times[u]) {
                    const t = u * l + o
                      , e = t + l - o;
                    d = kg.arraySlice(n.values, t, e)
                } else {
                    const t = n.createInterpolant()
                      , e = o
                      , i = l - o;
                    t.evaluate(s),
                    d = kg.arraySlice(t.resultBuffer, e, i)
                }
                if ("quaternion" === r) {
                    (new Th).fromArray(d).normalize().conjugate().toArray(d)
                }
                const p = a.times.length;
                for (let t = 0; t < p; ++t) {
                    const e = t * h + c;
                    if ("quaternion" === r)
                        Th.multiplyQuaternionsFlat(a.values, e, d, 0, a.values, e);
                    else {
                        const t = h - 2 * c;
                        for (let i = 0; i < t; ++i)
                            a.values[e + i] -= d[i]
                    }
                }
            }
            return t.blendMode = 2501,
            t
        }
    };
    class Bg {
        constructor(t, e, i, n) {
            this.parameterPositions = t,
            this._cachedIndex = 0,
            this.resultBuffer = void 0 !== n ? n : new e.constructor(i),
            this.sampleValues = e,
            this.valueSize = i,
            this.settings = null,
            this.DefaultSettings_ = {}
        }
        evaluate(t) {
            const e = this.parameterPositions;
            let i = this._cachedIndex
              , n = e[i]
              , r = e[i - 1];
            t: {
                e: {
                    let s;
                    i: {
                        n: if (!(t < n)) {
                            for (let s = i + 2; ; ) {
                                if (void 0 === n) {
                                    if (t < r)
                                        break n;
                                    return i = e.length,
                                    this._cachedIndex = i,
                                    this.afterEnd_(i - 1, t, r)
                                }
                                if (i === s)
                                    break;
                                if (r = n,
                                n = e[++i],
                                t < n)
                                    break e
                            }
                            s = e.length;
                            break i
                        }
                        if (t >= r)
                            break t;
                        {
                            const a = e[1];
                            t < a && (i = 2,
                            r = a);
                            for (let s = i - 2; ; ) {
                                if (void 0 === r)
                                    return this._cachedIndex = 0,
                                    this.beforeStart_(0, t, n);
                                if (i === s)
                                    break;
                                if (n = r,
                                r = e[--i - 1],
                                t >= r)
                                    break e
                            }
                            s = i,
                            i = 0
                        }
                    }
                    for (; i < s; ) {
                        const n = i + s >>> 1;
                        t < e[n] ? s = n : i = n + 1
                    }
                    if (n = e[i],
                    r = e[i - 1],
                    void 0 === r)
                        return this._cachedIndex = 0,
                        this.beforeStart_(0, t, n);
                    if (void 0 === n)
                        return i = e.length,
                        this._cachedIndex = i,
                        this.afterEnd_(i - 1, r, t)
                }
                this._cachedIndex = i,
                this.intervalChanged_(i, r, n)
            }
            return this.interpolate_(i, r, t, n)
        }
        getSettings_() {
            return this.settings || this.DefaultSettings_
        }
        copySampleValue_(t) {
            const e = this.resultBuffer
              , i = this.sampleValues
              , n = this.valueSize
              , r = t * n;
            for (let t = 0; t !== n; ++t)
                e[t] = i[r + t];
            return e
        }
        interpolate_() {
            throw new Error("call to abstract method")
        }
        intervalChanged_() {}
    }
    Bg.prototype.beforeStart_ = Bg.prototype.copySampleValue_,
    Bg.prototype.afterEnd_ = Bg.prototype.copySampleValue_;
    class Fg extends Bg {
        constructor(t, e, i, n) {
            super(t, e, i, n),
            this._weightPrev = -0,
            this._offsetPrev = -0,
            this._weightNext = -0,
            this._offsetNext = -0,
            this.DefaultSettings_ = {
                endingStart: Gc,
                endingEnd: Gc
            }
        }
        intervalChanged_(t, e, i) {
            const n = this.parameterPositions;
            let r = t - 2
              , s = t + 1
              , a = n[r]
              , o = n[s];
            if (void 0 === a)
                switch (this.getSettings_().endingStart) {
                case Vc:
                    r = t,
                    a = 2 * e - i;
                    break;
                case Wc:
                    r = n.length - 2,
                    a = e + n[r] - n[r + 1];
                    break;
                default:
                    r = t,
                    a = i
                }
            if (void 0 === o)
                switch (this.getSettings_().endingEnd) {
                case Vc:
                    s = t,
                    o = 2 * i - e;
                    break;
                case Wc:
                    s = 1,
                    o = i + n[1] - n[0];
                    break;
                default:
                    s = t - 1,
                    o = e
                }
            const l = .5 * (i - e)
              , c = this.valueSize;
            this._weightPrev = l / (e - a),
            this._weightNext = l / (o - i),
            this._offsetPrev = r * c,
            this._offsetNext = s * c
        }
        interpolate_(t, e, i, n) {
            const r = this.resultBuffer
              , s = this.sampleValues
              , a = this.valueSize
              , o = t * a
              , l = o - a
              , c = this._offsetPrev
              , h = this._offsetNext
              , u = this._weightPrev
              , d = this._weightNext
              , p = (i - e) / (n - e)
              , f = p * p
              , m = f * p
              , g = -u * m + 2 * u * f - u * p
              , v = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * p + 1
              , y = (-1 - d) * m + (1.5 + d) * f + .5 * p
              , x = d * m - d * f;
            for (let t = 0; t !== a; ++t)
                r[t] = g * s[c + t] + v * s[l + t] + y * s[o + t] + x * s[h + t];
            return r
        }
    }
    class Hg extends Bg {
        constructor(t, e, i, n) {
            super(t, e, i, n)
        }
        interpolate_(t, e, i, n) {
            const r = this.resultBuffer
              , s = this.sampleValues
              , a = this.valueSize
              , o = t * a
              , l = o - a
              , c = (i - e) / (n - e)
              , h = 1 - c;
            for (let t = 0; t !== a; ++t)
                r[t] = s[l + t] * h + s[o + t] * c;
            return r
        }
    }
    class Ug extends Bg {
        constructor(t, e, i, n) {
            super(t, e, i, n)
        }
        interpolate_(t) {
            return this.copySampleValue_(t - 1)
        }
    }
    class Gg {
        constructor(t, e, i, n) {
            if (void 0 === t)
                throw new Error("THREE.KeyframeTrack: track name is undefined");
            if (void 0 === e || 0 === e.length)
                throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
            this.name = t,
            this.times = kg.convertArray(e, this.TimeBufferType),
            this.values = kg.convertArray(i, this.ValueBufferType),
            this.setInterpolation(n || this.DefaultInterpolation)
        }
        static toJSON(t) {
            const e = t.constructor;
            let i;
            if (e.toJSON !== this.toJSON)
                i = e.toJSON(t);
            else {
                i = {
                    name: t.name,
                    times: kg.convertArray(t.times, Array),
                    values: kg.convertArray(t.values, Array)
                };
                const e = t.getInterpolation();
                e !== t.DefaultInterpolation && (i.interpolation = e)
            }
            return i.type = t.ValueTypeName,
            i
        }
        InterpolantFactoryMethodDiscrete(t) {
            return new Ug(this.times,this.values,this.getValueSize(),t)
        }
        InterpolantFactoryMethodLinear(t) {
            return new Hg(this.times,this.values,this.getValueSize(),t)
        }
        InterpolantFactoryMethodSmooth(t) {
            return new Fg(this.times,this.values,this.getValueSize(),t)
        }
        setInterpolation(t) {
            let e;
            switch (t) {
            case Fc:
                e = this.InterpolantFactoryMethodDiscrete;
                break;
            case Hc:
                e = this.InterpolantFactoryMethodLinear;
                break;
            case Uc:
                e = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 === e) {
                const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                if (void 0 === this.createInterpolant) {
                    if (t === this.DefaultInterpolation)
                        throw new Error(e);
                    this.setInterpolation(this.DefaultInterpolation)
                }
                return console.warn("THREE.KeyframeTrack:", e),
                this
            }
            return this.createInterpolant = e,
            this
        }
        getInterpolation() {
            switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
                return Fc;
            case this.InterpolantFactoryMethodLinear:
                return Hc;
            case this.InterpolantFactoryMethodSmooth:
                return Uc
            }
        }
        getValueSize() {
            return this.values.length / this.times.length
        }
        shift(t) {
            if (0 !== t) {
                const e = this.times;
                for (let i = 0, n = e.length; i !== n; ++i)
                    e[i] += t
            }
            return this
        }
        scale(t) {
            if (1 !== t) {
                const e = this.times;
                for (let i = 0, n = e.length; i !== n; ++i)
                    e[i] *= t
            }
            return this
        }
        trim(t, e) {
            const i = this.times
              , n = i.length;
            let r = 0
              , s = n - 1;
            for (; r !== n && i[r] < t; )
                ++r;
            for (; -1 !== s && i[s] > e; )
                --s;
            if (++s,
            0 !== r || s !== n) {
                r >= s && (s = Math.max(s, 1),
                r = s - 1);
                const t = this.getValueSize();
                this.times = kg.arraySlice(i, r, s),
                this.values = kg.arraySlice(this.values, r * t, s * t)
            }
            return this
        }
        validate() {
            let t = !0;
            const e = this.getValueSize();
            e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
            t = !1);
            const i = this.times
              , n = this.values
              , r = i.length;
            0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this),
            t = !1);
            let s = null;
            for (let e = 0; e !== r; e++) {
                const n = i[e];
                if ("number" == typeof n && isNaN(n)) {
                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, n),
                    t = !1;
                    break
                }
                if (null !== s && s > n) {
                    console.error("THREE.KeyframeTrack: Out of order keys.", this, e, n, s),
                    t = !1;
                    break
                }
                s = n
            }
            if (void 0 !== n && kg.isTypedArray(n))
                for (let e = 0, i = n.length; e !== i; ++e) {
                    const i = n[e];
                    if (isNaN(i)) {
                        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, i),
                        t = !1;
                        break
                    }
                }
            return t
        }
        optimize() {
            const t = kg.arraySlice(this.times)
              , e = kg.arraySlice(this.values)
              , i = this.getValueSize()
              , n = this.getInterpolation() === Uc
              , r = t.length - 1;
            let s = 1;
            for (let a = 1; a < r; ++a) {
                let r = !1;
                const o = t[a];
                if (o !== t[a + 1] && (1 !== a || o !== t[0]))
                    if (n)
                        r = !0;
                    else {
                        const t = a * i
                          , n = t - i
                          , s = t + i;
                        for (let a = 0; a !== i; ++a) {
                            const i = e[t + a];
                            if (i !== e[n + a] || i !== e[s + a]) {
                                r = !0;
                                break
                            }
                        }
                    }
                if (r) {
                    if (a !== s) {
                        t[s] = t[a];
                        const n = a * i
                          , r = s * i;
                        for (let t = 0; t !== i; ++t)
                            e[r + t] = e[n + t]
                    }
                    ++s
                }
            }
            if (r > 0) {
                t[s] = t[r];
                for (let t = r * i, n = s * i, a = 0; a !== i; ++a)
                    e[n + a] = e[t + a];
                ++s
            }
            return s !== t.length ? (this.times = kg.arraySlice(t, 0, s),
            this.values = kg.arraySlice(e, 0, s * i)) : (this.times = t,
            this.values = e),
            this
        }
        clone() {
            const t = kg.arraySlice(this.times, 0)
              , e = kg.arraySlice(this.values, 0)
              , i = new (0,
            this.constructor)(this.name,t,e);
            return i.createInterpolant = this.createInterpolant,
            i
        }
    }
    Gg.prototype.TimeBufferType = Float32Array,
    Gg.prototype.ValueBufferType = Float32Array,
    Gg.prototype.DefaultInterpolation = Hc;
    class Vg extends Gg {
    }
    Vg.prototype.ValueTypeName = "bool",
    Vg.prototype.ValueBufferType = Array,
    Vg.prototype.DefaultInterpolation = Fc,
    Vg.prototype.InterpolantFactoryMethodLinear = void 0,
    Vg.prototype.InterpolantFactoryMethodSmooth = void 0;
    class Wg extends Gg {
    }
    Wg.prototype.ValueTypeName = "color";
    class qg extends Gg {
    }
    qg.prototype.ValueTypeName = "number";
    class jg extends Bg {
        constructor(t, e, i, n) {
            super(t, e, i, n)
        }
        interpolate_(t, e, i, n) {
            const r = this.resultBuffer
              , s = this.sampleValues
              , a = this.valueSize
              , o = (i - e) / (n - e);
            let l = t * a;
            for (let t = l + a; l !== t; l += 4)
                Th.slerpFlat(r, 0, s, l - a, s, l, o);
            return r
        }
    }
    class Yg extends Gg {
        InterpolantFactoryMethodLinear(t) {
            return new jg(this.times,this.values,this.getValueSize(),t)
        }
    }
    Yg.prototype.ValueTypeName = "quaternion",
    Yg.prototype.DefaultInterpolation = Hc,
    Yg.prototype.InterpolantFactoryMethodSmooth = void 0;
    class Xg extends Gg {
    }
    Xg.prototype.ValueTypeName = "string",
    Xg.prototype.ValueBufferType = Array,
    Xg.prototype.DefaultInterpolation = Fc,
    Xg.prototype.InterpolantFactoryMethodLinear = void 0,
    Xg.prototype.InterpolantFactoryMethodSmooth = void 0;
    class Jg extends Gg {
    }
    Jg.prototype.ValueTypeName = "vector";
    class Zg {
        constructor(t, e=-1, i, n=2500) {
            this.name = t,
            this.tracks = i,
            this.duration = e,
            this.blendMode = n,
            this.uuid = uh(),
            this.duration < 0 && this.resetDuration()
        }
        static parse(t) {
            const e = []
              , i = t.tracks
              , n = 1 / (t.fps || 1);
            for (let t = 0, r = i.length; t !== r; ++t)
                e.push(Qg(i[t]).scale(n));
            const r = new this(t.name,t.duration,e,t.blendMode);
            return r.uuid = t.uuid,
            r
        }
        static toJSON(t) {
            const e = []
              , i = t.tracks
              , n = {
                name: t.name,
                duration: t.duration,
                tracks: e,
                uuid: t.uuid,
                blendMode: t.blendMode
            };
            for (let t = 0, n = i.length; t !== n; ++t)
                e.push(Gg.toJSON(i[t]));
            return n
        }
        static CreateFromMorphTargetSequence(t, e, i, n) {
            const r = e.length
              , s = [];
            for (let t = 0; t < r; t++) {
                let a = []
                  , o = [];
                a.push((t + r - 1) % r, t, (t + 1) % r),
                o.push(0, 1, 0);
                const l = kg.getKeyframeOrder(a);
                a = kg.sortedArray(a, 1, l),
                o = kg.sortedArray(o, 1, l),
                n || 0 !== a[0] || (a.push(r),
                o.push(o[0])),
                s.push(new qg(".morphTargetInfluences[" + e[t].name + "]",a,o).scale(1 / i))
            }
            return new this(t,-1,s)
        }
        static findByName(t, e) {
            let i = t;
            if (!Array.isArray(t)) {
                const e = t;
                i = e.geometry && e.geometry.animations || e.animations
            }
            for (let t = 0; t < i.length; t++)
                if (i[t].name === e)
                    return i[t];
            return null
        }
        static CreateClipsFromMorphTargetSequences(t, e, i) {
            const n = {}
              , r = /^([\w-]*?)([\d]+)$/;
            for (let e = 0, i = t.length; e < i; e++) {
                const i = t[e]
                  , s = i.name.match(r);
                if (s && s.length > 1) {
                    const t = s[1];
                    let e = n[t];
                    e || (n[t] = e = []),
                    e.push(i)
                }
            }
            const s = [];
            for (const t in n)
                s.push(this.CreateFromMorphTargetSequence(t, n[t], e, i));
            return s
        }
        static parseAnimation(t, e) {
            if (!t)
                return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
                null;
            const i = function(t, e, i, n, r) {
                if (0 !== i.length) {
                    const s = []
                      , a = [];
                    kg.flattenJSON(i, s, a, n),
                    0 !== s.length && r.push(new t(e,s,a))
                }
            }
              , n = []
              , r = t.name || "default"
              , s = t.fps || 30
              , a = t.blendMode;
            let o = t.length || -1;
            const l = t.hierarchy || [];
            for (let t = 0; t < l.length; t++) {
                const r = l[t].keys;
                if (r && 0 !== r.length)
                    if (r[0].morphTargets) {
                        const t = {};
                        let e;
                        for (e = 0; e < r.length; e++)
                            if (r[e].morphTargets)
                                for (let i = 0; i < r[e].morphTargets.length; i++)
                                    t[r[e].morphTargets[i]] = -1;
                        for (const i in t) {
                            const t = []
                              , s = [];
                            for (let n = 0; n !== r[e].morphTargets.length; ++n) {
                                const n = r[e];
                                t.push(n.time),
                                s.push(n.morphTarget === i ? 1 : 0)
                            }
                            n.push(new qg(".morphTargetInfluence[" + i + "]",t,s))
                        }
                        o = t.length * (s || 1)
                    } else {
                        const s = ".bones[" + e[t].name + "]";
                        i(Jg, s + ".position", r, "pos", n),
                        i(Yg, s + ".quaternion", r, "rot", n),
                        i(Jg, s + ".scale", r, "scl", n)
                    }
            }
            if (0 === n.length)
                return null;
            return new this(r,o,n,a)
        }
        resetDuration() {
            let t = 0;
            for (let e = 0, i = this.tracks.length; e !== i; ++e) {
                const i = this.tracks[e];
                t = Math.max(t, i.times[i.times.length - 1])
            }
            return this.duration = t,
            this
        }
        trim() {
            for (let t = 0; t < this.tracks.length; t++)
                this.tracks[t].trim(0, this.duration);
            return this
        }
        validate() {
            let t = !0;
            for (let e = 0; e < this.tracks.length; e++)
                t = t && this.tracks[e].validate();
            return t
        }
        optimize() {
            for (let t = 0; t < this.tracks.length; t++)
                this.tracks[t].optimize();
            return this
        }
        clone() {
            const t = [];
            for (let e = 0; e < this.tracks.length; e++)
                t.push(this.tracks[e].clone());
            return new this.constructor(this.name,this.duration,t,this.blendMode)
        }
        toJSON() {
            return this.constructor.toJSON(this)
        }
    }
    function Qg(t) {
        if (void 0 === t.type)
            throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        const e = function(t) {
            switch (t.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
                return qg;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
                return Jg;
            case "color":
                return Wg;
            case "quaternion":
                return Yg;
            case "bool":
            case "boolean":
                return Vg;
            case "string":
                return Xg
            }
            throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
        }(t.type);
        if (void 0 === t.times) {
            const e = []
              , i = [];
            kg.flattenJSON(t.keys, e, i, "value"),
            t.times = e,
            t.values = i
        }
        return void 0 !== e.parse ? e.parse(t) : new e(t.name,t.times,t.values,t.interpolation)
    }
    const $g = {
        enabled: !1,
        files: {},
        add: function(t, e) {
            !1 !== this.enabled && (this.files[t] = e)
        },
        get: function(t) {
            if (!1 !== this.enabled)
                return this.files[t]
        },
        remove: function(t) {
            delete this.files[t]
        },
        clear: function() {
            this.files = {}
        }
    };
    const Kg = new class {
        constructor(t, e, i) {
            const n = this;
            let r, s = !1, a = 0, o = 0;
            const l = [];
            this.onStart = void 0,
            this.onLoad = t,
            this.onProgress = e,
            this.onError = i,
            this.itemStart = function(t) {
                o++,
                !1 === s && void 0 !== n.onStart && n.onStart(t, a, o),
                s = !0
            }
            ,
            this.itemEnd = function(t) {
                a++,
                void 0 !== n.onProgress && n.onProgress(t, a, o),
                a === o && (s = !1,
                void 0 !== n.onLoad && n.onLoad())
            }
            ,
            this.itemError = function(t) {
                void 0 !== n.onError && n.onError(t)
            }
            ,
            this.resolveURL = function(t) {
                return r ? r(t) : t
            }
            ,
            this.setURLModifier = function(t) {
                return r = t,
                this
            }
            ,
            this.addHandler = function(t, e) {
                return l.push(t, e),
                this
            }
            ,
            this.removeHandler = function(t) {
                const e = l.indexOf(t);
                return -1 !== e && l.splice(e, 2),
                this
            }
            ,
            this.getHandler = function(t) {
                for (let e = 0, i = l.length; e < i; e += 2) {
                    const i = l[e]
                      , n = l[e + 1];
                    if (i.global && (i.lastIndex = 0),
                    i.test(t))
                        return n
                }
                return null
            }
        }
    }
    ;
    class tv {
        constructor(t) {
            this.manager = void 0 !== t ? t : Kg,
            this.crossOrigin = "anonymous",
            this.withCredentials = !1,
            this.path = "",
            this.resourcePath = "",
            this.requestHeader = {}
        }
        load() {}
        loadAsync(t, e) {
            const i = this;
            return new Promise((function(n, r) {
                i.load(t, n, e, r)
            }
            ))
        }
        parse() {}
        setCrossOrigin(t) {
            return this.crossOrigin = t,
            this
        }
        setWithCredentials(t) {
            return this.withCredentials = t,
            this
        }
        setPath(t) {
            return this.path = t,
            this
        }
        setResourcePath(t) {
            return this.resourcePath = t,
            this
        }
        setRequestHeader(t) {
            return this.requestHeader = t,
            this
        }
    }
    const ev = {};
    class iv extends tv {
        constructor(t) {
            super(t)
        }
        load(t, e, i, n) {
            void 0 === t && (t = ""),
            void 0 !== this.path && (t = this.path + t),
            t = this.manager.resolveURL(t);
            const r = this
              , s = $g.get(t);
            if (void 0 !== s)
                return r.manager.itemStart(t),
                setTimeout((function() {
                    e && e(s),
                    r.manager.itemEnd(t)
                }
                ), 0),
                s;
            if (void 0 !== ev[t])
                return void ev[t].push({
                    onLoad: e,
                    onProgress: i,
                    onError: n
                });
            const a = t.match(/^data:(.*?)(;base64)?,(.*)$/);
            let o;
            if (a) {
                const i = a[1]
                  , s = !!a[2];
                let o = a[3];
                o = decodeURIComponent(o),
                s && (o = atob(o));
                try {
                    let n;
                    const s = (this.responseType || "").toLowerCase();
                    switch (s) {
                    case "arraybuffer":
                    case "blob":
                        const t = new Uint8Array(o.length);
                        for (let e = 0; e < o.length; e++)
                            t[e] = o.charCodeAt(e);
                        n = "blob" === s ? new Blob([t.buffer],{
                            type: i
                        }) : t.buffer;
                        break;
                    case "document":
                        const e = new DOMParser;
                        n = e.parseFromString(o, i);
                        break;
                    case "json":
                        n = JSON.parse(o);
                        break;
                    default:
                        n = o
                    }
                    setTimeout((function() {
                        e && e(n),
                        r.manager.itemEnd(t)
                    }
                    ), 0)
                } catch (e) {
                    setTimeout((function() {
                        n && n(e),
                        r.manager.itemError(t),
                        r.manager.itemEnd(t)
                    }
                    ), 0)
                }
            } else {
                ev[t] = [],
                ev[t].push({
                    onLoad: e,
                    onProgress: i,
                    onError: n
                }),
                o = new XMLHttpRequest,
                o.open("GET", t, !0),
                o.addEventListener("load", (function(e) {
                    const i = this.response
                      , n = ev[t];
                    if (delete ev[t],
                    200 === this.status || 0 === this.status) {
                        0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                        $g.add(t, i);
                        for (let t = 0, e = n.length; t < e; t++) {
                            const e = n[t];
                            e.onLoad && e.onLoad(i)
                        }
                        r.manager.itemEnd(t)
                    } else {
                        for (let t = 0, i = n.length; t < i; t++) {
                            const i = n[t];
                            i.onError && i.onError(e)
                        }
                        r.manager.itemError(t),
                        r.manager.itemEnd(t)
                    }
                }
                ), !1),
                o.addEventListener("progress", (function(e) {
                    const i = ev[t];
                    for (let t = 0, n = i.length; t < n; t++) {
                        const n = i[t];
                        n.onProgress && n.onProgress(e)
                    }
                }
                ), !1),
                o.addEventListener("error", (function(e) {
                    const i = ev[t];
                    delete ev[t];
                    for (let t = 0, n = i.length; t < n; t++) {
                        const n = i[t];
                        n.onError && n.onError(e)
                    }
                    r.manager.itemError(t),
                    r.manager.itemEnd(t)
                }
                ), !1),
                o.addEventListener("abort", (function(e) {
                    const i = ev[t];
                    delete ev[t];
                    for (let t = 0, n = i.length; t < n; t++) {
                        const n = i[t];
                        n.onError && n.onError(e)
                    }
                    r.manager.itemError(t),
                    r.manager.itemEnd(t)
                }
                ), !1),
                void 0 !== this.responseType && (o.responseType = this.responseType),
                void 0 !== this.withCredentials && (o.withCredentials = this.withCredentials),
                o.overrideMimeType && o.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                for (const t in this.requestHeader)
                    o.setRequestHeader(t, this.requestHeader[t]);
                o.send(null)
            }
            return r.manager.itemStart(t),
            o
        }
        setResponseType(t) {
            return this.responseType = t,
            this
        }
        setMimeType(t) {
            return this.mimeType = t,
            this
        }
    }
    class nv extends tv {
        constructor(t) {
            super(t)
        }
        load(t, e, i, n) {
            void 0 !== this.path && (t = this.path + t),
            t = this.manager.resolveURL(t);
            const r = this
              , s = $g.get(t);
            if (void 0 !== s)
                return r.manager.itemStart(t),
                setTimeout((function() {
                    e && e(s),
                    r.manager.itemEnd(t)
                }
                ), 0),
                s;
            const a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
            function o() {
                a.removeEventListener("load", o, !1),
                a.removeEventListener("error", l, !1),
                $g.add(t, this),
                e && e(this),
                r.manager.itemEnd(t)
            }
            function l(e) {
                a.removeEventListener("load", o, !1),
                a.removeEventListener("error", l, !1),
                n && n(e),
                r.manager.itemError(t),
                r.manager.itemEnd(t)
            }
            return a.addEventListener("load", o, !1),
            a.addEventListener("error", l, !1),
            "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin),
            r.manager.itemStart(t),
            a.src = t,
            a
        }
    }
    class rv extends tv {
        constructor(t) {
            super(t)
        }
        load(t, e, i, n) {
            const r = new Vd
              , s = new nv(this.manager);
            s.setCrossOrigin(this.crossOrigin),
            s.setPath(this.path);
            let a = 0;
            function o(i) {
                s.load(t[i], (function(t) {
                    r.images[i] = t,
                    a++,
                    6 === a && (r.needsUpdate = !0,
                    e && e(r))
                }
                ), void 0, n)
            }
            for (let e = 0; e < t.length; ++e)
                o(e);
            return r
        }
    }
    class sv extends tv {
        constructor(t) {
            super(t)
        }
        load(t, e, i, n) {
            const r = new wh
              , s = new nv(this.manager);
            return s.setCrossOrigin(this.crossOrigin),
            s.setPath(this.path),
            s.load(t, (function(i) {
                r.image = i;
                const n = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                r.format = n ? Ul : Gl,
                r.needsUpdate = !0,
                void 0 !== e && e(r)
            }
            ), i, n),
            r
        }
    }
    class av {
        constructor() {
            this.type = "Curve",
            this.arcLengthDivisions = 200
        }
        getPoint() {
            return console.warn("THREE.Curve: .getPoint() not implemented."),
            null
        }
        getPointAt(t, e) {
            const i = this.getUtoTmapping(t);
            return this.getPoint(i, e)
        }
        getPoints(t=5) {
            const e = [];
            for (let i = 0; i <= t; i++)
                e.push(this.getPoint(i / t));
            return e
        }
        getSpacedPoints(t=5) {
            const e = [];
            for (let i = 0; i <= t; i++)
                e.push(this.getPointAt(i / t));
            return e
        }
        getLength() {
            const t = this.getLengths();
            return t[t.length - 1]
        }
        getLengths(t=this.arcLengthDivisions) {
            if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)
                return this.cacheArcLengths;
            this.needsUpdate = !1;
            const e = [];
            let i, n = this.getPoint(0), r = 0;
            e.push(0);
            for (let s = 1; s <= t; s++)
                i = this.getPoint(s / t),
                r += i.distanceTo(n),
                e.push(r),
                n = i;
            return this.cacheArcLengths = e,
            e
        }
        updateArcLengths() {
            this.needsUpdate = !0,
            this.getLengths()
        }
        getUtoTmapping(t, e) {
            const i = this.getLengths();
            let n = 0;
            const r = i.length;
            let s;
            s = e || t * i[r - 1];
            let a, o = 0, l = r - 1;
            for (; o <= l; )
                if (n = Math.floor(o + (l - o) / 2),
                a = i[n] - s,
                a < 0)
                    o = n + 1;
                else {
                    if (!(a > 0)) {
                        l = n;
                        break
                    }
                    l = n - 1
                }
            if (n = l,
            i[n] === s)
                return n / (r - 1);
            const c = i[n];
            return (n + (s - c) / (i[n + 1] - c)) / (r - 1)
        }
        getTangent(t, e) {
            const i = 1e-4;
            let n = t - i
              , r = t + i;
            n < 0 && (n = 0),
            r > 1 && (r = 1);
            const s = this.getPoint(n)
              , a = this.getPoint(r)
              , o = e || (s.isVector2 ? new gh : new Eh);
            return o.copy(a).sub(s).normalize(),
            o
        }
        getTangentAt(t, e) {
            const i = this.getUtoTmapping(t);
            return this.getTangent(i, e)
        }
        computeFrenetFrames(t, e) {
            const i = new Eh
              , n = []
              , r = []
              , s = []
              , a = new Eh
              , o = new nu;
            for (let e = 0; e <= t; e++) {
                const i = e / t;
                n[e] = this.getTangentAt(i, new Eh),
                n[e].normalize()
            }
            r[0] = new Eh,
            s[0] = new Eh;
            let l = Number.MAX_VALUE;
            const c = Math.abs(n[0].x)
              , h = Math.abs(n[0].y)
              , u = Math.abs(n[0].z);
            c <= l && (l = c,
            i.set(1, 0, 0)),
            h <= l && (l = h,
            i.set(0, 1, 0)),
            u <= l && i.set(0, 0, 1),
            a.crossVectors(n[0], i).normalize(),
            r[0].crossVectors(n[0], a),
            s[0].crossVectors(n[0], r[0]);
            for (let e = 1; e <= t; e++) {
                if (r[e] = r[e - 1].clone(),
                s[e] = s[e - 1].clone(),
                a.crossVectors(n[e - 1], n[e]),
                a.length() > Number.EPSILON) {
                    a.normalize();
                    const t = Math.acos(dh(n[e - 1].dot(n[e]), -1, 1));
                    r[e].applyMatrix4(o.makeRotationAxis(a, t))
                }
                s[e].crossVectors(n[e], r[e])
            }
            if (!0 === e) {
                let e = Math.acos(dh(r[0].dot(r[t]), -1, 1));
                e /= t,
                n[0].dot(a.crossVectors(r[0], r[t])) > 0 && (e = -e);
                for (let i = 1; i <= t; i++)
                    r[i].applyMatrix4(o.makeRotationAxis(n[i], e * i)),
                    s[i].crossVectors(n[i], r[i])
            }
            return {
                tangents: n,
                normals: r,
                binormals: s
            }
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(t) {
            return this.arcLengthDivisions = t.arcLengthDivisions,
            this
        }
        toJSON() {
            const t = {
                metadata: {
                    version: 4.5,
                    type: "Curve",
                    generator: "Curve.toJSON"
                }
            };
            return t.arcLengthDivisions = this.arcLengthDivisions,
            t.type = this.type,
            t
        }
        fromJSON(t) {
            return this.arcLengthDivisions = t.arcLengthDivisions,
            this
        }
    }
    class ov extends av {
        constructor(t=0, e=0, i=1, n=1, r=0, s=2 * Math.PI, a=!1, o=0) {
            super(),
            this.type = "EllipseCurve",
            this.aX = t,
            this.aY = e,
            this.xRadius = i,
            this.yRadius = n,
            this.aStartAngle = r,
            this.aEndAngle = s,
            this.aClockwise = a,
            this.aRotation = o
        }
        getPoint(t, e) {
            const i = e || new gh
              , n = 2 * Math.PI;
            let r = this.aEndAngle - this.aStartAngle;
            const s = Math.abs(r) < Number.EPSILON;
            for (; r < 0; )
                r += n;
            for (; r > n; )
                r -= n;
            r < Number.EPSILON && (r = s ? 0 : n),
            !0 !== this.aClockwise || s || (r === n ? r = -n : r -= n);
            const a = this.aStartAngle + t * r;
            let o = this.aX + this.xRadius * Math.cos(a)
              , l = this.aY + this.yRadius * Math.sin(a);
            if (0 !== this.aRotation) {
                const t = Math.cos(this.aRotation)
                  , e = Math.sin(this.aRotation)
                  , i = o - this.aX
                  , n = l - this.aY;
                o = i * t - n * e + this.aX,
                l = i * e + n * t + this.aY
            }
            return i.set(o, l)
        }
        copy(t) {
            return super.copy(t),
            this.aX = t.aX,
            this.aY = t.aY,
            this.xRadius = t.xRadius,
            this.yRadius = t.yRadius,
            this.aStartAngle = t.aStartAngle,
            this.aEndAngle = t.aEndAngle,
            this.aClockwise = t.aClockwise,
            this.aRotation = t.aRotation,
            this
        }
        toJSON() {
            const t = super.toJSON();
            return t.aX = this.aX,
            t.aY = this.aY,
            t.xRadius = this.xRadius,
            t.yRadius = this.yRadius,
            t.aStartAngle = this.aStartAngle,
            t.aEndAngle = this.aEndAngle,
            t.aClockwise = this.aClockwise,
            t.aRotation = this.aRotation,
            t
        }
        fromJSON(t) {
            return super.fromJSON(t),
            this.aX = t.aX,
            this.aY = t.aY,
            this.xRadius = t.xRadius,
            this.yRadius = t.yRadius,
            this.aStartAngle = t.aStartAngle,
            this.aEndAngle = t.aEndAngle,
            this.aClockwise = t.aClockwise,
            this.aRotation = t.aRotation,
            this
        }
    }
    ov.prototype.isEllipseCurve = !0;
    class lv extends ov {
        constructor(t, e, i, n, r, s) {
            super(t, e, i, i, n, r, s),
            this.type = "ArcCurve"
        }
    }
    function cv() {
        let t = 0
          , e = 0
          , i = 0
          , n = 0;
        function r(r, s, a, o) {
            t = r,
            e = a,
            i = -3 * r + 3 * s - 2 * a - o,
            n = 2 * r - 2 * s + a + o
        }
        return {
            initCatmullRom: function(t, e, i, n, s) {
                r(e, i, s * (i - t), s * (n - e))
            },
            initNonuniformCatmullRom: function(t, e, i, n, s, a, o) {
                let l = (e - t) / s - (i - t) / (s + a) + (i - e) / a
                  , c = (i - e) / a - (n - e) / (a + o) + (n - i) / o;
                l *= a,
                c *= a,
                r(e, i, l, c)
            },
            calc: function(r) {
                const s = r * r;
                return t + e * r + i * s + n * (s * r)
            }
        }
    }
    lv.prototype.isArcCurve = !0;
    const hv = new Eh
      , uv = new cv
      , dv = new cv
      , pv = new cv;
    class fv extends av {
        constructor(t=[], e=!1, i="centripetal", n=.5) {
            super(),
            this.type = "CatmullRomCurve3",
            this.points = t,
            this.closed = e,
            this.curveType = i,
            this.tension = n
        }
        getPoint(t, e=new Eh) {
            const i = e
              , n = this.points
              , r = n.length
              , s = (r - (this.closed ? 0 : 1)) * t;
            let a, o, l = Math.floor(s), c = s - l;
            this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === c && l === r - 1 && (l = r - 2,
            c = 1),
            this.closed || l > 0 ? a = n[(l - 1) % r] : (hv.subVectors(n[0], n[1]).add(n[0]),
            a = hv);
            const h = n[l % r]
              , u = n[(l + 1) % r];
            if (this.closed || l + 2 < r ? o = n[(l + 2) % r] : (hv.subVectors(n[r - 1], n[r - 2]).add(n[r - 1]),
            o = hv),
            "centripetal" === this.curveType || "chordal" === this.curveType) {
                const t = "chordal" === this.curveType ? .5 : .25;
                let e = Math.pow(a.distanceToSquared(h), t)
                  , i = Math.pow(h.distanceToSquared(u), t)
                  , n = Math.pow(u.distanceToSquared(o), t);
                i < 1e-4 && (i = 1),
                e < 1e-4 && (e = i),
                n < 1e-4 && (n = i),
                uv.initNonuniformCatmullRom(a.x, h.x, u.x, o.x, e, i, n),
                dv.initNonuniformCatmullRom(a.y, h.y, u.y, o.y, e, i, n),
                pv.initNonuniformCatmullRom(a.z, h.z, u.z, o.z, e, i, n)
            } else
                "catmullrom" === this.curveType && (uv.initCatmullRom(a.x, h.x, u.x, o.x, this.tension),
                dv.initCatmullRom(a.y, h.y, u.y, o.y, this.tension),
                pv.initCatmullRom(a.z, h.z, u.z, o.z, this.tension));
            return i.set(uv.calc(c), dv.calc(c), pv.calc(c)),
            i
        }
        copy(t) {
            super.copy(t),
            this.points = [];
            for (let e = 0, i = t.points.length; e < i; e++) {
                const i = t.points[e];
                this.points.push(i.clone())
            }
            return this.closed = t.closed,
            this.curveType = t.curveType,
            this.tension = t.tension,
            this
        }
        toJSON() {
            const t = super.toJSON();
            t.points = [];
            for (let e = 0, i = this.points.length; e < i; e++) {
                const i = this.points[e];
                t.points.push(i.toArray())
            }
            return t.closed = this.closed,
            t.curveType = this.curveType,
            t.tension = this.tension,
            t
        }
        fromJSON(t) {
            super.fromJSON(t),
            this.points = [];
            for (let e = 0, i = t.points.length; e < i; e++) {
                const i = t.points[e];
                this.points.push((new Eh).fromArray(i))
            }
            return this.closed = t.closed,
            this.curveType = t.curveType,
            this.tension = t.tension,
            this
        }
    }
    function mv(t, e, i, n, r) {
        const s = .5 * (n - e)
          , a = .5 * (r - i)
          , o = t * t;
        return (2 * i - 2 * n + s + a) * (t * o) + (-3 * i + 3 * n - 2 * s - a) * o + s * t + i
    }
    function gv(t, e, i, n) {
        return function(t, e) {
            const i = 1 - t;
            return i * i * e
        }(t, e) + function(t, e) {
            return 2 * (1 - t) * t * e
        }(t, i) + function(t, e) {
            return t * t * e
        }(t, n)
    }
    function vv(t, e, i, n, r) {
        return function(t, e) {
            const i = 1 - t;
            return i * i * i * e
        }(t, e) + function(t, e) {
            const i = 1 - t;
            return 3 * i * i * t * e
        }(t, i) + function(t, e) {
            return 3 * (1 - t) * t * t * e
        }(t, n) + function(t, e) {
            return t * t * t * e
        }(t, r)
    }
    fv.prototype.isCatmullRomCurve3 = !0;
    class yv extends av {
        constructor(t=new gh, e=new gh, i=new gh, n=new gh) {
            super(),
            this.type = "CubicBezierCurve",
            this.v0 = t,
            this.v1 = e,
            this.v2 = i,
            this.v3 = n
        }
        getPoint(t, e=new gh) {
            const i = e
              , n = this.v0
              , r = this.v1
              , s = this.v2
              , a = this.v3;
            return i.set(vv(t, n.x, r.x, s.x, a.x), vv(t, n.y, r.y, s.y, a.y)),
            i
        }
        copy(t) {
            return super.copy(t),
            this.v0.copy(t.v0),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this.v3.copy(t.v3),
            this
        }
        toJSON() {
            const t = super.toJSON();
            return t.v0 = this.v0.toArray(),
            t.v1 = this.v1.toArray(),
            t.v2 = this.v2.toArray(),
            t.v3 = this.v3.toArray(),
            t
        }
        fromJSON(t) {
            return super.fromJSON(t),
            this.v0.fromArray(t.v0),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this.v3.fromArray(t.v3),
            this
        }
    }
    yv.prototype.isCubicBezierCurve = !0;
    class xv extends av {
        constructor(t=new Eh, e=new Eh, i=new Eh, n=new Eh) {
            super(),
            this.type = "CubicBezierCurve3",
            this.v0 = t,
            this.v1 = e,
            this.v2 = i,
            this.v3 = n
        }
        getPoint(t, e=new Eh) {
            const i = e
              , n = this.v0
              , r = this.v1
              , s = this.v2
              , a = this.v3;
            return i.set(vv(t, n.x, r.x, s.x, a.x), vv(t, n.y, r.y, s.y, a.y), vv(t, n.z, r.z, s.z, a.z)),
            i
        }
        copy(t) {
            return super.copy(t),
            this.v0.copy(t.v0),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this.v3.copy(t.v3),
            this
        }
        toJSON() {
            const t = super.toJSON();
            return t.v0 = this.v0.toArray(),
            t.v1 = this.v1.toArray(),
            t.v2 = this.v2.toArray(),
            t.v3 = this.v3.toArray(),
            t
        }
        fromJSON(t) {
            return super.fromJSON(t),
            this.v0.fromArray(t.v0),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this.v3.fromArray(t.v3),
            this
        }
    }
    xv.prototype.isCubicBezierCurve3 = !0;
    class _v extends av {
        constructor(t=new gh, e=new gh) {
            super(),
            this.type = "LineCurve",
            this.v1 = t,
            this.v2 = e
        }
        getPoint(t, e=new gh) {
            const i = e;
            return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1),
            i.multiplyScalar(t).add(this.v1)),
            i
        }
        getPointAt(t, e) {
            return this.getPoint(t, e)
        }
        getTangent(t, e) {
            const i = e || new gh;
            return i.copy(this.v2).sub(this.v1).normalize(),
            i
        }
        copy(t) {
            return super.copy(t),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this
        }
        toJSON() {
            const t = super.toJSON();
            return t.v1 = this.v1.toArray(),
            t.v2 = this.v2.toArray(),
            t
        }
        fromJSON(t) {
            return super.fromJSON(t),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this
        }
    }
    _v.prototype.isLineCurve = !0;
    class wv extends av {
        constructor(t=new gh, e=new gh, i=new gh) {
            super(),
            this.type = "QuadraticBezierCurve",
            this.v0 = t,
            this.v1 = e,
            this.v2 = i
        }
        getPoint(t, e=new gh) {
            const i = e
              , n = this.v0
              , r = this.v1
              , s = this.v2;
            return i.set(gv(t, n.x, r.x, s.x), gv(t, n.y, r.y, s.y)),
            i
        }
        copy(t) {
            return super.copy(t),
            this.v0.copy(t.v0),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this
        }
        toJSON() {
            const t = super.toJSON();
            return t.v0 = this.v0.toArray(),
            t.v1 = this.v1.toArray(),
            t.v2 = this.v2.toArray(),
            t
        }
        fromJSON(t) {
            return super.fromJSON(t),
            this.v0.fromArray(t.v0),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this
        }
    }
    wv.prototype.isQuadraticBezierCurve = !0;
    class bv extends av {
        constructor(t=new Eh, e=new Eh, i=new Eh) {
            super(),
            this.type = "QuadraticBezierCurve3",
            this.v0 = t,
            this.v1 = e,
            this.v2 = i
        }
        getPoint(t, e=new Eh) {
            const i = e
              , n = this.v0
              , r = this.v1
              , s = this.v2;
            return i.set(gv(t, n.x, r.x, s.x), gv(t, n.y, r.y, s.y), gv(t, n.z, r.z, s.z)),
            i
        }
        copy(t) {
            return super.copy(t),
            this.v0.copy(t.v0),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this
        }
        toJSON() {
            const t = super.toJSON();
            return t.v0 = this.v0.toArray(),
            t.v1 = this.v1.toArray(),
            t.v2 = this.v2.toArray(),
            t
        }
        fromJSON(t) {
            return super.fromJSON(t),
            this.v0.fromArray(t.v0),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this
        }
    }
    bv.prototype.isQuadraticBezierCurve3 = !0;
    class Mv extends av {
        constructor(t=[]) {
            super(),
            this.type = "SplineCurve",
            this.points = t
        }
        getPoint(t, e=new gh) {
            const i = e
              , n = this.points
              , r = (n.length - 1) * t
              , s = Math.floor(r)
              , a = r - s
              , o = n[0 === s ? s : s - 1]
              , l = n[s]
              , c = n[s > n.length - 2 ? n.length - 1 : s + 1]
              , h = n[s > n.length - 3 ? n.length - 1 : s + 2];
            return i.set(mv(a, o.x, l.x, c.x, h.x), mv(a, o.y, l.y, c.y, h.y)),
            i
        }
        copy(t) {
            super.copy(t),
            this.points = [];
            for (let e = 0, i = t.points.length; e < i; e++) {
                const i = t.points[e];
                this.points.push(i.clone())
            }
            return this
        }
        toJSON() {
            const t = super.toJSON();
            t.points = [];
            for (let e = 0, i = this.points.length; e < i; e++) {
                const i = this.points[e];
                t.points.push(i.toArray())
            }
            return t
        }
        fromJSON(t) {
            super.fromJSON(t),
            this.points = [];
            for (let e = 0, i = t.points.length; e < i; e++) {
                const i = t.points[e];
                this.points.push((new gh).fromArray(i))
            }
            return this
        }
    }
    Mv.prototype.isSplineCurve = !0;
    var Sv = Object.freeze({
        __proto__: null,
        ArcCurve: lv,
        CatmullRomCurve3: fv,
        CubicBezierCurve: yv,
        CubicBezierCurve3: xv,
        EllipseCurve: ov,
        LineCurve: _v,
        LineCurve3: class extends av {
            constructor(t=new Eh, e=new Eh) {
                super(),
                this.type = "LineCurve3",
                this.isLineCurve3 = !0,
                this.v1 = t,
                this.v2 = e
            }
            getPoint(t, e=new Eh) {
                const i = e;
                return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1),
                i.multiplyScalar(t).add(this.v1)),
                i
            }
            getPointAt(t, e) {
                return this.getPoint(t, e)
            }
            copy(t) {
                return super.copy(t),
                this.v1.copy(t.v1),
                this.v2.copy(t.v2),
                this
            }
            toJSON() {
                const t = super.toJSON();
                return t.v1 = this.v1.toArray(),
                t.v2 = this.v2.toArray(),
                t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                this.v1.fromArray(t.v1),
                this.v2.fromArray(t.v2),
                this
            }
        }
        ,
        QuadraticBezierCurve: wv,
        QuadraticBezierCurve3: bv,
        SplineCurve: Mv
    });
    class Tv extends av {
        constructor() {
            super(),
            this.type = "CurvePath",
            this.curves = [],
            this.autoClose = !1
        }
        add(t) {
            this.curves.push(t)
        }
        closePath() {
            const t = this.curves[0].getPoint(0)
              , e = this.curves[this.curves.length - 1].getPoint(1);
            t.equals(e) || this.curves.push(new _v(e,t))
        }
        getPoint(t) {
            const e = t * this.getLength()
              , i = this.getCurveLengths();
            let n = 0;
            for (; n < i.length; ) {
                if (i[n] >= e) {
                    const t = i[n] - e
                      , r = this.curves[n]
                      , s = r.getLength()
                      , a = 0 === s ? 0 : 1 - t / s;
                    return r.getPointAt(a)
                }
                n++
            }
            return null
        }
        getLength() {
            const t = this.getCurveLengths();
            return t[t.length - 1]
        }
        updateArcLengths() {
            this.needsUpdate = !0,
            this.cacheLengths = null,
            this.getCurveLengths()
        }
        getCurveLengths() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                return this.cacheLengths;
            const t = [];
            let e = 0;
            for (let i = 0, n = this.curves.length; i < n; i++)
                e += this.curves[i].getLength(),
                t.push(e);
            return this.cacheLengths = t,
            t
        }
        getSpacedPoints(t=40) {
            const e = [];
            for (let i = 0; i <= t; i++)
                e.push(this.getPoint(i / t));
            return this.autoClose && e.push(e[0]),
            e
        }
        getPoints(t=12) {
            const e = [];
            let i;
            for (let n = 0, r = this.curves; n < r.length; n++) {
                const s = r[n]
                  , a = s && s.isEllipseCurve ? 2 * t : s && (s.isLineCurve || s.isLineCurve3) ? 1 : s && s.isSplineCurve ? t * s.points.length : t
                  , o = s.getPoints(a);
                for (let t = 0; t < o.length; t++) {
                    const n = o[t];
                    i && i.equals(n) || (e.push(n),
                    i = n)
                }
            }
            return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]),
            e
        }
        copy(t) {
            super.copy(t),
            this.curves = [];
            for (let e = 0, i = t.curves.length; e < i; e++) {
                const i = t.curves[e];
                this.curves.push(i.clone())
            }
            return this.autoClose = t.autoClose,
            this
        }
        toJSON() {
            const t = super.toJSON();
            t.autoClose = this.autoClose,
            t.curves = [];
            for (let e = 0, i = this.curves.length; e < i; e++) {
                const i = this.curves[e];
                t.curves.push(i.toJSON())
            }
            return t
        }
        fromJSON(t) {
            super.fromJSON(t),
            this.autoClose = t.autoClose,
            this.curves = [];
            for (let e = 0, i = t.curves.length; e < i; e++) {
                const i = t.curves[e];
                this.curves.push((new Sv[i.type]).fromJSON(i))
            }
            return this
        }
    }
    class Ev extends Tv {
        constructor(t) {
            super(),
            this.type = "Path",
            this.currentPoint = new gh,
            t && this.setFromPoints(t)
        }
        setFromPoints(t) {
            this.moveTo(t[0].x, t[0].y);
            for (let e = 1, i = t.length; e < i; e++)
                this.lineTo(t[e].x, t[e].y);
            return this
        }
        moveTo(t, e) {
            return this.currentPoint.set(t, e),
            this
        }
        lineTo(t, e) {
            const i = new _v(this.currentPoint.clone(),new gh(t,e));
            return this.curves.push(i),
            this.currentPoint.set(t, e),
            this
        }
        quadraticCurveTo(t, e, i, n) {
            const r = new wv(this.currentPoint.clone(),new gh(t,e),new gh(i,n));
            return this.curves.push(r),
            this.currentPoint.set(i, n),
            this
        }
        bezierCurveTo(t, e, i, n, r, s) {
            const a = new yv(this.currentPoint.clone(),new gh(t,e),new gh(i,n),new gh(r,s));
            return this.curves.push(a),
            this.currentPoint.set(r, s),
            this
        }
        splineThru(t) {
            const e = [this.currentPoint.clone()].concat(t)
              , i = new Mv(e);
            return this.curves.push(i),
            this.currentPoint.copy(t[t.length - 1]),
            this
        }
        arc(t, e, i, n, r, s) {
            const a = this.currentPoint.x
              , o = this.currentPoint.y;
            return this.absarc(t + a, e + o, i, n, r, s),
            this
        }
        absarc(t, e, i, n, r, s) {
            return this.absellipse(t, e, i, i, n, r, s),
            this
        }
        ellipse(t, e, i, n, r, s, a, o) {
            const l = this.currentPoint.x
              , c = this.currentPoint.y;
            return this.absellipse(t + l, e + c, i, n, r, s, a, o),
            this
        }
        absellipse(t, e, i, n, r, s, a, o) {
            const l = new ov(t,e,i,n,r,s,a,o);
            if (this.curves.length > 0) {
                const t = l.getPoint(0);
                t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
            }
            this.curves.push(l);
            const c = l.getPoint(1);
            return this.currentPoint.copy(c),
            this
        }
        copy(t) {
            return super.copy(t),
            this.currentPoint.copy(t.currentPoint),
            this
        }
        toJSON() {
            const t = super.toJSON();
            return t.currentPoint = this.currentPoint.toArray(),
            t
        }
        fromJSON(t) {
            return super.fromJSON(t),
            this.currentPoint.fromArray(t.currentPoint),
            this
        }
    }
    class Lv extends Ev {
        constructor(t) {
            super(t),
            this.uuid = uh(),
            this.type = "Shape",
            this.holes = []
        }
        getPointsHoles(t) {
            const e = [];
            for (let i = 0, n = this.holes.length; i < n; i++)
                e[i] = this.holes[i].getPoints(t);
            return e
        }
        extractPoints(t) {
            return {
                shape: this.getPoints(t),
                holes: this.getPointsHoles(t)
            }
        }
        copy(t) {
            super.copy(t),
            this.holes = [];
            for (let e = 0, i = t.holes.length; e < i; e++) {
                const i = t.holes[e];
                this.holes.push(i.clone())
            }
            return this
        }
        toJSON() {
            const t = super.toJSON();
            t.uuid = this.uuid,
            t.holes = [];
            for (let e = 0, i = this.holes.length; e < i; e++) {
                const i = this.holes[e];
                t.holes.push(i.toJSON())
            }
            return t
        }
        fromJSON(t) {
            super.fromJSON(t),
            this.uuid = t.uuid,
            this.holes = [];
            for (let e = 0, i = t.holes.length; e < i; e++) {
                const i = t.holes[e];
                this.holes.push((new Ev).fromJSON(i))
            }
            return this
        }
    }
    class Av extends Au {
        constructor(t, e=1) {
            super(),
            this.type = "Light",
            this.color = new $u(t),
            this.intensity = e
        }
        dispose() {}
        copy(t) {
            return super.copy(t),
            this.color.copy(t.color),
            this.intensity = t.intensity,
            this
        }
        toJSON(t) {
            const e = super.toJSON(t);
            return e.object.color = this.color.getHex(),
            e.object.intensity = this.intensity,
            void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()),
            void 0 !== this.distance && (e.object.distance = this.distance),
            void 0 !== this.angle && (e.object.angle = this.angle),
            void 0 !== this.decay && (e.object.decay = this.decay),
            void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
            void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
            e
        }
    }
    Av.prototype.isLight = !0;
    (class extends Av {
        constructor(t, e, i) {
            super(t, i),
            this.type = "HemisphereLight",
            this.position.copy(Au.DefaultUp),
            this.updateMatrix(),
            this.groundColor = new $u(e)
        }
        copy(t) {
            return Av.prototype.copy.call(this, t),
            this.groundColor.copy(t.groundColor),
            this
        }
    }
    ).prototype.isHemisphereLight = !0;
    const Cv = new nu
      , Pv = new Eh
      , Rv = new Eh;
    class Iv {
        constructor(t) {
            this.camera = t,
            this.bias = 0,
            this.normalBias = 0,
            this.radius = 1,
            this.mapSize = new gh(512,512),
            this.map = null,
            this.mapPass = null,
            this.matrix = new nu,
            this.autoUpdate = !0,
            this.needsUpdate = !1,
            this._frustum = new Xd,
            this._frameExtents = new gh(1,1),
            this._viewportCount = 1,
            this._viewports = [new Mh(0,0,1,1)]
        }
        getViewportCount() {
            return this._viewportCount
        }
        getFrustum() {
            return this._frustum
        }
        updateMatrices(t) {
            const e = this.camera
              , i = this.matrix;
            Pv.setFromMatrixPosition(t.matrixWorld),
            e.position.copy(Pv),
            Rv.setFromMatrixPosition(t.target.matrixWorld),
            e.lookAt(Rv),
            e.updateMatrixWorld(),
            Cv.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(Cv),
            i.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
            i.multiply(e.projectionMatrix),
            i.multiply(e.matrixWorldInverse)
        }
        getViewport(t) {
            return this._viewports[t]
        }
        getFrameExtents() {
            return this._frameExtents
        }
        dispose() {
            this.map && this.map.dispose(),
            this.mapPass && this.mapPass.dispose()
        }
        copy(t) {
            return this.camera = t.camera.clone(),
            this.bias = t.bias,
            this.radius = t.radius,
            this.mapSize.copy(t.mapSize),
            this
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        toJSON() {
            const t = {};
            return 0 !== this.bias && (t.bias = this.bias),
            0 !== this.normalBias && (t.normalBias = this.normalBias),
            1 !== this.radius && (t.radius = this.radius),
            512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()),
            t.camera = this.camera.toJSON(!1).object,
            delete t.camera.matrix,
            t
        }
    }
    class Dv extends Iv {
        constructor() {
            super(new Hd(50,1,.5,500)),
            this.focus = 1
        }
        updateMatrices(t) {
            const e = this.camera
              , i = 2 * hh * t.angle * this.focus
              , n = this.mapSize.width / this.mapSize.height
              , r = t.distance || e.far;
            i === e.fov && n === e.aspect && r === e.far || (e.fov = i,
            e.aspect = n,
            e.far = r,
            e.updateProjectionMatrix()),
            super.updateMatrices(t)
        }
        copy(t) {
            return super.copy(t),
            this.focus = t.focus,
            this
        }
    }
    Dv.prototype.isSpotLightShadow = !0;
    (class extends Av {
        constructor(t, e, i=0, n=Math.PI / 3, r=0, s=1) {
            super(t, e),
            this.type = "SpotLight",
            this.position.copy(Au.DefaultUp),
            this.updateMatrix(),
            this.target = new Au,
            this.distance = i,
            this.angle = n,
            this.penumbra = r,
            this.decay = s,
            this.shadow = new Dv
        }
        get power() {
            return this.intensity * Math.PI
        }
        set power(t) {
            this.intensity = t / Math.PI
        }
        dispose() {
            this.shadow.dispose()
        }
        copy(t) {
            return super.copy(t),
            this.distance = t.distance,
            this.angle = t.angle,
            this.penumbra = t.penumbra,
            this.decay = t.decay,
            this.target = t.target.clone(),
            this.shadow = t.shadow.clone(),
            this
        }
    }
    ).prototype.isSpotLight = !0;
    const Nv = new nu
      , Ov = new Eh
      , zv = new Eh;
    class kv extends Iv {
        constructor() {
            super(new Hd(90,1,.5,500)),
            this._frameExtents = new gh(4,2),
            this._viewportCount = 6,
            this._viewports = [new Mh(2,1,1,1), new Mh(0,1,1,1), new Mh(3,1,1,1), new Mh(1,1,1,1), new Mh(3,0,1,1), new Mh(1,0,1,1)],
            this._cubeDirections = [new Eh(1,0,0), new Eh(-1,0,0), new Eh(0,0,1), new Eh(0,0,-1), new Eh(0,1,0), new Eh(0,-1,0)],
            this._cubeUps = [new Eh(0,1,0), new Eh(0,1,0), new Eh(0,1,0), new Eh(0,1,0), new Eh(0,0,1), new Eh(0,0,-1)]
        }
        updateMatrices(t, e=0) {
            const i = this.camera
              , n = this.matrix
              , r = t.distance || i.far;
            r !== i.far && (i.far = r,
            i.updateProjectionMatrix()),
            Ov.setFromMatrixPosition(t.matrixWorld),
            i.position.copy(Ov),
            zv.copy(i.position),
            zv.add(this._cubeDirections[e]),
            i.up.copy(this._cubeUps[e]),
            i.lookAt(zv),
            i.updateMatrixWorld(),
            n.makeTranslation(-Ov.x, -Ov.y, -Ov.z),
            Nv.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(Nv)
        }
    }
    kv.prototype.isPointLightShadow = !0;
    (class extends Av {
        constructor(t, e, i=0, n=1) {
            super(t, e),
            this.type = "PointLight",
            this.distance = i,
            this.decay = n,
            this.shadow = new kv
        }
        get power() {
            return 4 * this.intensity * Math.PI
        }
        set power(t) {
            this.intensity = t / (4 * Math.PI)
        }
        dispose() {
            this.shadow.dispose()
        }
        copy(t) {
            return super.copy(t),
            this.distance = t.distance,
            this.decay = t.decay,
            this.shadow = t.shadow.clone(),
            this
        }
    }
    ).prototype.isPointLight = !0;
    class Bv extends Fd {
        constructor(t=-1, e=1, i=1, n=-1, r=.1, s=2e3) {
            super(),
            this.type = "OrthographicCamera",
            this.zoom = 1,
            this.view = null,
            this.left = t,
            this.right = e,
            this.top = i,
            this.bottom = n,
            this.near = r,
            this.far = s,
            this.updateProjectionMatrix()
        }
        copy(t, e) {
            return super.copy(t, e),
            this.left = t.left,
            this.right = t.right,
            this.top = t.top,
            this.bottom = t.bottom,
            this.near = t.near,
            this.far = t.far,
            this.zoom = t.zoom,
            this.view = null === t.view ? null : Object.assign({}, t.view),
            this
        }
        setViewOffset(t, e, i, n, r, s) {
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }),
            this.view.enabled = !0,
            this.view.fullWidth = t,
            this.view.fullHeight = e,
            this.view.offsetX = i,
            this.view.offsetY = n,
            this.view.width = r,
            this.view.height = s,
            this.updateProjectionMatrix()
        }
        clearViewOffset() {
            null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix()
        }
        updateProjectionMatrix() {
            const t = (this.right - this.left) / (2 * this.zoom)
              , e = (this.top - this.bottom) / (2 * this.zoom)
              , i = (this.right + this.left) / 2
              , n = (this.top + this.bottom) / 2;
            let r = i - t
              , s = i + t
              , a = n + e
              , o = n - e;
            if (null !== this.view && this.view.enabled) {
                const t = (this.right - this.left) / this.view.fullWidth / this.zoom
                  , e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                r += t * this.view.offsetX,
                s = r + t * this.view.width,
                a -= e * this.view.offsetY,
                o = a - e * this.view.height
            }
            this.projectionMatrix.makeOrthographic(r, s, a, o, this.near, this.far),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
        }
        toJSON(t) {
            const e = super.toJSON(t);
            return e.object.zoom = this.zoom,
            e.object.left = this.left,
            e.object.right = this.right,
            e.object.top = this.top,
            e.object.bottom = this.bottom,
            e.object.near = this.near,
            e.object.far = this.far,
            null !== this.view && (e.object.view = Object.assign({}, this.view)),
            e
        }
    }
    Bv.prototype.isOrthographicCamera = !0;
    class Fv extends Iv {
        constructor() {
            super(new Bv(-5,5,5,-5,.5,500))
        }
    }
    Fv.prototype.isDirectionalLightShadow = !0;
    (class extends Av {
        constructor(t, e) {
            super(t, e),
            this.type = "DirectionalLight",
            this.position.copy(Au.DefaultUp),
            this.updateMatrix(),
            this.target = new Au,
            this.shadow = new Fv
        }
        dispose() {
            this.shadow.dispose()
        }
        copy(t) {
            return super.copy(t),
            this.target = t.target.clone(),
            this.shadow = t.shadow.clone(),
            this
        }
    }
    ).prototype.isDirectionalLight = !0;
    (class extends Av {
        constructor(t, e) {
            super(t, e),
            this.type = "AmbientLight"
        }
    }
    ).prototype.isAmbientLight = !0;
    (class extends Av {
        constructor(t, e, i=10, n=10) {
            super(t, e),
            this.type = "RectAreaLight",
            this.width = i,
            this.height = n
        }
        copy(t) {
            return super.copy(t),
            this.width = t.width,
            this.height = t.height,
            this
        }
        toJSON(t) {
            const e = super.toJSON(t);
            return e.object.width = this.width,
            e.object.height = this.height,
            e
        }
    }
    ).prototype.isRectAreaLight = !0;
    class Hv {
        constructor() {
            this.coefficients = [];
            for (let t = 0; t < 9; t++)
                this.coefficients.push(new Eh)
        }
        set(t) {
            for (let e = 0; e < 9; e++)
                this.coefficients[e].copy(t[e]);
            return this
        }
        zero() {
            for (let t = 0; t < 9; t++)
                this.coefficients[t].set(0, 0, 0);
            return this
        }
        getAt(t, e) {
            const i = t.x
              , n = t.y
              , r = t.z
              , s = this.coefficients;
            return e.copy(s[0]).multiplyScalar(.282095),
            e.addScaledVector(s[1], .488603 * n),
            e.addScaledVector(s[2], .488603 * r),
            e.addScaledVector(s[3], .488603 * i),
            e.addScaledVector(s[4], i * n * 1.092548),
            e.addScaledVector(s[5], n * r * 1.092548),
            e.addScaledVector(s[6], .315392 * (3 * r * r - 1)),
            e.addScaledVector(s[7], i * r * 1.092548),
            e.addScaledVector(s[8], .546274 * (i * i - n * n)),
            e
        }
        getIrradianceAt(t, e) {
            const i = t.x
              , n = t.y
              , r = t.z
              , s = this.coefficients;
            return e.copy(s[0]).multiplyScalar(.886227),
            e.addScaledVector(s[1], 1.023328 * n),
            e.addScaledVector(s[2], 1.023328 * r),
            e.addScaledVector(s[3], 1.023328 * i),
            e.addScaledVector(s[4], .858086 * i * n),
            e.addScaledVector(s[5], .858086 * n * r),
            e.addScaledVector(s[6], .743125 * r * r - .247708),
            e.addScaledVector(s[7], .858086 * i * r),
            e.addScaledVector(s[8], .429043 * (i * i - n * n)),
            e
        }
        add(t) {
            for (let e = 0; e < 9; e++)
                this.coefficients[e].add(t.coefficients[e]);
            return this
        }
        addScaledSH(t, e) {
            for (let i = 0; i < 9; i++)
                this.coefficients[i].addScaledVector(t.coefficients[i], e);
            return this
        }
        scale(t) {
            for (let e = 0; e < 9; e++)
                this.coefficients[e].multiplyScalar(t);
            return this
        }
        lerp(t, e) {
            for (let i = 0; i < 9; i++)
                this.coefficients[i].lerp(t.coefficients[i], e);
            return this
        }
        equals(t) {
            for (let e = 0; e < 9; e++)
                if (!this.coefficients[e].equals(t.coefficients[e]))
                    return !1;
            return !0
        }
        copy(t) {
            return this.set(t.coefficients)
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        fromArray(t, e=0) {
            const i = this.coefficients;
            for (let n = 0; n < 9; n++)
                i[n].fromArray(t, e + 3 * n);
            return this
        }
        toArray(t=[], e=0) {
            const i = this.coefficients;
            for (let n = 0; n < 9; n++)
                i[n].toArray(t, e + 3 * n);
            return t
        }
        static getBasisAt(t, e) {
            const i = t.x
              , n = t.y
              , r = t.z;
            e[0] = .282095,
            e[1] = .488603 * n,
            e[2] = .488603 * r,
            e[3] = .488603 * i,
            e[4] = 1.092548 * i * n,
            e[5] = 1.092548 * n * r,
            e[6] = .315392 * (3 * r * r - 1),
            e[7] = 1.092548 * i * r,
            e[8] = .546274 * (i * i - n * n)
        }
    }
    Hv.prototype.isSphericalHarmonics3 = !0;
    class Uv extends Av {
        constructor(t=new Hv, e=1) {
            super(void 0, e),
            this.sh = t
        }
        copy(t) {
            return super.copy(t),
            this.sh.copy(t.sh),
            this
        }
        fromJSON(t) {
            return this.intensity = t.intensity,
            this.sh.fromArray(t.sh),
            this
        }
        toJSON(t) {
            const e = super.toJSON(t);
            return e.object.sh = this.sh.toArray(),
            e
        }
    }
    Uv.prototype.isLightProbe = !0;
    class Gv {
        static decodeText(t) {
            if ("undefined" != typeof TextDecoder)
                return (new TextDecoder).decode(t);
            let e = "";
            for (let i = 0, n = t.length; i < n; i++)
                e += String.fromCharCode(t[i]);
            try {
                return decodeURIComponent(escape(e))
            } catch (t) {
                return e
            }
        }
        static extractUrlBase(t) {
            const e = t.lastIndexOf("/");
            return -1 === e ? "./" : t.substr(0, e + 1)
        }
    }
    (class extends fd {
        constructor() {
            super(),
            this.type = "InstancedBufferGeometry",
            this.instanceCount = 1 / 0
        }
        copy(t) {
            return super.copy(t),
            this.instanceCount = t.instanceCount,
            this
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        toJSON() {
            const t = super.toJSON(this);
            return t.instanceCount = this.instanceCount,
            t.isInstancedBufferGeometry = !0,
            t
        }
    }
    ).prototype.isInstancedBufferGeometry = !0;
    (class extends id {
        constructor(t, e, i, n) {
            "number" == typeof i && (n = i,
            i = !1,
            console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),
            super(t, e, i),
            this.meshPerAttribute = n || 1
        }
        copy(t) {
            return super.copy(t),
            this.meshPerAttribute = t.meshPerAttribute,
            this
        }
        toJSON() {
            const t = super.toJSON();
            return t.meshPerAttribute = this.meshPerAttribute,
            t.isInstancedBufferAttribute = !0,
            t
        }
    }
    ).prototype.isInstancedBufferAttribute = !0;
    let Vv;
    (class extends tv {
        constructor(t) {
            super(t),
            "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
            "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
            this.options = {
                premultiplyAlpha: "none"
            }
        }
        setOptions(t) {
            return this.options = t,
            this
        }
        load(t, e, i, n) {
            void 0 === t && (t = ""),
            void 0 !== this.path && (t = this.path + t),
            t = this.manager.resolveURL(t);
            const r = this
              , s = $g.get(t);
            if (void 0 !== s)
                return r.manager.itemStart(t),
                setTimeout((function() {
                    e && e(s),
                    r.manager.itemEnd(t)
                }
                ), 0),
                s;
            const a = {};
            a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include",
            a.headers = this.requestHeader,
            fetch(t, a).then((function(t) {
                return t.blob()
            }
            )).then((function(t) {
                return createImageBitmap(t, Object.assign(r.options, {
                    colorSpaceConversion: "none"
                }))
            }
            )).then((function(i) {
                $g.add(t, i),
                e && e(i),
                r.manager.itemEnd(t)
            }
            )).catch((function(e) {
                n && n(e),
                r.manager.itemError(t),
                r.manager.itemEnd(t)
            }
            )),
            r.manager.itemStart(t)
        }
    }
    ).prototype.isImageBitmapLoader = !0;
    const Wv = function() {
        return void 0 === Vv && (Vv = new (window.AudioContext || window.webkitAudioContext)),
        Vv
    };
    class qv extends tv {
        constructor(t) {
            super(t)
        }
        load(t, e, i, n) {
            const r = this
              , s = new iv(this.manager);
            s.setResponseType("arraybuffer"),
            s.setPath(this.path),
            s.setRequestHeader(this.requestHeader),
            s.setWithCredentials(this.withCredentials),
            s.load(t, (function(i) {
                try {
                    const t = i.slice(0);
                    Wv().decodeAudioData(t, (function(t) {
                        e(t)
                    }
                    ))
                } catch (e) {
                    n ? n(e) : console.error(e),
                    r.manager.itemError(t)
                }
            }
            ), i, n)
        }
    }
    (class extends Uv {
        constructor(t, e, i=1) {
            super(void 0, i);
            const n = (new $u).set(t)
              , r = (new $u).set(e)
              , s = new Eh(n.r,n.g,n.b)
              , a = new Eh(r.r,r.g,r.b)
              , o = Math.sqrt(Math.PI)
              , l = o * Math.sqrt(.75);
            this.sh.coefficients[0].copy(s).add(a).multiplyScalar(o),
            this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(l)
        }
    }
    ).prototype.isHemisphereLightProbe = !0;
    (class extends Uv {
        constructor(t, e=1) {
            super(void 0, e);
            const i = (new $u).set(t);
            this.sh.coefficients[0].set(i.r, i.g, i.b).multiplyScalar(2 * Math.sqrt(Math.PI))
        }
    }
    ).prototype.isAmbientLightProbe = !0;
    class jv {
        constructor(t, e, i) {
            let n, r, s;
            switch (this.binding = t,
            this.valueSize = i,
            e) {
            case "quaternion":
                n = this._slerp,
                r = this._slerpAdditive,
                s = this._setAdditiveIdentityQuaternion,
                this.buffer = new Float64Array(6 * i),
                this._workIndex = 5;
                break;
            case "string":
            case "bool":
                n = this._select,
                r = this._select,
                s = this._setAdditiveIdentityOther,
                this.buffer = new Array(5 * i);
                break;
            default:
                n = this._lerp,
                r = this._lerpAdditive,
                s = this._setAdditiveIdentityNumeric,
                this.buffer = new Float64Array(5 * i)
            }
            this._mixBufferRegion = n,
            this._mixBufferRegionAdditive = r,
            this._setIdentity = s,
            this._origIndex = 3,
            this._addIndex = 4,
            this.cumulativeWeight = 0,
            this.cumulativeWeightAdditive = 0,
            this.useCount = 0,
            this.referenceCount = 0
        }
        accumulate(t, e) {
            const i = this.buffer
              , n = this.valueSize
              , r = t * n + n;
            let s = this.cumulativeWeight;
            if (0 === s) {
                for (let t = 0; t !== n; ++t)
                    i[r + t] = i[t];
                s = e
            } else {
                s += e;
                const t = e / s;
                this._mixBufferRegion(i, r, 0, t, n)
            }
            this.cumulativeWeight = s
        }
        accumulateAdditive(t) {
            const e = this.buffer
              , i = this.valueSize
              , n = i * this._addIndex;
            0 === this.cumulativeWeightAdditive && this._setIdentity(),
            this._mixBufferRegionAdditive(e, n, 0, t, i),
            this.cumulativeWeightAdditive += t
        }
        apply(t) {
            const e = this.valueSize
              , i = this.buffer
              , n = t * e + e
              , r = this.cumulativeWeight
              , s = this.cumulativeWeightAdditive
              , a = this.binding;
            if (this.cumulativeWeight = 0,
            this.cumulativeWeightAdditive = 0,
            r < 1) {
                const t = e * this._origIndex;
                this._mixBufferRegion(i, n, t, 1 - r, e)
            }
            s > 0 && this._mixBufferRegionAdditive(i, n, this._addIndex * e, 1, e);
            for (let t = e, r = e + e; t !== r; ++t)
                if (i[t] !== i[t + e]) {
                    a.setValue(i, n);
                    break
                }
        }
        saveOriginalState() {
            const t = this.binding
              , e = this.buffer
              , i = this.valueSize
              , n = i * this._origIndex;
            t.getValue(e, n);
            for (let t = i, r = n; t !== r; ++t)
                e[t] = e[n + t % i];
            this._setIdentity(),
            this.cumulativeWeight = 0,
            this.cumulativeWeightAdditive = 0
        }
        restoreOriginalState() {
            const t = 3 * this.valueSize;
            this.binding.setValue(this.buffer, t)
        }
        _setAdditiveIdentityNumeric() {
            const t = this._addIndex * this.valueSize
              , e = t + this.valueSize;
            for (let i = t; i < e; i++)
                this.buffer[i] = 0
        }
        _setAdditiveIdentityQuaternion() {
            this._setAdditiveIdentityNumeric(),
            this.buffer[this._addIndex * this.valueSize + 3] = 1
        }
        _setAdditiveIdentityOther() {
            const t = this._origIndex * this.valueSize
              , e = this._addIndex * this.valueSize;
            for (let i = 0; i < this.valueSize; i++)
                this.buffer[e + i] = this.buffer[t + i]
        }
        _select(t, e, i, n, r) {
            if (n >= .5)
                for (let n = 0; n !== r; ++n)
                    t[e + n] = t[i + n]
        }
        _slerp(t, e, i, n) {
            Th.slerpFlat(t, e, t, e, t, i, n)
        }
        _slerpAdditive(t, e, i, n, r) {
            const s = this._workIndex * r;
            Th.multiplyQuaternionsFlat(t, s, t, e, t, i),
            Th.slerpFlat(t, e, t, e, t, s, n)
        }
        _lerp(t, e, i, n, r) {
            const s = 1 - n;
            for (let a = 0; a !== r; ++a) {
                const r = e + a;
                t[r] = t[r] * s + t[i + a] * n
            }
        }
        _lerpAdditive(t, e, i, n, r) {
            for (let s = 0; s !== r; ++s) {
                const r = e + s;
                t[r] = t[r] + t[i + s] * n
            }
        }
    }
    const Yv = "\\[\\]\\.:\\/"
      , Xv = new RegExp("[" + Yv + "]","g")
      , Jv = "[^" + Yv + "]"
      , Zv = "[^" + Yv.replace("\\.", "") + "]"
      , Qv = /((?:WC+[\/:])*)/.source.replace("WC", Jv)
      , $v = /(WCOD+)?/.source.replace("WCOD", Zv)
      , Kv = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Jv)
      , ty = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Jv)
      , ey = new RegExp("^" + Qv + $v + Kv + ty + "$")
      , iy = ["material", "materials", "bones"];
    class ny {
        constructor(t, e, i) {
            this.path = e,
            this.parsedPath = i || ny.parseTrackName(e),
            this.node = ny.findNode(t, this.parsedPath.nodeName) || t,
            this.rootNode = t,
            this.getValue = this._getValue_unbound,
            this.setValue = this._setValue_unbound
        }
        static create(t, e, i) {
            return t && t.isAnimationObjectGroup ? new ny.Composite(t,e,i) : new ny(t,e,i)
        }
        static sanitizeNodeName(t) {
            return t.replace(/\s/g, "_").replace(Xv, "")
        }
        static parseTrackName(t) {
            const e = ey.exec(t);
            if (!e)
                throw new Error("PropertyBinding: Cannot parse trackName: " + t);
            const i = {
                nodeName: e[2],
                objectName: e[3],
                objectIndex: e[4],
                propertyName: e[5],
                propertyIndex: e[6]
            }
              , n = i.nodeName && i.nodeName.lastIndexOf(".");
            if (void 0 !== n && -1 !== n) {
                const t = i.nodeName.substring(n + 1);
                -1 !== iy.indexOf(t) && (i.nodeName = i.nodeName.substring(0, n),
                i.objectName = t)
            }
            if (null === i.propertyName || 0 === i.propertyName.length)
                throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
            return i
        }
        static findNode(t, e) {
            if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid)
                return t;
            if (t.skeleton) {
                const i = t.skeleton.getBoneByName(e);
                if (void 0 !== i)
                    return i
            }
            if (t.children) {
                const i = function(t) {
                    for (let n = 0; n < t.length; n++) {
                        const r = t[n];
                        if (r.name === e || r.uuid === e)
                            return r;
                        const s = i(r.children);
                        if (s)
                            return s
                    }
                    return null
                }
                  , n = i(t.children);
                if (n)
                    return n
            }
            return null
        }
        _getValue_unavailable() {}
        _setValue_unavailable() {}
        _getValue_direct(t, e) {
            t[e] = this.node[this.propertyName]
        }
        _getValue_array(t, e) {
            const i = this.resolvedProperty;
            for (let n = 0, r = i.length; n !== r; ++n)
                t[e++] = i[n]
        }
        _getValue_arrayElement(t, e) {
            t[e] = this.resolvedProperty[this.propertyIndex]
        }
        _getValue_toArray(t, e) {
            this.resolvedProperty.toArray(t, e)
        }
        _setValue_direct(t, e) {
            this.targetObject[this.propertyName] = t[e]
        }
        _setValue_direct_setNeedsUpdate(t, e) {
            this.targetObject[this.propertyName] = t[e],
            this.targetObject.needsUpdate = !0
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
            this.targetObject[this.propertyName] = t[e],
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        _setValue_array(t, e) {
            const i = this.resolvedProperty;
            for (let n = 0, r = i.length; n !== r; ++n)
                i[n] = t[e++]
        }
        _setValue_array_setNeedsUpdate(t, e) {
            const i = this.resolvedProperty;
            for (let n = 0, r = i.length; n !== r; ++n)
                i[n] = t[e++];
            this.targetObject.needsUpdate = !0
        }
        _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
            const i = this.resolvedProperty;
            for (let n = 0, r = i.length; n !== r; ++n)
                i[n] = t[e++];
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        _setValue_arrayElement(t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e]
        }
        _setValue_arrayElement_setNeedsUpdate(t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e],
            this.targetObject.needsUpdate = !0
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e],
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        _setValue_fromArray(t, e) {
            this.resolvedProperty.fromArray(t, e)
        }
        _setValue_fromArray_setNeedsUpdate(t, e) {
            this.resolvedProperty.fromArray(t, e),
            this.targetObject.needsUpdate = !0
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
            this.resolvedProperty.fromArray(t, e),
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        _getValue_unbound(t, e) {
            this.bind(),
            this.getValue(t, e)
        }
        _setValue_unbound(t, e) {
            this.bind(),
            this.setValue(t, e)
        }
        bind() {
            let t = this.node;
            const e = this.parsedPath
              , i = e.objectName
              , n = e.propertyName;
            let r = e.propertyIndex;
            if (t || (t = ny.findNode(this.rootNode, e.nodeName) || this.rootNode,
            this.node = t),
            this.getValue = this._getValue_unavailable,
            this.setValue = this._setValue_unavailable,
            !t)
                return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
            if (i) {
                let n = e.objectIndex;
                switch (i) {
                case "materials":
                    if (!t.material)
                        return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    if (!t.material.materials)
                        return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                    t = t.material.materials;
                    break;
                case "bones":
                    if (!t.skeleton)
                        return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                    t = t.skeleton.bones;
                    for (let e = 0; e < t.length; e++)
                        if (t[e].name === n) {
                            n = e;
                            break
                        }
                    break;
                default:
                    if (void 0 === t[i])
                        return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                    t = t[i]
                }
                if (void 0 !== n) {
                    if (void 0 === t[n])
                        return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                    t = t[n]
                }
            }
            const s = t[n];
            if (void 0 === s) {
                const i = e.nodeName;
                return void console.error("THREE.PropertyBinding: Trying to update property for track: " + i + "." + n + " but it wasn't found.", t)
            }
            let a = this.Versioning.None;
            this.targetObject = t,
            void 0 !== t.needsUpdate ? a = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate);
            let o = this.BindingType.Direct;
            if (void 0 !== r) {
                if ("morphTargetInfluences" === n) {
                    if (!t.geometry)
                        return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    if (!t.geometry.isBufferGeometry)
                        return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                    if (!t.geometry.morphAttributes)
                        return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                    void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r])
                }
                o = this.BindingType.ArrayElement,
                this.resolvedProperty = s,
                this.propertyIndex = r
            } else
                void 0 !== s.fromArray && void 0 !== s.toArray ? (o = this.BindingType.HasFromToArray,
                this.resolvedProperty = s) : Array.isArray(s) ? (o = this.BindingType.EntireArray,
                this.resolvedProperty = s) : this.propertyName = n;
            this.getValue = this.GetterByBindingType[o],
            this.setValue = this.SetterByBindingTypeAndVersioning[o][a]
        }
        unbind() {
            this.node = null,
            this.getValue = this._getValue_unbound,
            this.setValue = this._setValue_unbound
        }
    }
    ny.Composite = class {
        constructor(t, e, i) {
            const n = i || ny.parseTrackName(e);
            this._targetGroup = t,
            this._bindings = t.subscribe_(e, n)
        }
        getValue(t, e) {
            this.bind();
            const i = this._targetGroup.nCachedObjects_
              , n = this._bindings[i];
            void 0 !== n && n.getValue(t, e)
        }
        setValue(t, e) {
            const i = this._bindings;
            for (let n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n)
                i[n].setValue(t, e)
        }
        bind() {
            const t = this._bindings;
            for (let e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e)
                t[e].bind()
        }
        unbind() {
            const t = this._bindings;
            for (let e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e)
                t[e].unbind()
        }
    }
    ,
    ny.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
    },
    ny.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
    },
    ny.prototype.GetterByBindingType = [ny.prototype._getValue_direct, ny.prototype._getValue_array, ny.prototype._getValue_arrayElement, ny.prototype._getValue_toArray],
    ny.prototype.SetterByBindingTypeAndVersioning = [[ny.prototype._setValue_direct, ny.prototype._setValue_direct_setNeedsUpdate, ny.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [ny.prototype._setValue_array, ny.prototype._setValue_array_setNeedsUpdate, ny.prototype._setValue_array_setMatrixWorldNeedsUpdate], [ny.prototype._setValue_arrayElement, ny.prototype._setValue_arrayElement_setNeedsUpdate, ny.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [ny.prototype._setValue_fromArray, ny.prototype._setValue_fromArray_setNeedsUpdate, ny.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
    class ry {
        constructor(t, e, i=null, n=e.blendMode) {
            this._mixer = t,
            this._clip = e,
            this._localRoot = i,
            this.blendMode = n;
            const r = e.tracks
              , s = r.length
              , a = new Array(s)
              , o = {
                endingStart: Gc,
                endingEnd: Gc
            };
            for (let t = 0; t !== s; ++t) {
                const e = r[t].createInterpolant(null);
                a[t] = e,
                e.settings = o
            }
            this._interpolantSettings = o,
            this._interpolants = a,
            this._propertyBindings = new Array(s),
            this._cacheIndex = null,
            this._byClipCacheIndex = null,
            this._timeScaleInterpolant = null,
            this._weightInterpolant = null,
            this.loop = 2201,
            this._loopCount = -1,
            this._startTime = null,
            this.time = 0,
            this.timeScale = 1,
            this._effectiveTimeScale = 1,
            this.weight = 1,
            this._effectiveWeight = 1,
            this.repetitions = 1 / 0,
            this.paused = !1,
            this.enabled = !0,
            this.clampWhenFinished = !1,
            this.zeroSlopeAtStart = !0,
            this.zeroSlopeAtEnd = !0
        }
        play() {
            return this._mixer._activateAction(this),
            this
        }
        stop() {
            return this._mixer._deactivateAction(this),
            this.reset()
        }
        reset() {
            return this.paused = !1,
            this.enabled = !0,
            this.time = 0,
            this._loopCount = -1,
            this._startTime = null,
            this.stopFading().stopWarping()
        }
        isRunning() {
            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
        }
        isScheduled() {
            return this._mixer._isActiveAction(this)
        }
        startAt(t) {
            return this._startTime = t,
            this
        }
        setLoop(t, e) {
            return this.loop = t,
            this.repetitions = e,
            this
        }
        setEffectiveWeight(t) {
            return this.weight = t,
            this._effectiveWeight = this.enabled ? t : 0,
            this.stopFading()
        }
        getEffectiveWeight() {
            return this._effectiveWeight
        }
        fadeIn(t) {
            return this._scheduleFading(t, 0, 1)
        }
        fadeOut(t) {
            return this._scheduleFading(t, 1, 0)
        }
        crossFadeFrom(t, e, i) {
            if (t.fadeOut(e),
            this.fadeIn(e),
            i) {
                const i = this._clip.duration
                  , n = t._clip.duration
                  , r = n / i
                  , s = i / n;
                t.warp(1, r, e),
                this.warp(s, 1, e)
            }
            return this
        }
        crossFadeTo(t, e, i) {
            return t.crossFadeFrom(this, e, i)
        }
        stopFading() {
            const t = this._weightInterpolant;
            return null !== t && (this._weightInterpolant = null,
            this._mixer._takeBackControlInterpolant(t)),
            this
        }
        setEffectiveTimeScale(t) {
            return this.timeScale = t,
            this._effectiveTimeScale = this.paused ? 0 : t,
            this.stopWarping()
        }
        getEffectiveTimeScale() {
            return this._effectiveTimeScale
        }
        setDuration(t) {
            return this.timeScale = this._clip.duration / t,
            this.stopWarping()
        }
        syncWith(t) {
            return this.time = t.time,
            this.timeScale = t.timeScale,
            this.stopWarping()
        }
        halt(t) {
            return this.warp(this._effectiveTimeScale, 0, t)
        }
        warp(t, e, i) {
            const n = this._mixer
              , r = n.time
              , s = this.timeScale;
            let a = this._timeScaleInterpolant;
            null === a && (a = n._lendControlInterpolant(),
            this._timeScaleInterpolant = a);
            const o = a.parameterPositions
              , l = a.sampleValues;
            return o[0] = r,
            o[1] = r + i,
            l[0] = t / s,
            l[1] = e / s,
            this
        }
        stopWarping() {
            const t = this._timeScaleInterpolant;
            return null !== t && (this._timeScaleInterpolant = null,
            this._mixer._takeBackControlInterpolant(t)),
            this
        }
        getMixer() {
            return this._mixer
        }
        getClip() {
            return this._clip
        }
        getRoot() {
            return this._localRoot || this._mixer._root
        }
        _update(t, e, i, n) {
            if (!this.enabled)
                return void this._updateWeight(t);
            const r = this._startTime;
            if (null !== r) {
                const n = (t - r) * i;
                if (n < 0 || 0 === i)
                    return;
                this._startTime = null,
                e = i * n
            }
            e *= this._updateTimeScale(t);
            const s = this._updateTime(e)
              , a = this._updateWeight(t);
            if (a > 0) {
                const t = this._interpolants
                  , e = this._propertyBindings;
                if (2501 === this.blendMode)
                    for (let i = 0, n = t.length; i !== n; ++i)
                        t[i].evaluate(s),
                        e[i].accumulateAdditive(a);
                else
                    for (let i = 0, r = t.length; i !== r; ++i)
                        t[i].evaluate(s),
                        e[i].accumulate(n, a)
            }
        }
        _updateWeight(t) {
            let e = 0;
            if (this.enabled) {
                e = this.weight;
                const i = this._weightInterpolant;
                if (null !== i) {
                    const n = i.evaluate(t)[0];
                    e *= n,
                    t > i.parameterPositions[1] && (this.stopFading(),
                    0 === n && (this.enabled = !1))
                }
            }
            return this._effectiveWeight = e,
            e
        }
        _updateTimeScale(t) {
            let e = 0;
            if (!this.paused) {
                e = this.timeScale;
                const i = this._timeScaleInterpolant;
                if (null !== i) {
                    e *= i.evaluate(t)[0],
                    t > i.parameterPositions[1] && (this.stopWarping(),
                    0 === e ? this.paused = !0 : this.timeScale = e)
                }
            }
            return this._effectiveTimeScale = e,
            e
        }
        _updateTime(t) {
            const e = this._clip.duration
              , i = this.loop;
            let n = this.time + t
              , r = this._loopCount;
            const s = 2202 === i;
            if (0 === t)
                return -1 === r || !s || 1 & ~r ? n : e - n;
            if (2200 === i) {
                -1 === r && (this._loopCount = 0,
                this._setEndings(!0, !0, !1));
                t: {
                    if (n >= e)
                        n = e;
                    else {
                        if (!(n < 0)) {
                            this.time = n;
                            break t
                        }
                        n = 0
                    }
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    this.time = n,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: t < 0 ? -1 : 1
                    })
                }
            } else {
                if (-1 === r && (t >= 0 ? (r = 0,
                this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)),
                n >= e || n < 0) {
                    const i = Math.floor(n / e);
                    n -= e * i,
                    r += Math.abs(i);
                    const a = this.repetitions - r;
                    if (a <= 0)
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                        n = t > 0 ? e : 0,
                        this.time = n,
                        this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: t > 0 ? 1 : -1
                        });
                    else {
                        if (1 === a) {
                            const e = t < 0;
                            this._setEndings(e, !e, s)
                        } else
                            this._setEndings(!1, !1, s);
                        this._loopCount = r,
                        this.time = n,
                        this._mixer.dispatchEvent({
                            type: "loop",
                            action: this,
                            loopDelta: i
                        })
                    }
                } else
                    this.time = n;
                if (s && !(1 & ~r))
                    return e - n
            }
            return n
        }
        _setEndings(t, e, i) {
            const n = this._interpolantSettings;
            i ? (n.endingStart = Vc,
            n.endingEnd = Vc) : (n.endingStart = t ? this.zeroSlopeAtStart ? Vc : Gc : Wc,
            n.endingEnd = e ? this.zeroSlopeAtEnd ? Vc : Gc : Wc)
        }
        _scheduleFading(t, e, i) {
            const n = this._mixer
              , r = n.time;
            let s = this._weightInterpolant;
            null === s && (s = n._lendControlInterpolant(),
            this._weightInterpolant = s);
            const a = s.parameterPositions
              , o = s.sampleValues;
            return a[0] = r,
            o[0] = e,
            a[1] = r + t,
            o[1] = i,
            this
        }
    }
    (class extends oh {
        constructor(t) {
            super(),
            this._root = t,
            this._initMemoryManager(),
            this._accuIndex = 0,
            this.time = 0,
            this.timeScale = 1
        }
        _bindAction(t, e) {
            const i = t._localRoot || this._root
              , n = t._clip.tracks
              , r = n.length
              , s = t._propertyBindings
              , a = t._interpolants
              , o = i.uuid
              , l = this._bindingsByRootAndName;
            let c = l[o];
            void 0 === c && (c = {},
            l[o] = c);
            for (let t = 0; t !== r; ++t) {
                const r = n[t]
                  , l = r.name;
                let h = c[l];
                if (void 0 !== h)
                    s[t] = h;
                else {
                    if (h = s[t],
                    void 0 !== h) {
                        null === h._cacheIndex && (++h.referenceCount,
                        this._addInactiveBinding(h, o, l));
                        continue
                    }
                    const n = e && e._propertyBindings[t].binding.parsedPath;
                    h = new jv(ny.create(i, l, n),r.ValueTypeName,r.getValueSize()),
                    ++h.referenceCount,
                    this._addInactiveBinding(h, o, l),
                    s[t] = h
                }
                a[t].resultBuffer = h.buffer
            }
        }
        _activateAction(t) {
            if (!this._isActiveAction(t)) {
                if (null === t._cacheIndex) {
                    const e = (t._localRoot || this._root).uuid
                      , i = t._clip.uuid
                      , n = this._actionsByClip[i];
                    this._bindAction(t, n && n.knownActions[0]),
                    this._addInactiveAction(t, i, e)
                }
                const e = t._propertyBindings;
                for (let t = 0, i = e.length; t !== i; ++t) {
                    const i = e[t];
                    0 == i.useCount++ && (this._lendBinding(i),
                    i.saveOriginalState())
                }
                this._lendAction(t)
            }
        }
        _deactivateAction(t) {
            if (this._isActiveAction(t)) {
                const e = t._propertyBindings;
                for (let t = 0, i = e.length; t !== i; ++t) {
                    const i = e[t];
                    0 == --i.useCount && (i.restoreOriginalState(),
                    this._takeBackBinding(i))
                }
                this._takeBackAction(t)
            }
        }
        _initMemoryManager() {
            this._actions = [],
            this._nActiveActions = 0,
            this._actionsByClip = {},
            this._bindings = [],
            this._nActiveBindings = 0,
            this._bindingsByRootAndName = {},
            this._controlInterpolants = [],
            this._nActiveControlInterpolants = 0;
            const t = this;
            this.stats = {
                actions: {
                    get total() {
                        return t._actions.length
                    },
                    get inUse() {
                        return t._nActiveActions
                    }
                },
                bindings: {
                    get total() {
                        return t._bindings.length
                    },
                    get inUse() {
                        return t._nActiveBindings
                    }
                },
                controlInterpolants: {
                    get total() {
                        return t._controlInterpolants.length
                    },
                    get inUse() {
                        return t._nActiveControlInterpolants
                    }
                }
            }
        }
        _isActiveAction(t) {
            const e = t._cacheIndex;
            return null !== e && e < this._nActiveActions
        }
        _addInactiveAction(t, e, i) {
            const n = this._actions
              , r = this._actionsByClip;
            let s = r[e];
            if (void 0 === s)
                s = {
                    knownActions: [t],
                    actionByRoot: {}
                },
                t._byClipCacheIndex = 0,
                r[e] = s;
            else {
                const e = s.knownActions;
                t._byClipCacheIndex = e.length,
                e.push(t)
            }
            t._cacheIndex = n.length,
            n.push(t),
            s.actionByRoot[i] = t
        }
        _removeInactiveAction(t) {
            const e = this._actions
              , i = e[e.length - 1]
              , n = t._cacheIndex;
            i._cacheIndex = n,
            e[n] = i,
            e.pop(),
            t._cacheIndex = null;
            const r = t._clip.uuid
              , s = this._actionsByClip
              , a = s[r]
              , o = a.knownActions
              , l = o[o.length - 1]
              , c = t._byClipCacheIndex;
            l._byClipCacheIndex = c,
            o[c] = l,
            o.pop(),
            t._byClipCacheIndex = null;
            delete a.actionByRoot[(t._localRoot || this._root).uuid],
            0 === o.length && delete s[r],
            this._removeInactiveBindingsForAction(t)
        }
        _removeInactiveBindingsForAction(t) {
            const e = t._propertyBindings;
            for (let t = 0, i = e.length; t !== i; ++t) {
                const i = e[t];
                0 == --i.referenceCount && this._removeInactiveBinding(i)
            }
        }
        _lendAction(t) {
            const e = this._actions
              , i = t._cacheIndex
              , n = this._nActiveActions++
              , r = e[n];
            t._cacheIndex = n,
            e[n] = t,
            r._cacheIndex = i,
            e[i] = r
        }
        _takeBackAction(t) {
            const e = this._actions
              , i = t._cacheIndex
              , n = --this._nActiveActions
              , r = e[n];
            t._cacheIndex = n,
            e[n] = t,
            r._cacheIndex = i,
            e[i] = r
        }
        _addInactiveBinding(t, e, i) {
            const n = this._bindingsByRootAndName
              , r = this._bindings;
            let s = n[e];
            void 0 === s && (s = {},
            n[e] = s),
            s[i] = t,
            t._cacheIndex = r.length,
            r.push(t)
        }
        _removeInactiveBinding(t) {
            const e = this._bindings
              , i = t.binding
              , n = i.rootNode.uuid
              , r = i.path
              , s = this._bindingsByRootAndName
              , a = s[n]
              , o = e[e.length - 1]
              , l = t._cacheIndex;
            o._cacheIndex = l,
            e[l] = o,
            e.pop(),
            delete a[r],
            0 === Object.keys(a).length && delete s[n]
        }
        _lendBinding(t) {
            const e = this._bindings
              , i = t._cacheIndex
              , n = this._nActiveBindings++
              , r = e[n];
            t._cacheIndex = n,
            e[n] = t,
            r._cacheIndex = i,
            e[i] = r
        }
        _takeBackBinding(t) {
            const e = this._bindings
              , i = t._cacheIndex
              , n = --this._nActiveBindings
              , r = e[n];
            t._cacheIndex = n,
            e[n] = t,
            r._cacheIndex = i,
            e[i] = r
        }
        _lendControlInterpolant() {
            const t = this._controlInterpolants
              , e = this._nActiveControlInterpolants++;
            let i = t[e];
            return void 0 === i && (i = new Hg(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),
            i.__cacheIndex = e,
            t[e] = i),
            i
        }
        _takeBackControlInterpolant(t) {
            const e = this._controlInterpolants
              , i = t.__cacheIndex
              , n = --this._nActiveControlInterpolants
              , r = e[n];
            t.__cacheIndex = n,
            e[n] = t,
            r.__cacheIndex = i,
            e[i] = r
        }
        clipAction(t, e, i) {
            const n = e || this._root
              , r = n.uuid;
            let s = "string" == typeof t ? Zg.findByName(n, t) : t;
            const a = null !== s ? s.uuid : t
              , o = this._actionsByClip[a];
            let l = null;
            if (void 0 === i && (i = null !== s ? s.blendMode : qc),
            void 0 !== o) {
                const t = o.actionByRoot[r];
                if (void 0 !== t && t.blendMode === i)
                    return t;
                l = o.knownActions[0],
                null === s && (s = l._clip)
            }
            if (null === s)
                return null;
            const c = new ry(this,s,e,i);
            return this._bindAction(c, l),
            this._addInactiveAction(c, a, r),
            c
        }
        existingAction(t, e) {
            const i = e || this._root
              , n = i.uuid
              , r = "string" == typeof t ? Zg.findByName(i, t) : t
              , s = r ? r.uuid : t
              , a = this._actionsByClip[s];
            return void 0 !== a && a.actionByRoot[n] || null
        }
        stopAllAction() {
            const t = this._actions;
            for (let e = this._nActiveActions - 1; e >= 0; --e)
                t[e].stop();
            return this
        }
        update(t) {
            t *= this.timeScale;
            const e = this._actions
              , i = this._nActiveActions
              , n = this.time += t
              , r = Math.sign(t)
              , s = this._accuIndex ^= 1;
            for (let a = 0; a !== i; ++a) {
                e[a]._update(n, t, r, s)
            }
            const a = this._bindings
              , o = this._nActiveBindings;
            for (let t = 0; t !== o; ++t)
                a[t].apply(s);
            return this
        }
        setTime(t) {
            this.time = 0;
            for (let t = 0; t < this._actions.length; t++)
                this._actions[t].time = 0;
            return this.update(t)
        }
        getRoot() {
            return this._root
        }
        uncacheClip(t) {
            const e = this._actions
              , i = t.uuid
              , n = this._actionsByClip
              , r = n[i];
            if (void 0 !== r) {
                const t = r.knownActions;
                for (let i = 0, n = t.length; i !== n; ++i) {
                    const n = t[i];
                    this._deactivateAction(n);
                    const r = n._cacheIndex
                      , s = e[e.length - 1];
                    n._cacheIndex = null,
                    n._byClipCacheIndex = null,
                    s._cacheIndex = r,
                    e[r] = s,
                    e.pop(),
                    this._removeInactiveBindingsForAction(n)
                }
                delete n[i]
            }
        }
        uncacheRoot(t) {
            const e = t.uuid
              , i = this._actionsByClip;
            for (const t in i) {
                const n = i[t].actionByRoot[e];
                void 0 !== n && (this._deactivateAction(n),
                this._removeInactiveAction(n))
            }
            const n = this._bindingsByRootAndName[e];
            if (void 0 !== n)
                for (const t in n) {
                    const e = n[t];
                    e.restoreOriginalState(),
                    this._removeInactiveBinding(e)
                }
        }
        uncacheAction(t, e) {
            const i = this.existingAction(t, e);
            null !== i && (this._deactivateAction(i),
            this._removeInactiveAction(i))
        }
    }
    ).prototype._controlInterpolantsResultBuffer = new Float32Array(1);
    (class extends fm {
        constructor(t, e, i=1) {
            super(t, e),
            this.meshPerAttribute = i || 1
        }
        copy(t) {
            return super.copy(t),
            this.meshPerAttribute = t.meshPerAttribute,
            this
        }
        clone(t) {
            const e = super.clone(t);
            return e.meshPerAttribute = this.meshPerAttribute,
            e
        }
        toJSON(t) {
            const e = super.toJSON(t);
            return e.isInstancedInterleavedBuffer = !0,
            e.meshPerAttribute = this.meshPerAttribute,
            e
        }
    }
    ).prototype.isInstancedInterleavedBuffer = !0;
    (class extends Au {
        constructor(t) {
            super(),
            this.material = t,
            this.render = function() {}
            ,
            this.hasPositions = !1,
            this.hasNormals = !1,
            this.hasColors = !1,
            this.hasUvs = !1,
            this.positionArray = null,
            this.normalArray = null,
            this.colorArray = null,
            this.uvArray = null,
            this.count = 0
        }
    }
    ).prototype.isImmediateRenderObject = !0;
    const sy = new Eh
      , ay = new nu
      , oy = new nu;
    function ly(t) {
        const e = [];
        t && t.isBone && e.push(t);
        for (let i = 0; i < t.children.length; i++)
            e.push.apply(e, ly(t.children[i]));
        return e
    }
    const cy = new Float32Array(1);
    new Int32Array(cy.buffer);
    const hy = new Ku({
        side: Eo,
        depthWrite: !1,
        depthTest: !1
    });
    new Id(new Nd,hy),
    av.create = function(t, e) {
        return console.log("THREE.Curve.create() has been deprecated"),
        t.prototype = Object.create(av.prototype),
        t.prototype.constructor = t,
        t.prototype.getPoint = e,
        t
    }
    ,
    Ev.prototype.fromPoints = function(t) {
        return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),
        this.setFromPoints(t)
    }
    ,
    class extends Qm {
        constructor(t=10, e=10, i=4473924, n=8947848) {
            i = new $u(i),
            n = new $u(n);
            const r = e / 2
              , s = t / e
              , a = t / 2
              , o = []
              , l = [];
            for (let t = 0, c = 0, h = -a; t <= e; t++,
            h += s) {
                o.push(-a, 0, h, a, 0, h),
                o.push(h, 0, -a, h, 0, a);
                const e = t === r ? i : n;
                e.toArray(l, c),
                c += 3,
                e.toArray(l, c),
                c += 3,
                e.toArray(l, c),
                c += 3,
                e.toArray(l, c),
                c += 3
            }
            const c = new fd;
            c.setAttribute("position", new sd(o,3)),
            c.setAttribute("color", new sd(l,3));
            super(c, new Gm({
                vertexColors: !0,
                toneMapped: !1
            })),
            this.type = "GridHelper"
        }
    }
    .prototype.setColors = function() {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
    }
    ,
    class extends Qm {
        constructor(t) {
            const e = ly(t)
              , i = new fd
              , n = []
              , r = []
              , s = new $u(0,0,1)
              , a = new $u(0,1,0);
            for (let t = 0; t < e.length; t++) {
                const i = e[t];
                i.parent && i.parent.isBone && (n.push(0, 0, 0),
                n.push(0, 0, 0),
                r.push(s.r, s.g, s.b),
                r.push(a.r, a.g, a.b))
            }
            i.setAttribute("position", new sd(n,3)),
            i.setAttribute("color", new sd(r,3));
            super(i, new Gm({
                vertexColors: !0,
                depthTest: !1,
                depthWrite: !1,
                toneMapped: !1,
                transparent: !0
            })),
            this.type = "SkeletonHelper",
            this.isSkeletonHelper = !0,
            this.root = t,
            this.bones = e,
            this.matrix = t.matrixWorld,
            this.matrixAutoUpdate = !1
        }
        updateMatrixWorld(t) {
            const e = this.bones
              , i = this.geometry
              , n = i.getAttribute("position");
            oy.copy(this.root.matrixWorld).invert();
            for (let t = 0, i = 0; t < e.length; t++) {
                const r = e[t];
                r.parent && r.parent.isBone && (ay.multiplyMatrices(oy, r.matrixWorld),
                sy.setFromMatrixPosition(ay),
                n.setXYZ(i, sy.x, sy.y, sy.z),
                ay.multiplyMatrices(oy, r.parent.matrixWorld),
                sy.setFromMatrixPosition(ay),
                n.setXYZ(i + 1, sy.x, sy.y, sy.z),
                i += 2)
            }
            i.getAttribute("position").needsUpdate = !0,
            super.updateMatrixWorld(t)
        }
    }
    .prototype.update = function() {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
    }
    ,
    tv.prototype.extractUrlBase = function(t) {
        return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),
        Gv.extractUrlBase(t)
    }
    ,
    tv.Handlers = {
        add: function() {
            console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
        },
        get: function() {
            console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
        }
    },
    Ch.prototype.center = function(t) {
        return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),
        this.getCenter(t)
    }
    ,
    Ch.prototype.empty = function() {
        return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
        this.isEmpty()
    }
    ,
    Ch.prototype.isIntersectionBox = function(t) {
        return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),
        this.intersectsBox(t)
    }
    ,
    Ch.prototype.isIntersectionSphere = function(t) {
        return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
        this.intersectsSphere(t)
    }
    ,
    Ch.prototype.size = function(t) {
        return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
        this.getSize(t)
    }
    ,
    Xh.prototype.empty = function() {
        return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),
        this.isEmpty()
    }
    ,
    Xd.prototype.setFromMatrix = function(t) {
        return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),
        this.setFromProjectionMatrix(t)
    }
    ,
    vh.prototype.flattenToArrayOffset = function(t, e) {
        return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
        this.toArray(t, e)
    }
    ,
    vh.prototype.multiplyVector3 = function(t) {
        return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),
        t.applyMatrix3(this)
    }
    ,
    vh.prototype.multiplyVector3Array = function() {
        console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
    }
    ,
    vh.prototype.applyToBufferAttribute = function(t) {
        return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),
        t.applyMatrix3(this)
    }
    ,
    vh.prototype.applyToVector3Array = function() {
        console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
    }
    ,
    vh.prototype.getInverse = function(t) {
        return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),
        this.copy(t).invert()
    }
    ,
    nu.prototype.extractPosition = function(t) {
        return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),
        this.copyPosition(t)
    }
    ,
    nu.prototype.flattenToArrayOffset = function(t, e) {
        return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
        this.toArray(t, e)
    }
    ,
    nu.prototype.getPosition = function() {
        return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),
        (new Eh).setFromMatrixColumn(this, 3)
    }
    ,
    nu.prototype.setRotationFromQuaternion = function(t) {
        return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),
        this.makeRotationFromQuaternion(t)
    }
    ,
    nu.prototype.multiplyToArray = function() {
        console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
    }
    ,
    nu.prototype.multiplyVector3 = function(t) {
        return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),
        t.applyMatrix4(this)
    }
    ,
    nu.prototype.multiplyVector4 = function(t) {
        return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),
        t.applyMatrix4(this)
    }
    ,
    nu.prototype.multiplyVector3Array = function() {
        console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
    }
    ,
    nu.prototype.rotateAxis = function(t) {
        console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),
        t.transformDirection(this)
    }
    ,
    nu.prototype.crossVector = function(t) {
        return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),
        t.applyMatrix4(this)
    }
    ,
    nu.prototype.translate = function() {
        console.error("THREE.Matrix4: .translate() has been removed.")
    }
    ,
    nu.prototype.rotateX = function() {
        console.error("THREE.Matrix4: .rotateX() has been removed.")
    }
    ,
    nu.prototype.rotateY = function() {
        console.error("THREE.Matrix4: .rotateY() has been removed.")
    }
    ,
    nu.prototype.rotateZ = function() {
        console.error("THREE.Matrix4: .rotateZ() has been removed.")
    }
    ,
    nu.prototype.rotateByAxis = function() {
        console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
    }
    ,
    nu.prototype.applyToBufferAttribute = function(t) {
        return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),
        t.applyMatrix4(this)
    }
    ,
    nu.prototype.applyToVector3Array = function() {
        console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
    }
    ,
    nu.prototype.makeFrustum = function(t, e, i, n, r, s) {
        return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),
        this.makePerspective(t, e, n, i, r, s)
    }
    ,
    nu.prototype.getInverse = function(t) {
        return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),
        this.copy(t).invert()
    }
    ,
    Iu.prototype.isIntersectionLine = function(t) {
        return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),
        this.intersectsLine(t)
    }
    ,
    Th.prototype.multiplyVector3 = function(t) {
        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),
        t.applyQuaternion(this)
    }
    ,
    Th.prototype.inverse = function() {
        return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),
        this.invert()
    }
    ,
    iu.prototype.isIntersectionBox = function(t) {
        return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),
        this.intersectsBox(t)
    }
    ,
    iu.prototype.isIntersectionPlane = function(t) {
        return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),
        this.intersectsPlane(t)
    }
    ,
    iu.prototype.isIntersectionSphere = function(t) {
        return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
        this.intersectsSphere(t)
    }
    ,
    Vu.prototype.area = function() {
        return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),
        this.getArea()
    }
    ,
    Vu.prototype.barycoordFromPoint = function(t, e) {
        return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
        this.getBarycoord(t, e)
    }
    ,
    Vu.prototype.midpoint = function(t) {
        return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),
        this.getMidpoint(t)
    }
    ,
    Vu.prototypenormal = function(t) {
        return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
        this.getNormal(t)
    }
    ,
    Vu.prototype.plane = function(t) {
        return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),
        this.getPlane(t)
    }
    ,
    Vu.barycoordFromPoint = function(t, e, i, n, r) {
        return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
        Vu.getBarycoord(t, e, i, n, r)
    }
    ,
    Vu.normal = function(t, e, i, n) {
        return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
        Vu.getNormal(t, e, i, n)
    }
    ,
    Lv.prototype.extractAllPoints = function(t) {
        return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),
        this.extractPoints(t)
    }
    ,
    Lv.prototype.extrude = function(t) {
        return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),
        new Ig(this,t)
    }
    ,
    Lv.prototype.makeGeometry = function(t) {
        return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),
        new Ng(this,t)
    }
    ,
    gh.prototype.fromAttribute = function(t, e, i) {
        return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),
        this.fromBufferAttribute(t, e, i)
    }
    ,
    gh.prototype.distanceToManhattan = function(t) {
        return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
        this.manhattanDistanceTo(t)
    }
    ,
    gh.prototype.lengthManhattan = function() {
        return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),
        this.manhattanLength()
    }
    ,
    Eh.prototype.setEulerFromRotationMatrix = function() {
        console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
    }
    ,
    Eh.prototype.setEulerFromQuaternion = function() {
        console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
    }
    ,
    Eh.prototype.getPositionFromMatrix = function(t) {
        return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),
        this.setFromMatrixPosition(t)
    }
    ,
    Eh.prototype.getScaleFromMatrix = function(t) {
        return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),
        this.setFromMatrixScale(t)
    }
    ,
    Eh.prototype.getColumnFromMatrix = function(t, e) {
        return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),
        this.setFromMatrixColumn(e, t)
    }
    ,
    Eh.prototype.applyProjection = function(t) {
        return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),
        this.applyMatrix4(t)
    }
    ,
    Eh.prototype.fromAttribute = function(t, e, i) {
        return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),
        this.fromBufferAttribute(t, e, i)
    }
    ,
    Eh.prototype.distanceToManhattan = function(t) {
        return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
        this.manhattanDistanceTo(t)
    }
    ,
    Eh.prototype.lengthManhattan = function() {
        return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),
        this.manhattanLength()
    }
    ,
    Mh.prototype.fromAttribute = function(t, e, i) {
        return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),
        this.fromBufferAttribute(t, e, i)
    }
    ,
    Mh.prototype.lengthManhattan = function() {
        return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),
        this.manhattanLength()
    }
    ,
    Au.prototype.getChildByName = function(t) {
        return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),
        this.getObjectByName(t)
    }
    ,
    Au.prototype.renderDepth = function() {
        console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
    }
    ,
    Au.prototype.translate = function(t, e) {
        return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),
        this.translateOnAxis(e, t)
    }
    ,
    Au.prototype.getWorldRotation = function() {
        console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
    }
    ,
    Au.prototype.applyMatrix = function(t) {
        return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),
        this.applyMatrix4(t)
    }
    ,
    Object.defineProperties(Au.prototype, {
        eulerOrder: {
            get: function() {
                return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                this.rotation.order
            },
            set: function(t) {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                this.rotation.order = t
            }
        },
        useQuaternion: {
            get: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            },
            set: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            }
        }
    }),
    Id.prototype.setDrawMode = function() {
        console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
    }
    ,
    Object.defineProperties(Id.prototype, {
        drawMode: {
            get: function() {
                return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),
                0
            },
            set: function() {
                console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
            }
        }
    }),
    km.prototype.initBones = function() {
        console.error("THREE.SkinnedMesh: initBones() has been removed.")
    }
    ,
    Hd.prototype.setLens = function(t, e) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),
        void 0 !== e && (this.filmGauge = e),
        this.setFocalLength(t)
    }
    ,
    Object.defineProperties(Av.prototype, {
        onlyShadow: {
            set: function() {
                console.warn("THREE.Light: .onlyShadow has been removed.")
            }
        },
        shadowCameraFov: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),
                this.shadow.camera.fov = t
            }
        },
        shadowCameraLeft: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),
                this.shadow.camera.left = t
            }
        },
        shadowCameraRight: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),
                this.shadow.camera.right = t
            }
        },
        shadowCameraTop: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),
                this.shadow.camera.top = t
            }
        },
        shadowCameraBottom: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),
                this.shadow.camera.bottom = t
            }
        },
        shadowCameraNear: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),
                this.shadow.camera.near = t
            }
        },
        shadowCameraFar: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),
                this.shadow.camera.far = t
            }
        },
        shadowCameraVisible: {
            set: function() {
                console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
            }
        },
        shadowBias: {
            set: function(t) {
                console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
                this.shadow.bias = t
            }
        },
        shadowDarkness: {
            set: function() {
                console.warn("THREE.Light: .shadowDarkness has been removed.")
            }
        },
        shadowMapWidth: {
            set: function(t) {
                console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),
                this.shadow.mapSize.width = t
            }
        },
        shadowMapHeight: {
            set: function(t) {
                console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),
                this.shadow.mapSize.height = t
            }
        }
    }),
    Object.defineProperties(id.prototype, {
        length: {
            get: function() {
                return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),
                this.array.length
            }
        },
        dynamic: {
            get: function() {
                return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),
                this.usage === sh
            },
            set: function() {
                console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),
                this.setUsage(sh)
            }
        }
    }),
    id.prototype.setDynamic = function(t) {
        return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),
        this.setUsage(!0 === t ? sh : rh),
        this
    }
    ,
    id.prototype.copyIndicesArray = function() {
        console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
    }
    ,
    id.prototype.setArray = function() {
        console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
    }
    ,
    fd.prototype.addIndex = function(t) {
        console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),
        this.setIndex(t)
    }
    ,
    fd.prototype.addAttribute = function(t, e) {
        return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),
        e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),
        this.setIndex(e),
        this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),
        this.setAttribute(t, new id(e,arguments[2])))
    }
    ,
    fd.prototype.addDrawCall = function(t, e, i) {
        void 0 !== i && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),
        console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),
        this.addGroup(t, e)
    }
    ,
    fd.prototype.clearDrawCalls = function() {
        console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),
        this.clearGroups()
    }
    ,
    fd.prototype.computeOffsets = function() {
        console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
    }
    ,
    fd.prototype.removeAttribute = function(t) {
        return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),
        this.deleteAttribute(t)
    }
    ,
    fd.prototype.applyMatrix = function(t) {
        return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),
        this.applyMatrix4(t)
    }
    ,
    Object.defineProperties(fd.prototype, {
        drawcalls: {
            get: function() {
                return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),
                this.groups
            }
        },
        offsets: {
            get: function() {
                return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),
                this.groups
            }
        }
    }),
    fm.prototype.setDynamic = function(t) {
        return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),
        this.setUsage(!0 === t ? sh : rh),
        this
    }
    ,
    fm.prototype.setArray = function() {
        console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
    }
    ,
    Ig.prototype.getArrays = function() {
        console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
    }
    ,
    Ig.prototype.addShapeList = function() {
        console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")
    }
    ,
    Ig.prototype.addShape = function() {
        console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
    }
    ,
    pm.prototype.dispose = function() {
        console.error("THREE.Scene: .dispose() has been removed.")
    }
    ,
    Object.defineProperties(qu.prototype, {
        wrapAround: {
            get: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            },
            set: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            }
        },
        overdraw: {
            get: function() {
                console.warn("THREE.Material: .overdraw has been removed.")
            },
            set: function() {
                console.warn("THREE.Material: .overdraw has been removed.")
            }
        },
        wrapRGB: {
            get: function() {
                return console.warn("THREE.Material: .wrapRGB has been removed."),
                new $u
            }
        },
        shading: {
            get: function() {
                console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
            },
            set: function(t) {
                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                this.flatShading = 1 === t
            }
        },
        stencilMask: {
            get: function() {
                return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."),
                this.stencilFuncMask
            },
            set: function(t) {
                console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."),
                this.stencilFuncMask = t
            }
        }
    }),
    Object.defineProperties(Bd.prototype, {
        derivatives: {
            get: function() {
                return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                this.extensions.derivatives
            },
            set: function(t) {
                console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                this.extensions.derivatives = t
            }
        }
    }),
    dm.prototype.clearTarget = function(t, e, i, n) {
        console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),
        this.setRenderTarget(t),
        this.clear(e, i, n)
    }
    ,
    dm.prototype.animate = function(t) {
        console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),
        this.setAnimationLoop(t)
    }
    ,
    dm.prototype.getCurrentRenderTarget = function() {
        return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),
        this.getRenderTarget()
    }
    ,
    dm.prototype.getMaxAnisotropy = function() {
        return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),
        this.capabilities.getMaxAnisotropy()
    }
    ,
    dm.prototype.getPrecision = function() {
        return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),
        this.capabilities.precision
    }
    ,
    dm.prototype.resetGLState = function() {
        return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),
        this.state.reset()
    }
    ,
    dm.prototype.supportsFloatTextures = function() {
        return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),
        this.extensions.get("OES_texture_float")
    }
    ,
    dm.prototype.supportsHalfFloatTextures = function() {
        return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),
        this.extensions.get("OES_texture_half_float")
    }
    ,
    dm.prototype.supportsStandardDerivatives = function() {
        return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),
        this.extensions.get("OES_standard_derivatives")
    }
    ,
    dm.prototype.supportsCompressedTextureS3TC = function() {
        return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),
        this.extensions.get("WEBGL_compressed_texture_s3tc")
    }
    ,
    dm.prototype.supportsCompressedTexturePVRTC = function() {
        return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),
        this.extensions.get("WEBGL_compressed_texture_pvrtc")
    }
    ,
    dm.prototype.supportsBlendMinMax = function() {
        return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),
        this.extensions.get("EXT_blend_minmax")
    }
    ,
    dm.prototype.supportsVertexTextures = function() {
        return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),
        this.capabilities.vertexTextures
    }
    ,
    dm.prototype.supportsInstancedArrays = function() {
        return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),
        this.extensions.get("ANGLE_instanced_arrays")
    }
    ,
    dm.prototype.enableScissorTest = function(t) {
        console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),
        this.setScissorTest(t)
    }
    ,
    dm.prototype.initMaterial = function() {
        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
    }
    ,
    dm.prototype.addPrePlugin = function() {
        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
    }
    ,
    dm.prototype.addPostPlugin = function() {
        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
    }
    ,
    dm.prototype.updateShadowMap = function() {
        console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
    }
    ,
    dm.prototype.setFaceCulling = function() {
        console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
    }
    ,
    dm.prototype.allocTextureUnit = function() {
        console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
    }
    ,
    dm.prototype.setTexture = function() {
        console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
    }
    ,
    dm.prototype.setTexture2D = function() {
        console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
    }
    ,
    dm.prototype.setTextureCube = function() {
        console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
    }
    ,
    dm.prototype.getActiveMipMapLevel = function() {
        return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),
        this.getActiveMipmapLevel()
    }
    ,
    Object.defineProperties(dm.prototype, {
        shadowMapEnabled: {
            get: function() {
                return this.shadowMap.enabled
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),
                this.shadowMap.enabled = t
            }
        },
        shadowMapType: {
            get: function() {
                return this.shadowMap.type
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),
                this.shadowMap.type = t
            }
        },
        shadowMapCullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            }
        },
        context: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),
                this.getContext()
            }
        },
        vr: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),
                this.xr
            }
        },
        gammaInput: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),
                !1
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
            }
        },
        gammaOutput: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),
                !1
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),
                this.outputEncoding = !0 === t ? Yc : jc
            }
        },
        toneMappingWhitePoint: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),
                1
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")
            }
        }
    }),
    Object.defineProperties(im.prototype, {
        cullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            }
        },
        renderReverseSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            }
        },
        renderSingleSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            }
        }
    }),
    Object.defineProperties(Sh.prototype, {
        wrapS: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                this.texture.wrapS
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                this.texture.wrapS = t
            }
        },
        wrapT: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                this.texture.wrapT
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                this.texture.wrapT = t
            }
        },
        magFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                this.texture.magFilter
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                this.texture.magFilter = t
            }
        },
        minFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                this.texture.minFilter
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                this.texture.minFilter = t
            }
        },
        anisotropy: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                this.texture.anisotropy
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                this.texture.anisotropy = t
            }
        },
        offset: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                this.texture.offset
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                this.texture.offset = t
            }
        },
        repeat: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                this.texture.repeat
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                this.texture.repeat = t
            }
        },
        format: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                this.texture.format
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                this.texture.format = t
            }
        },
        type: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                this.texture.type
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                this.texture.type = t
            }
        },
        generateMipmaps: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                this.texture.generateMipmaps
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                this.texture.generateMipmaps = t
            }
        }
    }),
    class extends Au {
        constructor(t) {
            super(),
            this.type = "Audio",
            this.listener = t,
            this.context = t.context,
            this.gain = this.context.createGain(),
            this.gain.connect(t.getInput()),
            this.autoplay = !1,
            this.buffer = null,
            this.detune = 0,
            this.loop = !1,
            this.loopStart = 0,
            this.loopEnd = 0,
            this.offset = 0,
            this.duration = void 0,
            this.playbackRate = 1,
            this.isPlaying = !1,
            this.hasPlaybackControl = !0,
            this.source = null,
            this.sourceType = "empty",
            this._startedAt = 0,
            this._progress = 0,
            this._connected = !1,
            this.filters = []
        }
        getOutput() {
            return this.gain
        }
        setNodeSource(t) {
            return this.hasPlaybackControl = !1,
            this.sourceType = "audioNode",
            this.source = t,
            this.connect(),
            this
        }
        setMediaElementSource(t) {
            return this.hasPlaybackControl = !1,
            this.sourceType = "mediaNode",
            this.source = this.context.createMediaElementSource(t),
            this.connect(),
            this
        }
        setMediaStreamSource(t) {
            return this.hasPlaybackControl = !1,
            this.sourceType = "mediaStreamNode",
            this.source = this.context.createMediaStreamSource(t),
            this.connect(),
            this
        }
        setBuffer(t) {
            return this.buffer = t,
            this.sourceType = "buffer",
            this.autoplay && this.play(),
            this
        }
        play(t=0) {
            if (!0 === this.isPlaying)
                return void console.warn("THREE.Audio: Audio is already playing.");
            if (!1 === this.hasPlaybackControl)
                return void console.warn("THREE.Audio: this Audio has no playback control.");
            this._startedAt = this.context.currentTime + t;
            const e = this.context.createBufferSource();
            return e.buffer = this.buffer,
            e.loop = this.loop,
            e.loopStart = this.loopStart,
            e.loopEnd = this.loopEnd,
            e.onended = this.onEnded.bind(this),
            e.start(this._startedAt, this._progress + this.offset, this.duration),
            this.isPlaying = !0,
            this.source = e,
            this.setDetune(this.detune),
            this.setPlaybackRate(this.playbackRate),
            this.connect()
        }
        pause() {
            if (!1 !== this.hasPlaybackControl)
                return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate,
                !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)),
                this.source.stop(),
                this.source.onended = null,
                this.isPlaying = !1),
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        }
        stop() {
            if (!1 !== this.hasPlaybackControl)
                return this._progress = 0,
                this.source.stop(),
                this.source.onended = null,
                this.isPlaying = !1,
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        }
        connect() {
            if (this.filters.length > 0) {
                this.source.connect(this.filters[0]);
                for (let t = 1, e = this.filters.length; t < e; t++)
                    this.filters[t - 1].connect(this.filters[t]);
                this.filters[this.filters.length - 1].connect(this.getOutput())
            } else
                this.source.connect(this.getOutput());
            return this._connected = !0,
            this
        }
        disconnect() {
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (let t = 1, e = this.filters.length; t < e; t++)
                    this.filters[t - 1].disconnect(this.filters[t]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else
                this.source.disconnect(this.getOutput());
            return this._connected = !1,
            this
        }
        getFilters() {
            return this.filters
        }
        setFilters(t) {
            return t || (t = []),
            !0 === this._connected ? (this.disconnect(),
            this.filters = t.slice(),
            this.connect()) : this.filters = t.slice(),
            this
        }
        setDetune(t) {
            if (this.detune = t,
            void 0 !== this.source.detune)
                return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
                this
        }
        getDetune() {
            return this.detune
        }
        getFilter() {
            return this.getFilters()[0]
        }
        setFilter(t) {
            return this.setFilters(t ? [t] : [])
        }
        setPlaybackRate(t) {
            if (!1 !== this.hasPlaybackControl)
                return this.playbackRate = t,
                !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        }
        getPlaybackRate() {
            return this.playbackRate
        }
        onEnded() {
            this.isPlaying = !1
        }
        getLoop() {
            return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."),
            !1) : this.loop
        }
        setLoop(t) {
            if (!1 !== this.hasPlaybackControl)
                return this.loop = t,
                !0 === this.isPlaying && (this.source.loop = this.loop),
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        }
        setLoopStart(t) {
            return this.loopStart = t,
            this
        }
        setLoopEnd(t) {
            return this.loopEnd = t,
            this
        }
        getVolume() {
            return this.gain.gain.value
        }
        setVolume(t) {
            return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01),
            this
        }
    }
    .prototype.load = function(t) {
        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
        const e = this;
        return (new qv).load(t, (function(t) {
            e.setBuffer(t)
        }
        )),
        this
    }
    ,
    Gd.prototype.updateCubeMap = function(t, e) {
        return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
        this.update(t, e)
    }
    ,
    Gd.prototype.clear = function(t, e, i, n) {
        return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),
        this.renderTarget.clear(t, e, i, n)
    }
    ,
    xh.crossOrigin = void 0,
    xh.loadTexture = function(t, e, i, n) {
        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
        const r = new sv;
        r.setCrossOrigin(this.crossOrigin);
        const s = r.load(t, i, void 0, n);
        return e && (s.mapping = e),
        s
    }
    ,
    xh.loadTextureCube = function(t, e, i, n) {
        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
        const r = new rv;
        r.setCrossOrigin(this.crossOrigin);
        const s = r.load(t, i, void 0, n);
        return e && (s.mapping = e),
        s
    }
    ,
    xh.loadCompressedTexture = function() {
        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
    }
    ,
    xh.loadCompressedTextureCube = function() {
        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
    }
    ,
    "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
        detail: {
            revision: "128"
        }
    })),
    "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "128");
    const uy = "precision highp float;\n    attribute vec2 position;\n    void main() {\n      // Look ma! no projection matrix multiplication,\n      // because we pass the values directly in clip space coordinates.\n      gl_Position = vec4(position, 1.0, 1.0);\n    }";
    class dy {
        constructor(t) {
            this.pos = t
        }
        init404() {
            this.W4 = document.querySelector(".webgl404").offsetWidth,
            this.H4 = document.querySelector(".webgl404").offsetHeight,
            this.step = 0,
            this.array4 = [],
            this.scene4 = new pm,
            this.ratio = this.W4 / this.H4,
            this.scene4.background = new $u(592138),
            this.camera4 = new Bv(-this.ratio,this.ratio,1,-1,-1,1),
            this.renderer4 = new dm({
                antialias: !0
            }),
            this.renderer4.setSize(this.W4, this.H4),
            this.renderer4.setPixelRatio(Math.min(window.devicePixelRatio, 2)),
            document.querySelector(".webgl404").appendChild(this.renderer4.domElement),
            this.ratio < 1 && (this.ratio = 3 * this.ratio);
            const t = .58 * this.ratio;
            this.heightGeo = 4.71 * this.ratio;
            const e = new Qd(t,this.heightGeo)
              , i = (new sv).load("", ( () => {
                this.step++,
                this.testStep()
            }
            ))
              , n = (new sv).load("", ( () => {
                this.step++,
                this.testStep()
            }
            ))
              , r = (new sv).load("", ( () => {
                this.step++,
                this.testStep()
            }
            ))
              , s = new Ku({
                map: i
            })
              , a = new Ku({
                map: n
            })
              , o = new Ku({
                map: r
            });
            this.col1 = new Id(e,s),
            this.col1.position.set(.71 * -this.ratio, 1, 0),
            this.col2 = new Id(e,a),
            this.col2.position.set(.085 * -this.ratio, .5, 0),
            this.col3 = new Id(e,o),
            this.col3.position.set(.54 * this.ratio, 0, 0),
            this.col4 = new Id(e,s),
            this.col4.position.set(1.165 * this.ratio, -.5, 0),
            this.scene4.add(this.col1, this.col2, this.col3, this.col4),
            this.array4.push(this.col1, this.col2, this.col3, this.col4),
            this.y1Set = Xn.quickSetter(this.col1.position, "y"),
            this.y2Set = Xn.quickSetter(this.col2.position, "y"),
            this.y3Set = Xn.quickSetter(this.col3.position, "y"),
            this.y4Set = Xn.quickSetter(this.col4.position, "y"),
            this.posY1 = 0,
            this.posY2 = .5,
            this.posY3 = -.5,
            this.posY4 = .2,
            this.varia1 = 0,
            this.varia2 = 0,
            this.varia3 = 0,
            this.varia4 = 0,
            this.deltaY = 0,
            this.dTrans = 0,
            this.constructorPost(this.renderer4),
            this.inten = Xn.quickSetter(this.materialP.uniforms.uIntensite, "value"),
            this.trans = Xn.quickSetter(this.materialP.uniforms.uTranslate, "value"),
            this.raf404()
        }
        testStep() {
            3 == this.step && Xn.to(".webgl404", {
                opacity: .75,
                duration: 1,
                delay: .2,
                ease: "power2.inOut"
            })
        }
        wheel() {
            window.addEventListener("wheel", this.ref = t => {
                this.deltaY = t.deltaY,
                window.clearTimeout(this.isWheeling),
                this.isWheeling = setTimeout((t => {
                    this.deltaY = 0
                }
                ), 66)
            }
            , {
                passive: !0
            })
        }
        touchmove() {
            let t = 0
              , e = 0
              , i = !0;
            window.addEventListener("touchmove", this.ref = n => {
                e = n.touches[0].clientY - t,
                i || (this.deltaY = 5 * -e),
                i = !1,
                t = n.touches[0].clientY,
                window.clearTimeout(this.isWheeling),
                this.isWheeling = setTimeout((n => {
                    this.deltaY = 0,
                    e = 0,
                    t = 0,
                    i = !0
                }
                ), 66)
            }
            , {
                passive: !0
            })
        }
        unwheel() {
            window.removeEventListener("wheel", this.ref)
        }
        untouchmove() {
            window.removeEventListener("touchmove", this.ref)
        }
        playTicker404() {
            const t = Xn.ticker.deltaRatio()
              , e = 1 - Math.pow(.9, t);
            this.y1Set(this.posY1),
            this.y2Set(this.posY2),
            this.y3Set(this.posY3),
            this.y4Set(this.posY4),
            window.scrollTo(0, 0),
            this.varia1 / 2 > .07 ? this.inten(.07) : this.varia1 / 2 < -.07 ? this.inten(-.07) : this.inten(this.varia1 / 2),
            this.trans(4 * -this.dTrans),
            this.varia1 += (this.deltaY / 900 - this.varia1) * e,
            this.posY1 += this.varia1 + t / 900,
            this.dTrans += this.varia1,
            this.varia2 += (this.deltaY / 700 - this.varia2) * e,
            this.posY2 += this.varia2 + t / 800,
            this.varia3 += (this.deltaY / 1200 - this.varia3) * e,
            this.posY3 += this.varia3 + t / 1200,
            this.varia4 += (this.deltaY / 850 - this.varia4) * e,
            this.posY4 += this.varia4 + t / 850,
            this.col1.position.y > (this.heightGeo - 2) / 2 && (this.posY1 = this.posY1 - this.heightGeo / 2),
            this.col1.position.y < -(this.heightGeo - 2) / 2 && (this.posY1 = this.posY1 + this.heightGeo / 2),
            this.col2.position.y > (this.heightGeo - 2) / 2 && (this.posY2 = this.posY2 - this.heightGeo / 2),
            this.col2.position.y < -(this.heightGeo - 2) / 2 && (this.posY2 = this.posY2 + this.heightGeo / 2),
            this.col3.position.y > (this.heightGeo - 2) / 2 && (this.posY3 = this.posY3 - this.heightGeo / 2),
            this.col3.position.y < -(this.heightGeo - 2) / 2 && (this.posY3 = this.posY3 + this.heightGeo / 2),
            this.col4.position.y > (this.heightGeo - 2) / 2 && (this.posY4 = this.posY4 - this.heightGeo / 2),
            this.col4.position.y < -(this.heightGeo - 2) / 2 && (this.posY4 = this.posY4 + this.heightGeo / 2),
            this.renderPost(this.scene4, this.camera4)
        }
        initJoin() {
            this.WJ = document.querySelector(".innerCan").offsetWidth,
            this.HJ = document.querySelector(".innerCan").offsetHeight,
            this.sceneJ = new pm,
            this.cameraJ = new Bv(-this.WJ / this.HJ,this.WJ / this.HJ,1,-1,-1,1),
            this.rendererJ = new dm({
                antialias: !0,
                alpha: !0
            }),
            this.rendererJ.setSize(this.WJ, this.HJ),
            this.rendererJ.setPixelRatio(Math.min(window.devicePixelRatio, 2)),
            document.querySelector(".innerCan").appendChild(this.rendererJ.domElement);
            const t = new Qd(2,2);
            let e = "img/cards/08.jpg";
            document.body.classList.contains("about") && (e = "img/");
            const i = (new sv).load(e, ( () => {
                Xn.to(".innerCan", {
                    opacity: 1,
                    delay: .4,
                    duration: 1
                }),
                null != document.querySelector(".innerCan .volet") && Xn.to(".innerCan .volet", {
                    scaleY: 0,
                    delay: .4,
                    duration: 2,
                    ease: "power4.out"
                }),
                Xn.to(".innerCan canvas, .looking p", {
                    y: 0,
                    delay: .4,
                    stagger: .2,
                    opacity: 1,
                    duration: 2,
                    ease: "power4.out"
                }),
                this.constructorPost(this.rendererJ),
                this.renderPost(this.sceneJ, this.cameraJ)
            }
            ))
              , n = new Ku({
                map: i
            })
              , r = new Id(t,n);
            this.sceneJ.add(r)
        }
        init() {
            this.W = window.innerWidth,
            this.H = document.getElementById("footer2").offsetHeight,
            this.table = [],
            this.zIndex = 0,
            this.speed = .1,
            this.varX = 0,
            this.varY = 0,
            this.oldX = 0,
            this.incrDist = 0,
            this.currentItem = 0;
            let t = "";
            document.body.classList.contains("single") && (t = "../");
            const e = (new sv).load(t + "", ( () => {
                this.renderPost(this.scene, this.camera)
            }
            ))
              , i = (new sv).load(t + "", ( () => {
                this.renderPost(this.scene, this.camera),
                this.cube02.visible = !1
            }
            ))
              , n = (new sv).load(t + "", ( () => {
                this.renderPost(this.scene, this.camera),
                this.cube03.visible = !1
            }
            ))
              , r = (new sv).load(t + "", ( () => {
                this.renderPost(this.scene, this.camera),
                this.cube04.visible = !1
            }
            ))
              , s = (new sv).load(t + "", ( () => {
                this.renderPost(this.scene, this.camera),
                this.cube05.visible = !1
            }
            ))
              , a = (new sv).load(t + "", ( () => {
                this.renderPost(this.scene, this.camera),
                this.cube06.visible = !1
            }
            ))
              , o = (new sv).load(t + "", ( () => {
                this.renderPost(this.scene, this.camera),
                this.cube07.visible = !1
            }
            ))
              , l = (new sv).load(t + "", ( () => {
                this.renderPost(this.scene, this.camera),
                this.cube08.visible = !1
            }
            ))
              , c = (new sv).load(t + "", ( () => {
                this.renderPost(this.scene, this.camera),
                this.cube09.visible = !1
            }
            ))
              , h = (new sv).load(t + "", ( () => {
                this.renderPost(this.scene, this.camera),
                this.cube10.visible = !1
            }
            ))
              , u = (new sv).load(t + "", ( () => {
                this.renderPost(this.scene, this.camera),
                this.cube11.visible = !1
            }
            ));
            this.scene = new pm,
            this.scene.background = new $u(0),
            this.camera = new Bv(-this.W / this.H,this.W / this.H,1,-1,-1,1),
            this.renderer = new dm({
                antialias: !0
            }),
            this.renderer.setSize(this.W, this.H),
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)),
            document.getElementById("webgl").appendChild(this.renderer.domElement);
            const d = new Qd(1,1)
              , p = new Ku({
                map: e
            })
              , f = new Ku({
                map: i
            })
              , m = new Ku({
                map: n
            })
              , g = new Ku({
                map: r
            })
              , v = new Ku({
                map: s
            })
              , y = new Ku({
                map: a
            })
              , x = new Ku({
                map: o
            })
              , _ = new Ku({
                map: l
            })
              , w = new Ku({
                map: c
            })
              , b = new Ku({
                map: h
            })
              , M = new Ku({
                map: u
            });
            this.cube01 = new Id(d,p),
            this.cube02 = new Id(d,f),
            this.cube03 = new Id(d,m),
            this.cube04 = new Id(d,g),
            this.cube05 = new Id(d,v),
            this.cube06 = new Id(d,y),
            this.cube07 = new Id(d,x),
            this.cube08 = new Id(d,_),
            this.cube09 = new Id(d,w),
            this.cube10 = new Id(d,b),
            this.cube11 = new Id(d,M),
            this.cube01.material.transparent = this.cube02.material.transparent = this.cube03.material.transparent = this.cube04.material.transparent = this.cube05.material.transparent = this.cube06.material.transparent = this.cube07.material.transparent = this.cube08.material.transparent = this.cube09.material.transparent = this.cube10.material.transparent = this.cube11.material.transparent = !0,
            this.table.push(this.cube01, this.cube02, this.cube03, this.cube04, this.cube05, this.cube06, this.cube07, this.cube08, this.cube09, this.cube10, this.cube11),
            this.scene.add(this.cube01, this.cube02, this.cube03, this.cube04, this.cube05, this.cube06, this.cube07, this.cube08, this.cube09, this.cube10, this.cube11),
            this.mX01 = Xn.quickSetter(this.cube01.position, "x"),
            this.mY01 = Xn.quickSetter(this.cube01.position, "y"),
            this.mX02 = Xn.quickSetter(this.cube02.position, "x"),
            this.mY02 = Xn.quickSetter(this.cube02.position, "y"),
            this.mX03 = Xn.quickSetter(this.cube03.position, "x"),
            this.mY03 = Xn.quickSetter(this.cube03.position, "y"),
            this.mX04 = Xn.quickSetter(this.cube04.position, "x"),
            this.mY04 = Xn.quickSetter(this.cube04.position, "y"),
            this.mX05 = Xn.quickSetter(this.cube05.position, "x"),
            this.mY05 = Xn.quickSetter(this.cube05.position, "y"),
            this.mX06 = Xn.quickSetter(this.cube06.position, "x"),
            this.mY06 = Xn.quickSetter(this.cube06.position, "y"),
            this.mX07 = Xn.quickSetter(this.cube07.position, "x"),
            this.mY07 = Xn.quickSetter(this.cube07.position, "y"),
            this.mX08 = Xn.quickSetter(this.cube08.position, "x"),
            this.mY08 = Xn.quickSetter(this.cube08.position, "y"),
            this.mX09 = Xn.quickSetter(this.cube09.position, "x"),
            this.mY09 = Xn.quickSetter(this.cube09.position, "y"),
            this.mX10 = Xn.quickSetter(this.cube10.position, "x"),
            this.mY10 = Xn.quickSetter(this.cube10.position, "y"),
            this.mX11 = Xn.quickSetter(this.cube11.position, "x"),
            this.mY11 = Xn.quickSetter(this.cube11.position, "y"),
            this.constructorPost(this.renderer)
        }
        fondHome() {
            this.scene.background = new $u(1250067)
        }
        fondAutreQueHome() {
            this.scene.background = new $u(0)
        }
        raf() {
            this.addTicker = () => {
                this.playTicker()
            }
            ,
            Xn.ticker.add(this.addTicker)
        }
        killRaf() {
            Xn.ticker.remove(this.addTicker)
        }
        raf404() {
            this.addTicker404 = () => {
                this.playTicker404()
            }
            ,
            Xn.ticker.add(this.addTicker404)
        }
        killRaf404() {
            Xn.ticker.remove(this.addTicker404)
        }
        constructorPost(t) {
            this.rendererP = t,
            this.sceneP = new pm,
            this.dummyCameraP = new Bv,
            this.geometryP = new fd;
            const e = new Float32Array([-1, -1, 3, -1, -1, 3]);
            this.geometryP.setAttribute("position", new id(e,2)),
            this.resolutionP = new gh,
            this.rendererP.getDrawingBufferSize(this.resolutionP),
            this.targetP = new Sh(this.resolutionP.x,this.resolutionP.y,{
                format: Ul,
                stencilBuffer: !1,
                depthBuffer: !0
            }),
            t == this.renderer ? this.materialP = new Og({
                fragmentShader: "precision highp float;\n    uniform sampler2D uScene;\n    uniform vec2 uResolution;\n\n    void main() {\n        vec2 uv = gl_FragCoord.xy / uResolution.xy;\n        vec3 color = vec3(uv, 1.0);\n        uv.x += sin(uv.x*40.0)/50.0;\n\n        color = texture2D(uScene, uv).rgb;\n\n        gl_FragColor = vec4(color, 1.0);\n    }",
                vertexShader: uy,
                uniforms: {
                    uScene: {
                        value: this.targetP.texture
                    },
                    uResolution: {
                        value: this.resolutionP
                    }
                }
            }) : t == this.rendererJ ? this.materialP = new Og({
                fragmentShader: "precision highp float;\n    uniform sampler2D uScene;\n    uniform vec2 uResolution;\n    uniform float uTranslate;\n\n    void main() {\n        vec2 uv = gl_FragCoord.xy / uResolution.xy;\n        vec3 color = vec3(uv, 1.0);\n        uv.y += sin(uv.y*10.0 + uTranslate)/15.0;\n\n        color = texture2D(uScene, uv).rgb;\n\n        gl_FragColor = vec4(color, 1.0);\n    }",
                vertexShader: uy,
                uniforms: {
                    uScene: {
                        value: this.targetP.texture
                    },
                    uResolution: {
                        value: this.resolutionP
                    },
                    uTranslate: {
                        value: 0
                    }
                }
            }) : t == this.renderer4 && (this.materialP = new Og({
                fragmentShader: "precision highp float;\n    uniform sampler2D uScene;\n    uniform vec2 uResolution;\n    uniform float uTranslate;\n    uniform float uIntensite;\n\n    void main() {\n        vec2 uv = gl_FragCoord.xy / uResolution.xy;\n        vec3 color = vec3(uv, 1.0);\n        uv.y += sin(uv.y*14.0 + uTranslate) * uIntensite;\n\n        color = texture2D(uScene, uv).rgb;\n\n        gl_FragColor = vec4(color, 1.0);\n    }",
                vertexShader: uy,
                uniforms: {
                    uScene: {
                        value: this.targetP.texture
                    },
                    uResolution: {
                        value: this.resolutionP
                    },
                    uTranslate: {
                        value: 0
                    },
                    uIntensite: {
                        value: 0
                    }
                }
            })),
            this.triangleP = new Id(this.geometryP,this.materialP),
            this.triangleP.frustumCulled = !1,
            this.sceneP.add(this.triangleP)
        }
        renderPost(t, e) {
            this.rendererP.setRenderTarget(this.targetP),
            this.rendererP.render(t, e),
            this.rendererP.setRenderTarget(null),
            this.rendererP.render(this.sceneP, this.dummyCameraP)
        }
        playTicker() {
            const t = 1 - Math.pow(1 - this.speed, Xn.ticker.deltaRatio())
              , e = Xn.utils.mapRange(0, this.W, -this.W / this.H, this.W / this.H, this.pos.x)
              , i = Xn.utils.mapRange(0, this.H, 1, -1, this.pos.y - document.getElementById("webgl").getBoundingClientRect().top);
            if (this.varX += (e - this.varX) * t,
            this.varY += (i - this.varY) * t,
            0 == this.currentItem ? (this.mX01(this.varX),
            this.mY01(this.varY)) : 1 == this.currentItem ? (this.mX02(this.varX),
            this.mY02(this.varY)) : 2 == this.currentItem ? (this.mX03(this.varX),
            this.mY03(this.varY)) : 3 == this.currentItem ? (this.mX04(this.varX),
            this.mY04(this.varY)) : 4 == this.currentItem ? (this.mX05(this.varX),
            this.mY05(this.varY)) : 5 == this.currentItem ? (this.mX06(this.varX),
            this.mY06(this.varY)) : 6 == this.currentItem ? (this.mX07(this.varX),
            this.mY07(this.varY)) : 7 == this.currentItem ? (this.mX08(this.varX),
            this.mY08(this.varY)) : 8 == this.currentItem ? (this.mX09(this.varX),
            this.mY09(this.varY)) : 9 == this.currentItem ? (this.mX10(this.varX),
            this.mY10(this.varY)) : 10 == this.currentItem && (this.mX11(this.varX),
            this.mY11(this.varY)),
            this.renderPost(this.scene, this.camera),
            this.incrDist += Math.abs(this.oldX - this.varX),
            this.incrDist > .25) {
                this.incrDist = 0;
                const t = this.table[this.currentItem];
                Xn.to(t.position, {
                    duration: .8,
                    y: -1.5,
                    x: this.oldX - this.varX,
                    ease: "power2.in",
                    onComplete: () => {
                        t.visible = !1
                    }
                }),
                Xn.to(t.scale, {
                    duration: .8,
                    x: .7,
                    y: .7,
                    ease: "power2.in"
                }),
                this.currentItem++,
                this.currentItem >= 11 && (this.currentItem = 0),
                Xn.killTweensOf(this.table[this.currentItem].position),
                Xn.killTweensOf(this.table[this.currentItem].scale),
                this.table[this.currentItem].position.x = this.table[this.currentItem].position.y = 0,
                this.table[this.currentItem].scale.x = this.table[this.currentItem].scale.y = 1,
                this.table[this.currentItem].visible = !0,
                this.zIndex++,
                this.table[this.currentItem].renderOrder = this.zIndex
            }
            this.oldX = this.varX
        }
    }
    function py(t) {
        return null !== t && "object" == typeof t && "constructor"in t && t.constructor === Object
    }
    function fy(t, e) {
        void 0 === t && (t = {}),
        void 0 === e && (e = {}),
        Object.keys(e).forEach((i => {
            void 0 === t[i] ? t[i] = e[i] : py(e[i]) && py(t[i]) && Object.keys(e[i]).length > 0 && fy(t[i], e[i])
        }
        ))
    }
    const my = {
        body: {},
        addEventListener() {},
        removeEventListener() {},
        activeElement: {
            blur() {},
            nodeName: ""
        },
        querySelector: () => null,
        querySelectorAll: () => [],
        getElementById: () => null,
        createEvent: () => ({
            initEvent() {}
        }),
        createElement: () => ({
            children: [],
            childNodes: [],
            style: {},
            setAttribute() {},
            getElementsByTagName: () => []
        }),
        createElementNS: () => ({}),
        importNode: () => null,
        location: {
            hash: "",
            host: "",
            hostname: "",
            href: "",
            origin: "",
            pathname: "",
            protocol: "",
            search: ""
        }
    };
    function gy() {
        const t = "undefined" != typeof document ? document : {};
        return fy(t, my),
        t
    }
    const vy = {
        document: my,
        navigator: {
            userAgent: ""
        },
        location: {
            hash: "",
            host: "",
            hostname: "",
            href: "",
            origin: "",
            pathname: "",
            protocol: "",
            search: ""
        },
        history: {
            replaceState() {},
            pushState() {},
            go() {},
            back() {}
        },
        CustomEvent: function() {
            return this
        },
        addEventListener() {},
        removeEventListener() {},
        getComputedStyle: () => ({
            getPropertyValue: () => ""
        }),
        Image() {},
        Date() {},
        screen: {},
        setTimeout() {},
        clearTimeout() {},
        matchMedia: () => ({}),
        requestAnimationFrame: t => "undefined" == typeof setTimeout ? (t(),
        null) : setTimeout(t, 0),
        cancelAnimationFrame(t) {
            "undefined" != typeof setTimeout && clearTimeout(t)
        }
    };
    function yy() {
        const t = "undefined" != typeof window ? window : {};
        return fy(t, vy),
        t
    }
    function xy(t, e) {
        return void 0 === e && (e = 0),
        setTimeout(t, e)
    }
    function _y() {
        return Date.now()
    }
    function wy(t, e) {
        void 0 === e && (e = "x");
        const i = yy();
        let n, r, s;
        const a = function(t) {
            const e = yy();
            let i;
            return e.getComputedStyle && (i = e.getComputedStyle(t, null)),
            !i && t.currentStyle && (i = t.currentStyle),
            i || (i = t.style),
            i
        }(t);
        return i.WebKitCSSMatrix ? (r = a.transform || a.webkitTransform,
        r.split(",").length > 6 && (r = r.split(", ").map((t => t.replace(",", "."))).join(", ")),
        s = new i.WebKitCSSMatrix("none" === r ? "" : r)) : (s = a.MozTransform || a.OTransform || a.MsTransform || a.msTransform || a.transform || a.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"),
        n = s.toString().split(",")),
        "x" === e && (r = i.WebKitCSSMatrix ? s.m41 : 16 === n.length ? parseFloat(n[12]) : parseFloat(n[4])),
        "y" === e && (r = i.WebKitCSSMatrix ? s.m42 : 16 === n.length ? parseFloat(n[13]) : parseFloat(n[5])),
        r || 0
    }
    function by(t) {
        return "object" == typeof t && null !== t && t.constructor && "Object" === Object.prototype.toString.call(t).slice(8, -1)
    }
    function My() {
        const t = Object(arguments.length <= 0 ? void 0 : arguments[0])
          , e = ["__proto__", "constructor", "prototype"];
        for (let n = 1; n < arguments.length; n += 1) {
            const r = n < 0 || arguments.length <= n ? void 0 : arguments[n];
            if (null != r && (i = r,
            !("undefined" != typeof window && void 0 !== window.HTMLElement ? i instanceof HTMLElement : i && (1 === i.nodeType || 11 === i.nodeType)))) {
                const i = Object.keys(Object(r)).filter((t => e.indexOf(t) < 0));
                for (let e = 0, n = i.length; e < n; e += 1) {
                    const n = i[e]
                      , s = Object.getOwnPropertyDescriptor(r, n);
                    void 0 !== s && s.enumerable && (by(t[n]) && by(r[n]) ? r[n].__swiper__ ? t[n] = r[n] : My(t[n], r[n]) : !by(t[n]) && by(r[n]) ? (t[n] = {},
                    r[n].__swiper__ ? t[n] = r[n] : My(t[n], r[n])) : t[n] = r[n])
                }
            }
        }
        var i;
        return t
    }
    function Sy(t, e, i) {
        t.style.setProperty(e, i)
    }
    function Ty(t) {
        let {swiper: e, targetPosition: i, side: n} = t;
        const r = yy()
          , s = -e.translate;
        let a, o = null;
        const l = e.params.speed;
        e.wrapperEl.style.scrollSnapType = "none",
        r.cancelAnimationFrame(e.cssModeFrameID);
        const c = i > s ? "next" : "prev"
          , h = (t, e) => "next" === c && t >= e || "prev" === c && t <= e
          , u = () => {
            a = (new Date).getTime(),
            null === o && (o = a);
            const t = Math.max(Math.min((a - o) / l, 1), 0)
              , c = .5 - Math.cos(t * Math.PI) / 2;
            let d = s + c * (i - s);
            if (h(d, i) && (d = i),
            e.wrapperEl.scrollTo({
                [n]: d
            }),
            h(d, i))
                return e.wrapperEl.style.overflow = "hidden",
                e.wrapperEl.style.scrollSnapType = "",
                setTimeout(( () => {
                    e.wrapperEl.style.overflow = "",
                    e.wrapperEl.scrollTo({
                        [n]: d
                    })
                }
                )),
                void r.cancelAnimationFrame(e.cssModeFrameID);
            e.cssModeFrameID = r.requestAnimationFrame(u)
        }
        ;
        u()
    }
    function Ey(t, e) {
        return void 0 === e && (e = ""),
        [...t.children].filter((t => t.matches(e)))
    }
    function Ly(t) {
        try {
            return void console.warn(t)
        } catch (t) {}
    }
    function Ay(t, e) {
        void 0 === e && (e = []);
        const i = document.createElement(t);
        return i.classList.add(...Array.isArray(e) ? e : function(t) {
            return void 0 === t && (t = ""),
            t.trim().split(" ").filter((t => !!t.trim()))
        }(e)),
        i
    }
    function Cy(t, e) {
        return yy().getComputedStyle(t, null).getPropertyValue(e)
    }
    function Py(t) {
        let e, i = t;
        if (i) {
            for (e = 0; null !== (i = i.previousSibling); )
                1 === i.nodeType && (e += 1);
            return e
        }
    }
    function Ry(t, e, i) {
        const n = yy();
        return i ? t["width" === e ? "offsetWidth" : "offsetHeight"] + parseFloat(n.getComputedStyle(t, null).getPropertyValue("width" === e ? "margin-right" : "margin-top")) + parseFloat(n.getComputedStyle(t, null).getPropertyValue("width" === e ? "margin-left" : "margin-bottom")) : t.offsetWidth
    }
    let Iy, Dy, Ny;
    function Oy() {
        return Iy || (Iy = function() {
            const t = yy()
              , e = gy();
            return {
                smoothScroll: e.documentElement && e.documentElement.style && "scrollBehavior"in e.documentElement.style,
                touch: !!("ontouchstart"in t || t.DocumentTouch && e instanceof t.DocumentTouch)
            }
        }()),
        Iy
    }
    function zy(t) {
        return void 0 === t && (t = {}),
        Dy || (Dy = function(t) {
            let {userAgent: e} = void 0 === t ? {} : t;
            const i = Oy()
              , n = yy()
              , r = n.navigator.platform
              , s = e || n.navigator.userAgent
              , a = {
                ios: !1,
                android: !1
            }
              , o = n.screen.width
              , l = n.screen.height
              , c = s.match(/(Android);?[\s\/]+([\d.]+)?/);
            let h = s.match(/(iPad).*OS\s([\d_]+)/);
            const u = s.match(/(iPod)(.*OS\s([\d_]+))?/)
              , d = !h && s.match(/(iPhone\sOS|iOS)\s([\d_]+)/)
              , p = "Win32" === r;
            let f = "MacIntel" === r;
            return !h && f && i.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${o}x${l}`) >= 0 && (h = s.match(/(Version)\/([\d.]+)/),
            h || (h = [0, 1, "13_0_0"]),
            f = !1),
            c && !p && (a.os = "android",
            a.android = !0),
            (h || d || u) && (a.os = "ios",
            a.ios = !0),
            a
        }(t)),
        Dy
    }
    function ky() {
        return Ny || (Ny = function() {
            const t = yy()
              , e = zy();
            let i = !1;
            function n() {
                const e = t.navigator.userAgent.toLowerCase();
                return e.indexOf("safari") >= 0 && e.indexOf("chrome") < 0 && e.indexOf("android") < 0
            }
            if (n()) {
                const e = String(t.navigator.userAgent);
                if (e.includes("Version/")) {
                    const [t,n] = e.split("Version/")[1].split(" ")[0].split(".").map((t => Number(t)));
                    i = t < 16 || 16 === t && n < 2
                }
            }
            const r = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(t.navigator.userAgent)
              , s = n();
            return {
                isSafari: i || s,
                needPerspectiveFix: i,
                need3dFix: s || r && e.ios,
                isWebView: r
            }
        }()),
        Ny
    }
    var By = {
        on(t, e, i) {
            const n = this;
            if (!n.eventsListeners || n.destroyed)
                return n;
            if ("function" != typeof e)
                return n;
            const r = i ? "unshift" : "push";
            return t.split(" ").forEach((t => {
                n.eventsListeners[t] || (n.eventsListeners[t] = []),
                n.eventsListeners[t][r](e)
            }
            )),
            n
        },
        once(t, e, i) {
            const n = this;
            if (!n.eventsListeners || n.destroyed)
                return n;
            if ("function" != typeof e)
                return n;
            function r() {
                n.off(t, r),
                r.__emitterProxy && delete r.__emitterProxy;
                for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)
                    s[a] = arguments[a];
                e.apply(n, s)
            }
            return r.__emitterProxy = e,
            n.on(t, r, i)
        },
        onAny(t, e) {
            const i = this;
            if (!i.eventsListeners || i.destroyed)
                return i;
            if ("function" != typeof t)
                return i;
            const n = e ? "unshift" : "push";
            return i.eventsAnyListeners.indexOf(t) < 0 && i.eventsAnyListeners[n](t),
            i
        },
        offAny(t) {
            const e = this;
            if (!e.eventsListeners || e.destroyed)
                return e;
            if (!e.eventsAnyListeners)
                return e;
            const i = e.eventsAnyListeners.indexOf(t);
            return i >= 0 && e.eventsAnyListeners.splice(i, 1),
            e
        },
        off(t, e) {
            const i = this;
            return !i.eventsListeners || i.destroyed ? i : i.eventsListeners ? (t.split(" ").forEach((t => {
                void 0 === e ? i.eventsListeners[t] = [] : i.eventsListeners[t] && i.eventsListeners[t].forEach(( (n, r) => {
                    (n === e || n.__emitterProxy && n.__emitterProxy === e) && i.eventsListeners[t].splice(r, 1)
                }
                ))
            }
            )),
            i) : i
        },
        emit() {
            const t = this;
            if (!t.eventsListeners || t.destroyed)
                return t;
            if (!t.eventsListeners)
                return t;
            let e, i, n;
            for (var r = arguments.length, s = new Array(r), a = 0; a < r; a++)
                s[a] = arguments[a];
            "string" == typeof s[0] || Array.isArray(s[0]) ? (e = s[0],
            i = s.slice(1, s.length),
            n = t) : (e = s[0].events,
            i = s[0].data,
            n = s[0].context || t),
            i.unshift(n);
            return (Array.isArray(e) ? e : e.split(" ")).forEach((e => {
                t.eventsAnyListeners && t.eventsAnyListeners.length && t.eventsAnyListeners.forEach((t => {
                    t.apply(n, [e, ...i])
                }
                )),
                t.eventsListeners && t.eventsListeners[e] && t.eventsListeners[e].forEach((t => {
                    t.apply(n, i)
                }
                ))
            }
            )),
            t
        }
    };
    const Fy = (t, e, i) => {
        e && !t.classList.contains(i) ? t.classList.add(i) : !e && t.classList.contains(i) && t.classList.remove(i)
    }
    ;
    const Hy = (t, e, i) => {
        e && !t.classList.contains(i) ? t.classList.add(i) : !e && t.classList.contains(i) && t.classList.remove(i)
    }
    ;
    const Uy = (t, e) => {
        if (!t || t.destroyed || !t.params)
            return;
        const i = e.closest(t.isElement ? "swiper-slide" : `.${t.params.slideClass}`);
        if (i) {
            let e = i.querySelector(`.${t.params.lazyPreloaderClass}`);
            !e && t.isElement && (i.shadowRoot ? e = i.shadowRoot.querySelector(`.${t.params.lazyPreloaderClass}`) : requestAnimationFrame(( () => {
                i.shadowRoot && (e = i.shadowRoot.querySelector(`.${t.params.lazyPreloaderClass}`),
                e && e.remove())
            }
            ))),
            e && e.remove()
        }
    }
      , Gy = (t, e) => {
        if (!t.slides[e])
            return;
        const i = t.slides[e].querySelector('[loading="lazy"]');
        i && i.removeAttribute("loading")
    }
      , Vy = t => {
        if (!t || t.destroyed || !t.params)
            return;
        let e = t.params.lazyPreloadPrevNext;
        const i = t.slides.length;
        if (!i || !e || e < 0)
            return;
        e = Math.min(e, i);
        const n = "auto" === t.params.slidesPerView ? t.slidesPerViewDynamic() : Math.ceil(t.params.slidesPerView)
          , r = t.activeIndex;
        if (t.params.grid && t.params.grid.rows > 1) {
            const i = r
              , s = [i - e];
            return s.push(...Array.from({
                length: e
            }).map(( (t, e) => i + n + e))),
            void t.slides.forEach(( (e, i) => {
                s.includes(e.column) && Gy(t, i)
            }
            ))
        }
        const s = r + n - 1;
        if (t.params.rewind || t.params.loop)
            for (let n = r - e; n <= s + e; n += 1) {
                const e = (n % i + i) % i;
                (e < r || e > s) && Gy(t, e)
            }
        else
            for (let n = Math.max(r - e, 0); n <= Math.min(s + e, i - 1); n += 1)
                n !== r && (n > s || n < r) && Gy(t, n)
    }
    ;
    var Wy = {
        updateSize: function() {
            const t = this;
            let e, i;
            const n = t.el;
            e = void 0 !== t.params.width && null !== t.params.width ? t.params.width : n.clientWidth,
            i = void 0 !== t.params.height && null !== t.params.height ? t.params.height : n.clientHeight,
            0 === e && t.isHorizontal() || 0 === i && t.isVertical() || (e = e - parseInt(Cy(n, "padding-left") || 0, 10) - parseInt(Cy(n, "padding-right") || 0, 10),
            i = i - parseInt(Cy(n, "padding-top") || 0, 10) - parseInt(Cy(n, "padding-bottom") || 0, 10),
            Number.isNaN(e) && (e = 0),
            Number.isNaN(i) && (i = 0),
            Object.assign(t, {
                width: e,
                height: i,
                size: t.isHorizontal() ? e : i
            }))
        },
        updateSlides: function() {
            const t = this;
            function e(e, i) {
                return parseFloat(e.getPropertyValue(t.getDirectionLabel(i)) || 0)
            }
            const i = t.params
              , {wrapperEl: n, slidesEl: r, size: s, rtlTranslate: a, wrongRTL: o} = t
              , l = t.virtual && i.virtual.enabled
              , c = l ? t.virtual.slides.length : t.slides.length
              , h = Ey(r, `.${t.params.slideClass}, swiper-slide`)
              , u = l ? t.virtual.slides.length : h.length;
            let d = [];
            const p = []
              , f = [];
            let m = i.slidesOffsetBefore;
            "function" == typeof m && (m = i.slidesOffsetBefore.call(t));
            let g = i.slidesOffsetAfter;
            "function" == typeof g && (g = i.slidesOffsetAfter.call(t));
            const v = t.snapGrid.length
              , y = t.slidesGrid.length;
            let x = i.spaceBetween
              , _ = -m
              , w = 0
              , b = 0;
            if (void 0 === s)
                return;
            "string" == typeof x && x.indexOf("%") >= 0 ? x = parseFloat(x.replace("%", "")) / 100 * s : "string" == typeof x && (x = parseFloat(x)),
            t.virtualSize = -x,
            h.forEach((t => {
                a ? t.style.marginLeft = "" : t.style.marginRight = "",
                t.style.marginBottom = "",
                t.style.marginTop = ""
            }
            )),
            i.centeredSlides && i.cssMode && (Sy(n, "--swiper-centered-offset-before", ""),
            Sy(n, "--swiper-centered-offset-after", ""));
            const M = i.grid && i.grid.rows > 1 && t.grid;
            let S;
            M ? t.grid.initSlides(h) : t.grid && t.grid.unsetSlides();
            const T = "auto" === i.slidesPerView && i.breakpoints && Object.keys(i.breakpoints).filter((t => void 0 !== i.breakpoints[t].slidesPerView)).length > 0;
            for (let n = 0; n < u; n += 1) {
                let r;
                if (S = 0,
                h[n] && (r = h[n]),
                M && t.grid.updateSlide(n, r, h),
                !h[n] || "none" !== Cy(r, "display")) {
                    if ("auto" === i.slidesPerView) {
                        T && (h[n].style[t.getDirectionLabel("width")] = "");
                        const s = getComputedStyle(r)
                          , a = r.style.transform
                          , o = r.style.webkitTransform;
                        if (a && (r.style.transform = "none"),
                        o && (r.style.webkitTransform = "none"),
                        i.roundLengths)
                            S = t.isHorizontal() ? Ry(r, "width", !0) : Ry(r, "height", !0);
                        else {
                            const t = e(s, "width")
                              , i = e(s, "padding-left")
                              , n = e(s, "padding-right")
                              , a = e(s, "margin-left")
                              , o = e(s, "margin-right")
                              , l = s.getPropertyValue("box-sizing");
                            if (l && "border-box" === l)
                                S = t + a + o;
                            else {
                                const {clientWidth: e, offsetWidth: s} = r;
                                S = t + i + n + a + o + (s - e)
                            }
                        }
                        a && (r.style.transform = a),
                        o && (r.style.webkitTransform = o),
                        i.roundLengths && (S = Math.floor(S))
                    } else
                        S = (s - (i.slidesPerView - 1) * x) / i.slidesPerView,
                        i.roundLengths && (S = Math.floor(S)),
                        h[n] && (h[n].style[t.getDirectionLabel("width")] = `${S}px`);
                    h[n] && (h[n].swiperSlideSize = S),
                    f.push(S),
                    i.centeredSlides ? (_ = _ + S / 2 + w / 2 + x,
                    0 === w && 0 !== n && (_ = _ - s / 2 - x),
                    0 === n && (_ = _ - s / 2 - x),
                    Math.abs(_) < .001 && (_ = 0),
                    i.roundLengths && (_ = Math.floor(_)),
                    b % i.slidesPerGroup == 0 && d.push(_),
                    p.push(_)) : (i.roundLengths && (_ = Math.floor(_)),
                    (b - Math.min(t.params.slidesPerGroupSkip, b)) % t.params.slidesPerGroup == 0 && d.push(_),
                    p.push(_),
                    _ = _ + S + x),
                    t.virtualSize += S + x,
                    w = S,
                    b += 1
                }
            }
            if (t.virtualSize = Math.max(t.virtualSize, s) + g,
            a && o && ("slide" === i.effect || "coverflow" === i.effect) && (n.style.width = `${t.virtualSize + x}px`),
            i.setWrapperSize && (n.style[t.getDirectionLabel("width")] = `${t.virtualSize + x}px`),
            M && t.grid.updateWrapperSize(S, d),
            !i.centeredSlides) {
                const e = [];
                for (let n = 0; n < d.length; n += 1) {
                    let r = d[n];
                    i.roundLengths && (r = Math.floor(r)),
                    d[n] <= t.virtualSize - s && e.push(r)
                }
                d = e,
                Math.floor(t.virtualSize - s) - Math.floor(d[d.length - 1]) > 1 && d.push(t.virtualSize - s)
            }
            if (l && i.loop) {
                const e = f[0] + x;
                if (i.slidesPerGroup > 1) {
                    const n = Math.ceil((t.virtual.slidesBefore + t.virtual.slidesAfter) / i.slidesPerGroup)
                      , r = e * i.slidesPerGroup;
                    for (let t = 0; t < n; t += 1)
                        d.push(d[d.length - 1] + r)
                }
                for (let n = 0; n < t.virtual.slidesBefore + t.virtual.slidesAfter; n += 1)
                    1 === i.slidesPerGroup && d.push(d[d.length - 1] + e),
                    p.push(p[p.length - 1] + e),
                    t.virtualSize += e
            }
            if (0 === d.length && (d = [0]),
            0 !== x) {
                const e = t.isHorizontal() && a ? "marginLeft" : t.getDirectionLabel("marginRight");
                h.filter(( (t, e) => !(i.cssMode && !i.loop) || e !== h.length - 1)).forEach((t => {
                    t.style[e] = `${x}px`
                }
                ))
            }
            if (i.centeredSlides && i.centeredSlidesBounds) {
                let t = 0;
                f.forEach((e => {
                    t += e + (x || 0)
                }
                )),
                t -= x;
                const e = t - s;
                d = d.map((t => t <= 0 ? -m : t > e ? e + g : t))
            }
            if (i.centerInsufficientSlides) {
                let t = 0;
                f.forEach((e => {
                    t += e + (x || 0)
                }
                )),
                t -= x;
                const e = (i.slidesOffsetBefore || 0) + (i.slidesOffsetAfter || 0);
                if (t + e < s) {
                    const i = (s - t - e) / 2;
                    d.forEach(( (t, e) => {
                        d[e] = t - i
                    }
                    )),
                    p.forEach(( (t, e) => {
                        p[e] = t + i
                    }
                    ))
                }
            }
            if (Object.assign(t, {
                slides: h,
                snapGrid: d,
                slidesGrid: p,
                slidesSizesGrid: f
            }),
            i.centeredSlides && i.cssMode && !i.centeredSlidesBounds) {
                Sy(n, "--swiper-centered-offset-before", -d[0] + "px"),
                Sy(n, "--swiper-centered-offset-after", t.size / 2 - f[f.length - 1] / 2 + "px");
                const e = -t.snapGrid[0]
                  , i = -t.slidesGrid[0];
                t.snapGrid = t.snapGrid.map((t => t + e)),
                t.slidesGrid = t.slidesGrid.map((t => t + i))
            }
            if (u !== c && t.emit("slidesLengthChange"),
            d.length !== v && (t.params.watchOverflow && t.checkOverflow(),
            t.emit("snapGridLengthChange")),
            p.length !== y && t.emit("slidesGridLengthChange"),
            i.watchSlidesProgress && t.updateSlidesOffset(),
            t.emit("slidesUpdated"),
            !(l || i.cssMode || "slide" !== i.effect && "fade" !== i.effect)) {
                const e = `${i.containerModifierClass}backface-hidden`
                  , n = t.el.classList.contains(e);
                u <= i.maxBackfaceHiddenSlides ? n || t.el.classList.add(e) : n && t.el.classList.remove(e)
            }
        },
        updateAutoHeight: function(t) {
            const e = this
              , i = []
              , n = e.virtual && e.params.virtual.enabled;
            let r, s = 0;
            "number" == typeof t ? e.setTransition(t) : !0 === t && e.setTransition(e.params.speed);
            const a = t => n ? e.slides[e.getSlideIndexByData(t)] : e.slides[t];
            if ("auto" !== e.params.slidesPerView && e.params.slidesPerView > 1)
                if (e.params.centeredSlides)
                    (e.visibleSlides || []).forEach((t => {
                        i.push(t)
                    }
                    ));
                else
                    for (r = 0; r < Math.ceil(e.params.slidesPerView); r += 1) {
                        const t = e.activeIndex + r;
                        if (t > e.slides.length && !n)
                            break;
                        i.push(a(t))
                    }
            else
                i.push(a(e.activeIndex));
            for (r = 0; r < i.length; r += 1)
                if (void 0 !== i[r]) {
                    const t = i[r].offsetHeight;
                    s = t > s ? t : s
                }
            (s || 0 === s) && (e.wrapperEl.style.height = `${s}px`)
        },
        updateSlidesOffset: function() {
            const t = this
              , e = t.slides
              , i = t.isElement ? t.isHorizontal() ? t.wrapperEl.offsetLeft : t.wrapperEl.offsetTop : 0;
            for (let n = 0; n < e.length; n += 1)
                e[n].swiperSlideOffset = (t.isHorizontal() ? e[n].offsetLeft : e[n].offsetTop) - i - t.cssOverflowAdjustment()
        },
        updateSlidesProgress: function(t) {
            void 0 === t && (t = this && this.translate || 0);
            const e = this
              , i = e.params
              , {slides: n, rtlTranslate: r, snapGrid: s} = e;
            if (0 === n.length)
                return;
            void 0 === n[0].swiperSlideOffset && e.updateSlidesOffset();
            let a = -t;
            r && (a = t),
            e.visibleSlidesIndexes = [],
            e.visibleSlides = [];
            let o = i.spaceBetween;
            "string" == typeof o && o.indexOf("%") >= 0 ? o = parseFloat(o.replace("%", "")) / 100 * e.size : "string" == typeof o && (o = parseFloat(o));
            for (let t = 0; t < n.length; t += 1) {
                const l = n[t];
                let c = l.swiperSlideOffset;
                i.cssMode && i.centeredSlides && (c -= n[0].swiperSlideOffset);
                const h = (a + (i.centeredSlides ? e.minTranslate() : 0) - c) / (l.swiperSlideSize + o)
                  , u = (a - s[0] + (i.centeredSlides ? e.minTranslate() : 0) - c) / (l.swiperSlideSize + o)
                  , d = -(a - c)
                  , p = d + e.slidesSizesGrid[t]
                  , f = d >= 0 && d <= e.size - e.slidesSizesGrid[t]
                  , m = d >= 0 && d < e.size - 1 || p > 1 && p <= e.size || d <= 0 && p >= e.size;
                m && (e.visibleSlides.push(l),
                e.visibleSlidesIndexes.push(t)),
                Fy(l, m, i.slideVisibleClass),
                Fy(l, f, i.slideFullyVisibleClass),
                l.progress = r ? -h : h,
                l.originalProgress = r ? -u : u
            }
        },
        updateProgress: function(t) {
            const e = this;
            if (void 0 === t) {
                const i = e.rtlTranslate ? -1 : 1;
                t = e && e.translate && e.translate * i || 0
            }
            const i = e.params
              , n = e.maxTranslate() - e.minTranslate();
            let {progress: r, isBeginning: s, isEnd: a, progressLoop: o} = e;
            const l = s
              , c = a;
            if (0 === n)
                r = 0,
                s = !0,
                a = !0;
            else {
                r = (t - e.minTranslate()) / n;
                const i = Math.abs(t - e.minTranslate()) < 1
                  , o = Math.abs(t - e.maxTranslate()) < 1;
                s = i || r <= 0,
                a = o || r >= 1,
                i && (r = 0),
                o && (r = 1)
            }
            if (i.loop) {
                const i = e.getSlideIndexByData(0)
                  , n = e.getSlideIndexByData(e.slides.length - 1)
                  , r = e.slidesGrid[i]
                  , s = e.slidesGrid[n]
                  , a = e.slidesGrid[e.slidesGrid.length - 1]
                  , l = Math.abs(t);
                o = l >= r ? (l - r) / a : (l + a - s) / a,
                o > 1 && (o -= 1)
            }
            Object.assign(e, {
                progress: r,
                progressLoop: o,
                isBeginning: s,
                isEnd: a
            }),
            (i.watchSlidesProgress || i.centeredSlides && i.autoHeight) && e.updateSlidesProgress(t),
            s && !l && e.emit("reachBeginning toEdge"),
            a && !c && e.emit("reachEnd toEdge"),
            (l && !s || c && !a) && e.emit("fromEdge"),
            e.emit("progress", r)
        },
        updateSlidesClasses: function() {
            const t = this
              , {slides: e, params: i, slidesEl: n, activeIndex: r} = t
              , s = t.virtual && i.virtual.enabled
              , a = t.grid && i.grid && i.grid.rows > 1
              , o = t => Ey(n, `.${i.slideClass}${t}, swiper-slide${t}`)[0];
            let l, c, h;
            if (s)
                if (i.loop) {
                    let e = r - t.virtual.slidesBefore;
                    e < 0 && (e = t.virtual.slides.length + e),
                    e >= t.virtual.slides.length && (e -= t.virtual.slides.length),
                    l = o(`[data-swiper-slide-index="${e}"]`)
                } else
                    l = o(`[data-swiper-slide-index="${r}"]`);
            else
                a ? (l = e.filter((t => t.column === r))[0],
                h = e.filter((t => t.column === r + 1))[0],
                c = e.filter((t => t.column === r - 1))[0]) : l = e[r];
            l && (a || (h = function(t, e) {
                const i = [];
                for (; t.nextElementSibling; ) {
                    const n = t.nextElementSibling;
                    e ? n.matches(e) && i.push(n) : i.push(n),
                    t = n
                }
                return i
            }(l, `.${i.slideClass}, swiper-slide`)[0],
            i.loop && !h && (h = e[0]),
            c = function(t, e) {
                const i = [];
                for (; t.previousElementSibling; ) {
                    const n = t.previousElementSibling;
                    e ? n.matches(e) && i.push(n) : i.push(n),
                    t = n
                }
                return i
            }(l, `.${i.slideClass}, swiper-slide`)[0],
            i.loop && 0 === !c && (c = e[e.length - 1]))),
            e.forEach((t => {
                Hy(t, t === l, i.slideActiveClass),
                Hy(t, t === h, i.slideNextClass),
                Hy(t, t === c, i.slidePrevClass)
            }
            )),
            t.emitSlidesClasses()
        },
        updateActiveIndex: function(t) {
            const e = this
              , i = e.rtlTranslate ? e.translate : -e.translate
              , {snapGrid: n, params: r, activeIndex: s, realIndex: a, snapIndex: o} = e;
            let l, c = t;
            const h = t => {
                let i = t - e.virtual.slidesBefore;
                return i < 0 && (i = e.virtual.slides.length + i),
                i >= e.virtual.slides.length && (i -= e.virtual.slides.length),
                i
            }
            ;
            if (void 0 === c && (c = function(t) {
                const {slidesGrid: e, params: i} = t
                  , n = t.rtlTranslate ? t.translate : -t.translate;
                let r;
                for (let t = 0; t < e.length; t += 1)
                    void 0 !== e[t + 1] ? n >= e[t] && n < e[t + 1] - (e[t + 1] - e[t]) / 2 ? r = t : n >= e[t] && n < e[t + 1] && (r = t + 1) : n >= e[t] && (r = t);
                return i.normalizeSlideIndex && (r < 0 || void 0 === r) && (r = 0),
                r
            }(e)),
            n.indexOf(i) >= 0)
                l = n.indexOf(i);
            else {
                const t = Math.min(r.slidesPerGroupSkip, c);
                l = t + Math.floor((c - t) / r.slidesPerGroup)
            }
            if (l >= n.length && (l = n.length - 1),
            c === s && !e.params.loop)
                return void (l !== o && (e.snapIndex = l,
                e.emit("snapIndexChange")));
            if (c === s && e.params.loop && e.virtual && e.params.virtual.enabled)
                return void (e.realIndex = h(c));
            const u = e.grid && r.grid && r.grid.rows > 1;
            let d;
            if (e.virtual && r.virtual.enabled && r.loop)
                d = h(c);
            else if (u) {
                const t = e.slides.filter((t => t.column === c))[0];
                let i = parseInt(t.getAttribute("data-swiper-slide-index"), 10);
                Number.isNaN(i) && (i = Math.max(e.slides.indexOf(t), 0)),
                d = Math.floor(i / r.grid.rows)
            } else if (e.slides[c]) {
                const t = e.slides[c].getAttribute("data-swiper-slide-index");
                d = t ? parseInt(t, 10) : c
            } else
                d = c;
            Object.assign(e, {
                previousSnapIndex: o,
                snapIndex: l,
                previousRealIndex: a,
                realIndex: d,
                previousIndex: s,
                activeIndex: c
            }),
            e.initialized && Vy(e),
            e.emit("activeIndexChange"),
            e.emit("snapIndexChange"),
            (e.initialized || e.params.runCallbacksOnInit) && (a !== d && e.emit("realIndexChange"),
            e.emit("slideChange"))
        },
        updateClickedSlide: function(t, e) {
            const i = this
              , n = i.params;
            let r = t.closest(`.${n.slideClass}, swiper-slide`);
            !r && i.isElement && e && e.length > 1 && e.includes(t) && [...e.slice(e.indexOf(t) + 1, e.length)].forEach((t => {
                !r && t.matches && t.matches(`.${n.slideClass}, swiper-slide`) && (r = t)
            }
            ));
            let s, a = !1;
            if (r)
                for (let t = 0; t < i.slides.length; t += 1)
                    if (i.slides[t] === r) {
                        a = !0,
                        s = t;
                        break
                    }
            if (!r || !a)
                return i.clickedSlide = void 0,
                void (i.clickedIndex = void 0);
            i.clickedSlide = r,
            i.virtual && i.params.virtual.enabled ? i.clickedIndex = parseInt(r.getAttribute("data-swiper-slide-index"), 10) : i.clickedIndex = s,
            n.slideToClickedSlide && void 0 !== i.clickedIndex && i.clickedIndex !== i.activeIndex && i.slideToClickedSlide()
        }
    };
    var qy = {
        getTranslate: function(t) {
            void 0 === t && (t = this.isHorizontal() ? "x" : "y");
            const {params: e, rtlTranslate: i, translate: n, wrapperEl: r} = this;
            if (e.virtualTranslate)
                return i ? -n : n;
            if (e.cssMode)
                return n;
            let s = wy(r, t);
            return s += this.cssOverflowAdjustment(),
            i && (s = -s),
            s || 0
        },
        setTranslate: function(t, e) {
            const i = this
              , {rtlTranslate: n, params: r, wrapperEl: s, progress: a} = i;
            let o, l = 0, c = 0;
            i.isHorizontal() ? l = n ? -t : t : c = t,
            r.roundLengths && (l = Math.floor(l),
            c = Math.floor(c)),
            i.previousTranslate = i.translate,
            i.translate = i.isHorizontal() ? l : c,
            r.cssMode ? s[i.isHorizontal() ? "scrollLeft" : "scrollTop"] = i.isHorizontal() ? -l : -c : r.virtualTranslate || (i.isHorizontal() ? l -= i.cssOverflowAdjustment() : c -= i.cssOverflowAdjustment(),
            s.style.transform = `translate3d(${l}px, ${c}px, 0px)`);
            const h = i.maxTranslate() - i.minTranslate();
            o = 0 === h ? 0 : (t - i.minTranslate()) / h,
            o !== a && i.updateProgress(t),
            i.emit("setTranslate", i.translate, e)
        },
        minTranslate: function() {
            return -this.snapGrid[0]
        },
        maxTranslate: function() {
            return -this.snapGrid[this.snapGrid.length - 1]
        },
        translateTo: function(t, e, i, n, r) {
            void 0 === t && (t = 0),
            void 0 === e && (e = this.params.speed),
            void 0 === i && (i = !0),
            void 0 === n && (n = !0);
            const s = this
              , {params: a, wrapperEl: o} = s;
            if (s.animating && a.preventInteractionOnTransition)
                return !1;
            const l = s.minTranslate()
              , c = s.maxTranslate();
            let h;
            if (h = n && t > l ? l : n && t < c ? c : t,
            s.updateProgress(h),
            a.cssMode) {
                const t = s.isHorizontal();
                if (0 === e)
                    o[t ? "scrollLeft" : "scrollTop"] = -h;
                else {
                    if (!s.support.smoothScroll)
                        return Ty({
                            swiper: s,
                            targetPosition: -h,
                            side: t ? "left" : "top"
                        }),
                        !0;
                    o.scrollTo({
                        [t ? "left" : "top"]: -h,
                        behavior: "smooth"
                    })
                }
                return !0
            }
            return 0 === e ? (s.setTransition(0),
            s.setTranslate(h),
            i && (s.emit("beforeTransitionStart", e, r),
            s.emit("transitionEnd"))) : (s.setTransition(e),
            s.setTranslate(h),
            i && (s.emit("beforeTransitionStart", e, r),
            s.emit("transitionStart")),
            s.animating || (s.animating = !0,
            s.onTranslateToWrapperTransitionEnd || (s.onTranslateToWrapperTransitionEnd = function(t) {
                s && !s.destroyed && t.target === this && (s.wrapperEl.removeEventListener("transitionend", s.onTranslateToWrapperTransitionEnd),
                s.onTranslateToWrapperTransitionEnd = null,
                delete s.onTranslateToWrapperTransitionEnd,
                s.animating = !1,
                i && s.emit("transitionEnd"))
            }
            ),
            s.wrapperEl.addEventListener("transitionend", s.onTranslateToWrapperTransitionEnd))),
            !0
        }
    };
    function jy(t) {
        let {swiper: e, runCallbacks: i, direction: n, step: r} = t;
        const {activeIndex: s, previousIndex: a} = e;
        let o = n;
        if (o || (o = s > a ? "next" : s < a ? "prev" : "reset"),
        e.emit(`transition${r}`),
        i && s !== a) {
            if ("reset" === o)
                return void e.emit(`slideResetTransition${r}`);
            e.emit(`slideChangeTransition${r}`),
            "next" === o ? e.emit(`slideNextTransition${r}`) : e.emit(`slidePrevTransition${r}`)
        }
    }
    var Yy = {
        slideTo: function(t, e, i, n, r) {
            void 0 === t && (t = 0),
            void 0 === i && (i = !0),
            "string" == typeof t && (t = parseInt(t, 10));
            const s = this;
            let a = t;
            a < 0 && (a = 0);
            const {params: o, snapGrid: l, slidesGrid: c, previousIndex: h, activeIndex: u, rtlTranslate: d, wrapperEl: p, enabled: f} = s;
            if (!f && !n && !r || s.destroyed || s.animating && o.preventInteractionOnTransition)
                return !1;
            void 0 === e && (e = s.params.speed);
            const m = Math.min(s.params.slidesPerGroupSkip, a);
            let g = m + Math.floor((a - m) / s.params.slidesPerGroup);
            g >= l.length && (g = l.length - 1);
            const v = -l[g];
            if (o.normalizeSlideIndex)
                for (let t = 0; t < c.length; t += 1) {
                    const e = -Math.floor(100 * v)
                      , i = Math.floor(100 * c[t])
                      , n = Math.floor(100 * c[t + 1]);
                    void 0 !== c[t + 1] ? e >= i && e < n - (n - i) / 2 ? a = t : e >= i && e < n && (a = t + 1) : e >= i && (a = t)
                }
            if (s.initialized && a !== u) {
                if (!s.allowSlideNext && (d ? v > s.translate && v > s.minTranslate() : v < s.translate && v < s.minTranslate()))
                    return !1;
                if (!s.allowSlidePrev && v > s.translate && v > s.maxTranslate() && (u || 0) !== a)
                    return !1
            }
            let y;
            if (a !== (h || 0) && i && s.emit("beforeSlideChangeStart"),
            s.updateProgress(v),
            y = a > u ? "next" : a < u ? "prev" : "reset",
            d && -v === s.translate || !d && v === s.translate)
                return s.updateActiveIndex(a),
                o.autoHeight && s.updateAutoHeight(),
                s.updateSlidesClasses(),
                "slide" !== o.effect && s.setTranslate(v),
                "reset" !== y && (s.transitionStart(i, y),
                s.transitionEnd(i, y)),
                !1;
            if (o.cssMode) {
                const t = s.isHorizontal()
                  , i = d ? v : -v;
                if (0 === e) {
                    const e = s.virtual && s.params.virtual.enabled;
                    e && (s.wrapperEl.style.scrollSnapType = "none",
                    s._immediateVirtual = !0),
                    e && !s._cssModeVirtualInitialSet && s.params.initialSlide > 0 ? (s._cssModeVirtualInitialSet = !0,
                    requestAnimationFrame(( () => {
                        p[t ? "scrollLeft" : "scrollTop"] = i
                    }
                    ))) : p[t ? "scrollLeft" : "scrollTop"] = i,
                    e && requestAnimationFrame(( () => {
                        s.wrapperEl.style.scrollSnapType = "",
                        s._immediateVirtual = !1
                    }
                    ))
                } else {
                    if (!s.support.smoothScroll)
                        return Ty({
                            swiper: s,
                            targetPosition: i,
                            side: t ? "left" : "top"
                        }),
                        !0;
                    p.scrollTo({
                        [t ? "left" : "top"]: i,
                        behavior: "smooth"
                    })
                }
                return !0
            }
            return s.setTransition(e),
            s.setTranslate(v),
            s.updateActiveIndex(a),
            s.updateSlidesClasses(),
            s.emit("beforeTransitionStart", e, n),
            s.transitionStart(i, y),
            0 === e ? s.transitionEnd(i, y) : s.animating || (s.animating = !0,
            s.onSlideToWrapperTransitionEnd || (s.onSlideToWrapperTransitionEnd = function(t) {
                s && !s.destroyed && t.target === this && (s.wrapperEl.removeEventListener("transitionend", s.onSlideToWrapperTransitionEnd),
                s.onSlideToWrapperTransitionEnd = null,
                delete s.onSlideToWrapperTransitionEnd,
                s.transitionEnd(i, y))
            }
            ),
            s.wrapperEl.addEventListener("transitionend", s.onSlideToWrapperTransitionEnd)),
            !0
        },
        slideToLoop: function(t, e, i, n) {
            if (void 0 === t && (t = 0),
            void 0 === i && (i = !0),
            "string" == typeof t) {
                t = parseInt(t, 10)
            }
            const r = this;
            if (r.destroyed)
                return;
            void 0 === e && (e = r.params.speed);
            const s = r.grid && r.params.grid && r.params.grid.rows > 1;
            let a = t;
            if (r.params.loop)
                if (r.virtual && r.params.virtual.enabled)
                    a += r.virtual.slidesBefore;
                else {
                    let t;
                    if (s) {
                        const e = a * r.params.grid.rows;
                        t = r.slides.filter((t => 1 * t.getAttribute("data-swiper-slide-index") === e))[0].column
                    } else
                        t = r.getSlideIndexByData(a);
                    const e = s ? Math.ceil(r.slides.length / r.params.grid.rows) : r.slides.length
                      , {centeredSlides: i} = r.params;
                    let o = r.params.slidesPerView;
                    "auto" === o ? o = r.slidesPerViewDynamic() : (o = Math.ceil(parseFloat(r.params.slidesPerView, 10)),
                    i && o % 2 == 0 && (o += 1));
                    let l = e - t < o;
                    if (i && (l = l || t < Math.ceil(o / 2)),
                    n && i && "auto" !== r.params.slidesPerView && !s && (l = !1),
                    l) {
                        const n = i ? t < r.activeIndex ? "prev" : "next" : t - r.activeIndex - 1 < r.params.slidesPerView ? "next" : "prev";
                        r.loopFix({
                            direction: n,
                            slideTo: !0,
                            activeSlideIndex: "next" === n ? t + 1 : t - e + 1,
                            slideRealIndex: "next" === n ? r.realIndex : void 0
                        })
                    }
                    if (s) {
                        const t = a * r.params.grid.rows;
                        a = r.slides.filter((e => 1 * e.getAttribute("data-swiper-slide-index") === t))[0].column
                    } else
                        a = r.getSlideIndexByData(a)
                }
            return requestAnimationFrame(( () => {
                r.slideTo(a, e, i, n)
            }
            )),
            r
        },
        slideNext: function(t, e, i) {
            void 0 === e && (e = !0);
            const n = this
              , {enabled: r, params: s, animating: a} = n;
            if (!r || n.destroyed)
                return n;
            void 0 === t && (t = n.params.speed);
            let o = s.slidesPerGroup;
            "auto" === s.slidesPerView && 1 === s.slidesPerGroup && s.slidesPerGroupAuto && (o = Math.max(n.slidesPerViewDynamic("current", !0), 1));
            const l = n.activeIndex < s.slidesPerGroupSkip ? 1 : o
              , c = n.virtual && s.virtual.enabled;
            if (s.loop) {
                if (a && !c && s.loopPreventsSliding)
                    return !1;
                if (n.loopFix({
                    direction: "next"
                }),
                n._clientLeft = n.wrapperEl.clientLeft,
                n.activeIndex === n.slides.length - 1 && s.cssMode)
                    return requestAnimationFrame(( () => {
                        n.slideTo(n.activeIndex + l, t, e, i)
                    }
                    )),
                    !0
            }
            return s.rewind && n.isEnd ? n.slideTo(0, t, e, i) : n.slideTo(n.activeIndex + l, t, e, i)
        },
        slidePrev: function(t, e, i) {
            void 0 === e && (e = !0);
            const n = this
              , {params: r, snapGrid: s, slidesGrid: a, rtlTranslate: o, enabled: l, animating: c} = n;
            if (!l || n.destroyed)
                return n;
            void 0 === t && (t = n.params.speed);
            const h = n.virtual && r.virtual.enabled;
            if (r.loop) {
                if (c && !h && r.loopPreventsSliding)
                    return !1;
                n.loopFix({
                    direction: "prev"
                }),
                n._clientLeft = n.wrapperEl.clientLeft
            }
            function u(t) {
                return t < 0 ? -Math.floor(Math.abs(t)) : Math.floor(t)
            }
            const d = u(o ? n.translate : -n.translate)
              , p = s.map((t => u(t)));
            let f = s[p.indexOf(d) - 1];
            if (void 0 === f && r.cssMode) {
                let t;
                s.forEach(( (e, i) => {
                    d >= e && (t = i)
                }
                )),
                void 0 !== t && (f = s[t > 0 ? t - 1 : t])
            }
            let m = 0;
            if (void 0 !== f && (m = a.indexOf(f),
            m < 0 && (m = n.activeIndex - 1),
            "auto" === r.slidesPerView && 1 === r.slidesPerGroup && r.slidesPerGroupAuto && (m = m - n.slidesPerViewDynamic("previous", !0) + 1,
            m = Math.max(m, 0))),
            r.rewind && n.isBeginning) {
                const r = n.params.virtual && n.params.virtual.enabled && n.virtual ? n.virtual.slides.length - 1 : n.slides.length - 1;
                return n.slideTo(r, t, e, i)
            }
            return r.loop && 0 === n.activeIndex && r.cssMode ? (requestAnimationFrame(( () => {
                n.slideTo(m, t, e, i)
            }
            )),
            !0) : n.slideTo(m, t, e, i)
        },
        slideReset: function(t, e, i) {
            void 0 === e && (e = !0);
            const n = this;
            if (!n.destroyed)
                return void 0 === t && (t = n.params.speed),
                n.slideTo(n.activeIndex, t, e, i)
        },
        slideToClosest: function(t, e, i, n) {
            void 0 === e && (e = !0),
            void 0 === n && (n = .5);
            const r = this;
            if (r.destroyed)
                return;
            void 0 === t && (t = r.params.speed);
            let s = r.activeIndex;
            const a = Math.min(r.params.slidesPerGroupSkip, s)
              , o = a + Math.floor((s - a) / r.params.slidesPerGroup)
              , l = r.rtlTranslate ? r.translate : -r.translate;
            if (l >= r.snapGrid[o]) {
                const t = r.snapGrid[o];
                l - t > (r.snapGrid[o + 1] - t) * n && (s += r.params.slidesPerGroup)
            } else {
                const t = r.snapGrid[o - 1];
                l - t <= (r.snapGrid[o] - t) * n && (s -= r.params.slidesPerGroup)
            }
            return s = Math.max(s, 0),
            s = Math.min(s, r.slidesGrid.length - 1),
            r.slideTo(s, t, e, i)
        },
        slideToClickedSlide: function() {
            const t = this;
            if (t.destroyed)
                return;
            const {params: e, slidesEl: i} = t
              , n = "auto" === e.slidesPerView ? t.slidesPerViewDynamic() : e.slidesPerView;
            let r, s = t.clickedIndex;
            const a = t.isElement ? "swiper-slide" : `.${e.slideClass}`;
            if (e.loop) {
                if (t.animating)
                    return;
                r = parseInt(t.clickedSlide.getAttribute("data-swiper-slide-index"), 10),
                e.centeredSlides ? s < t.loopedSlides - n / 2 || s > t.slides.length - t.loopedSlides + n / 2 ? (t.loopFix(),
                s = t.getSlideIndex(Ey(i, `${a}[data-swiper-slide-index="${r}"]`)[0]),
                xy(( () => {
                    t.slideTo(s)
                }
                ))) : t.slideTo(s) : s > t.slides.length - n ? (t.loopFix(),
                s = t.getSlideIndex(Ey(i, `${a}[data-swiper-slide-index="${r}"]`)[0]),
                xy(( () => {
                    t.slideTo(s)
                }
                ))) : t.slideTo(s)
            } else
                t.slideTo(s)
        }
    };
    var Xy = {
        loopCreate: function(t) {
            const e = this
              , {params: i, slidesEl: n} = e;
            if (!i.loop || e.virtual && e.params.virtual.enabled)
                return;
            const r = () => {
                Ey(n, `.${i.slideClass}, swiper-slide`).forEach(( (t, e) => {
                    t.setAttribute("data-swiper-slide-index", e)
                }
                ))
            }
              , s = e.grid && i.grid && i.grid.rows > 1
              , a = i.slidesPerGroup * (s ? i.grid.rows : 1)
              , o = e.slides.length % a != 0
              , l = s && e.slides.length % i.grid.rows != 0
              , c = t => {
                for (let n = 0; n < t; n += 1) {
                    const t = e.isElement ? Ay("swiper-slide", [i.slideBlankClass]) : Ay("div", [i.slideClass, i.slideBlankClass]);
                    e.slidesEl.append(t)
                }
            }
            ;
            if (o) {
                if (i.loopAddBlankSlides) {
                    c(a - e.slides.length % a),
                    e.recalcSlides(),
                    e.updateSlides()
                } else
                    Ly("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
                r()
            } else if (l) {
                if (i.loopAddBlankSlides) {
                    c(i.grid.rows - e.slides.length % i.grid.rows),
                    e.recalcSlides(),
                    e.updateSlides()
                } else
                    Ly("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
                r()
            } else
                r();
            e.loopFix({
                slideRealIndex: t,
                direction: i.centeredSlides ? void 0 : "next"
            })
        },
        loopFix: function(t) {
            let {slideRealIndex: e, slideTo: i=!0, direction: n, setTranslate: r, activeSlideIndex: s, byController: a, byMousewheel: o} = void 0 === t ? {} : t;
            const l = this;
            if (!l.params.loop)
                return;
            l.emit("beforeLoopFix");
            const {slides: c, allowSlidePrev: h, allowSlideNext: u, slidesEl: d, params: p} = l
              , {centeredSlides: f} = p;
            if (l.allowSlidePrev = !0,
            l.allowSlideNext = !0,
            l.virtual && p.virtual.enabled)
                return i && (p.centeredSlides || 0 !== l.snapIndex ? p.centeredSlides && l.snapIndex < p.slidesPerView ? l.slideTo(l.virtual.slides.length + l.snapIndex, 0, !1, !0) : l.snapIndex === l.snapGrid.length - 1 && l.slideTo(l.virtual.slidesBefore, 0, !1, !0) : l.slideTo(l.virtual.slides.length, 0, !1, !0)),
                l.allowSlidePrev = h,
                l.allowSlideNext = u,
                void l.emit("loopFix");
            let m = p.slidesPerView;
            "auto" === m ? m = l.slidesPerViewDynamic() : (m = Math.ceil(parseFloat(p.slidesPerView, 10)),
            f && m % 2 == 0 && (m += 1));
            const g = p.slidesPerGroupAuto ? m : p.slidesPerGroup;
            let v = g;
            v % g != 0 && (v += g - v % g),
            v += p.loopAdditionalSlides,
            l.loopedSlides = v;
            const y = l.grid && p.grid && p.grid.rows > 1;
            c.length < m + v ? Ly("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters") : y && "row" === p.grid.fill && Ly("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`");
            const x = []
              , _ = [];
            let w = l.activeIndex;
            void 0 === s ? s = l.getSlideIndex(c.filter((t => t.classList.contains(p.slideActiveClass)))[0]) : w = s;
            const b = "next" === n || !n
              , M = "prev" === n || !n;
            let S = 0
              , T = 0;
            const E = y ? Math.ceil(c.length / p.grid.rows) : c.length
              , L = (y ? c[s].column : s) + (f && void 0 === r ? -m / 2 + .5 : 0);
            if (L < v) {
                S = Math.max(v - L, g);
                for (let t = 0; t < v - L; t += 1) {
                    const e = t - Math.floor(t / E) * E;
                    if (y) {
                        const t = E - e - 1;
                        for (let e = c.length - 1; e >= 0; e -= 1)
                            c[e].column === t && x.push(e)
                    } else
                        x.push(E - e - 1)
                }
            } else if (L + m > E - v) {
                T = Math.max(L - (E - 2 * v), g);
                for (let t = 0; t < T; t += 1) {
                    const e = t - Math.floor(t / E) * E;
                    y ? c.forEach(( (t, i) => {
                        t.column === e && _.push(i)
                    }
                    )) : _.push(e)
                }
            }
            if (l.__preventObserver__ = !0,
            requestAnimationFrame(( () => {
                l.__preventObserver__ = !1
            }
            )),
            M && x.forEach((t => {
                c[t].swiperLoopMoveDOM = !0,
                d.prepend(c[t]),
                c[t].swiperLoopMoveDOM = !1
            }
            )),
            b && _.forEach((t => {
                c[t].swiperLoopMoveDOM = !0,
                d.append(c[t]),
                c[t].swiperLoopMoveDOM = !1
            }
            )),
            l.recalcSlides(),
            "auto" === p.slidesPerView ? l.updateSlides() : y && (x.length > 0 && M || _.length > 0 && b) && l.slides.forEach(( (t, e) => {
                l.grid.updateSlide(e, t, l.slides)
            }
            )),
            p.watchSlidesProgress && l.updateSlidesOffset(),
            i)
                if (x.length > 0 && M) {
                    if (void 0 === e) {
                        const t = l.slidesGrid[w]
                          , e = l.slidesGrid[w + S] - t;
                        o ? l.setTranslate(l.translate - e) : (l.slideTo(w + Math.ceil(S), 0, !1, !0),
                        r && (l.touchEventsData.startTranslate = l.touchEventsData.startTranslate - e,
                        l.touchEventsData.currentTranslate = l.touchEventsData.currentTranslate - e))
                    } else if (r) {
                        const t = y ? x.length / p.grid.rows : x.length;
                        l.slideTo(l.activeIndex + t, 0, !1, !0),
                        l.touchEventsData.currentTranslate = l.translate
                    }
                } else if (_.length > 0 && b)
                    if (void 0 === e) {
                        const t = l.slidesGrid[w]
                          , e = l.slidesGrid[w - T] - t;
                        o ? l.setTranslate(l.translate - e) : (l.slideTo(w - T, 0, !1, !0),
                        r && (l.touchEventsData.startTranslate = l.touchEventsData.startTranslate - e,
                        l.touchEventsData.currentTranslate = l.touchEventsData.currentTranslate - e))
                    } else {
                        const t = y ? _.length / p.grid.rows : _.length;
                        l.slideTo(l.activeIndex - t, 0, !1, !0)
                    }
            if (l.allowSlidePrev = h,
            l.allowSlideNext = u,
            l.controller && l.controller.control && !a) {
                const t = {
                    slideRealIndex: e,
                    direction: n,
                    setTranslate: r,
                    activeSlideIndex: s,
                    byController: !0
                };
                Array.isArray(l.controller.control) ? l.controller.control.forEach((e => {
                    !e.destroyed && e.params.loop && e.loopFix({
                        ...t,
                        slideTo: e.params.slidesPerView === p.slidesPerView && i
                    })
                }
                )) : l.controller.control instanceof l.constructor && l.controller.control.params.loop && l.controller.control.loopFix({
                    ...t,
                    slideTo: l.controller.control.params.slidesPerView === p.slidesPerView && i
                })
            }
            l.emit("loopFix")
        },
        loopDestroy: function() {
            const t = this
              , {params: e, slidesEl: i} = t;
            if (!e.loop || t.virtual && t.params.virtual.enabled)
                return;
            t.recalcSlides();
            const n = [];
            t.slides.forEach((t => {
                const e = void 0 === t.swiperSlideIndex ? 1 * t.getAttribute("data-swiper-slide-index") : t.swiperSlideIndex;
                n[e] = t
            }
            )),
            t.slides.forEach((t => {
                t.removeAttribute("data-swiper-slide-index")
            }
            )),
            n.forEach((t => {
                i.append(t)
            }
            )),
            t.recalcSlides(),
            t.slideTo(t.realIndex, 0)
        }
    };
    function Jy(t, e, i) {
        const n = yy()
          , {params: r} = t
          , s = r.edgeSwipeDetection
          , a = r.edgeSwipeThreshold;
        return !s || !(i <= a || i >= n.innerWidth - a) || "prevent" === s && (e.preventDefault(),
        !0)
    }
    function Zy(t) {
        const e = this
          , i = gy();
        let n = t;
        n.originalEvent && (n = n.originalEvent);
        const r = e.touchEventsData;
        if ("pointerdown" === n.type) {
            if (null !== r.pointerId && r.pointerId !== n.pointerId)
                return;
            r.pointerId = n.pointerId
        } else
            "touchstart" === n.type && 1 === n.targetTouches.length && (r.touchId = n.targetTouches[0].identifier);
        if ("touchstart" === n.type)
            return void Jy(e, n, n.targetTouches[0].pageX);
        const {params: s, touches: a, enabled: o} = e;
        if (!o)
            return;
        if (!s.simulateTouch && "mouse" === n.pointerType)
            return;
        if (e.animating && s.preventInteractionOnTransition)
            return;
        !e.animating && s.cssMode && s.loop && e.loopFix();
        let l = n.target;
        if ("wrapper" === s.touchEventsTarget && !e.wrapperEl.contains(l))
            return;
        if ("which"in n && 3 === n.which)
            return;
        if ("button"in n && n.button > 0)
            return;
        if (r.isTouched && r.isMoved)
            return;
        const c = !!s.noSwipingClass && "" !== s.noSwipingClass
          , h = n.composedPath ? n.composedPath() : n.path;
        c && n.target && n.target.shadowRoot && h && (l = h[0]);
        const u = s.noSwipingSelector ? s.noSwipingSelector : `.${s.noSwipingClass}`
          , d = !(!n.target || !n.target.shadowRoot);
        if (s.noSwiping && (d ? function(t, e) {
            return void 0 === e && (e = this),
            function e(i) {
                if (!i || i === gy() || i === yy())
                    return null;
                i.assignedSlot && (i = i.assignedSlot);
                const n = i.closest(t);
                return n || i.getRootNode ? n || e(i.getRootNode().host) : null
            }(e)
        }(u, l) : l.closest(u)))
            return void (e.allowClick = !0);
        if (s.swipeHandler && !l.closest(s.swipeHandler))
            return;
        a.currentX = n.pageX,
        a.currentY = n.pageY;
        const p = a.currentX
          , f = a.currentY;
        if (!Jy(e, n, p))
            return;
        Object.assign(r, {
            isTouched: !0,
            isMoved: !1,
            allowTouchCallbacks: !0,
            isScrolling: void 0,
            startMoving: void 0
        }),
        a.startX = p,
        a.startY = f,
        r.touchStartTime = _y(),
        e.allowClick = !0,
        e.updateSize(),
        e.swipeDirection = void 0,
        s.threshold > 0 && (r.allowThresholdMove = !1);
        let m = !0;
        l.matches(r.focusableElements) && (m = !1,
        "SELECT" === l.nodeName && (r.isTouched = !1)),
        i.activeElement && i.activeElement.matches(r.focusableElements) && i.activeElement !== l && i.activeElement.blur();
        const g = m && e.allowTouchMove && s.touchStartPreventDefault;
        !s.touchStartForcePreventDefault && !g || l.isContentEditable || n.preventDefault(),
        s.freeMode && s.freeMode.enabled && e.freeMode && e.animating && !s.cssMode && e.freeMode.onTouchStart(),
        e.emit("touchStart", n)
    }
    function Qy(t) {
        const e = gy()
          , i = this
          , n = i.touchEventsData
          , {params: r, touches: s, rtlTranslate: a, enabled: o} = i;
        if (!o)
            return;
        if (!r.simulateTouch && "mouse" === t.pointerType)
            return;
        let l, c = t;
        if (c.originalEvent && (c = c.originalEvent),
        "pointermove" === c.type) {
            if (null !== n.touchId)
                return;
            if (c.pointerId !== n.pointerId)
                return
        }
        if ("touchmove" === c.type) {
            if (l = [...c.changedTouches].filter((t => t.identifier === n.touchId))[0],
            !l || l.identifier !== n.touchId)
                return
        } else
            l = c;
        if (!n.isTouched)
            return void (n.startMoving && n.isScrolling && i.emit("touchMoveOpposite", c));
        const h = l.pageX
          , u = l.pageY;
        if (c.preventedByNestedSwiper)
            return s.startX = h,
            void (s.startY = u);
        if (!i.allowTouchMove)
            return c.target.matches(n.focusableElements) || (i.allowClick = !1),
            void (n.isTouched && (Object.assign(s, {
                startX: h,
                startY: u,
                currentX: h,
                currentY: u
            }),
            n.touchStartTime = _y()));
        if (r.touchReleaseOnEdges && !r.loop)
            if (i.isVertical()) {
                if (u < s.startY && i.translate <= i.maxTranslate() || u > s.startY && i.translate >= i.minTranslate())
                    return n.isTouched = !1,
                    void (n.isMoved = !1)
            } else if (h < s.startX && i.translate <= i.maxTranslate() || h > s.startX && i.translate >= i.minTranslate())
                return;
        if (e.activeElement && c.target === e.activeElement && c.target.matches(n.focusableElements))
            return n.isMoved = !0,
            void (i.allowClick = !1);
        n.allowTouchCallbacks && i.emit("touchMove", c),
        s.previousX = s.currentX,
        s.previousY = s.currentY,
        s.currentX = h,
        s.currentY = u;
        const d = s.currentX - s.startX
          , p = s.currentY - s.startY;
        if (i.params.threshold && Math.sqrt(d ** 2 + p ** 2) < i.params.threshold)
            return;
        if (void 0 === n.isScrolling) {
            let t;
            i.isHorizontal() && s.currentY === s.startY || i.isVertical() && s.currentX === s.startX ? n.isScrolling = !1 : d * d + p * p >= 25 && (t = 180 * Math.atan2(Math.abs(p), Math.abs(d)) / Math.PI,
            n.isScrolling = i.isHorizontal() ? t > r.touchAngle : 90 - t > r.touchAngle)
        }
        if (n.isScrolling && i.emit("touchMoveOpposite", c),
        void 0 === n.startMoving && (s.currentX === s.startX && s.currentY === s.startY || (n.startMoving = !0)),
        n.isScrolling || "touchmove" === c.type && n.preventTouchMoveFromPointerMove)
            return void (n.isTouched = !1);
        if (!n.startMoving)
            return;
        i.allowClick = !1,
        !r.cssMode && c.cancelable && c.preventDefault(),
        r.touchMoveStopPropagation && !r.nested && c.stopPropagation();
        let f = i.isHorizontal() ? d : p
          , m = i.isHorizontal() ? s.currentX - s.previousX : s.currentY - s.previousY;
        r.oneWayMovement && (f = Math.abs(f) * (a ? 1 : -1),
        m = Math.abs(m) * (a ? 1 : -1)),
        s.diff = f,
        f *= r.touchRatio,
        a && (f = -f,
        m = -m);
        const g = i.touchesDirection;
        i.swipeDirection = f > 0 ? "prev" : "next",
        i.touchesDirection = m > 0 ? "prev" : "next";
        const v = i.params.loop && !r.cssMode
          , y = "next" === i.touchesDirection && i.allowSlideNext || "prev" === i.touchesDirection && i.allowSlidePrev;
        if (!n.isMoved) {
            if (v && y && i.loopFix({
                direction: i.swipeDirection
            }),
            n.startTranslate = i.getTranslate(),
            i.setTransition(0),
            i.animating) {
                const t = new window.CustomEvent("transitionend",{
                    bubbles: !0,
                    cancelable: !0,
                    detail: {
                        bySwiperTouchMove: !0
                    }
                });
                i.wrapperEl.dispatchEvent(t)
            }
            n.allowMomentumBounce = !1,
            !r.grabCursor || !0 !== i.allowSlideNext && !0 !== i.allowSlidePrev || i.setGrabCursor(!0),
            i.emit("sliderFirstMove", c)
        }
        if ((new Date).getTime(),
        n.isMoved && n.allowThresholdMove && g !== i.touchesDirection && v && y && Math.abs(f) >= 1)
            return Object.assign(s, {
                startX: h,
                startY: u,
                currentX: h,
                currentY: u,
                startTranslate: n.currentTranslate
            }),
            n.loopSwapReset = !0,
            void (n.startTranslate = n.currentTranslate);
        i.emit("sliderMove", c),
        n.isMoved = !0,
        n.currentTranslate = f + n.startTranslate;
        let x = !0
          , _ = r.resistanceRatio;
        if (r.touchReleaseOnEdges && (_ = 0),
        f > 0 ? (v && y && n.allowThresholdMove && n.currentTranslate > (r.centeredSlides ? i.minTranslate() - i.slidesSizesGrid[i.activeIndex + 1] : i.minTranslate()) && i.loopFix({
            direction: "prev",
            setTranslate: !0,
            activeSlideIndex: 0
        }),
        n.currentTranslate > i.minTranslate() && (x = !1,
        r.resistance && (n.currentTranslate = i.minTranslate() - 1 + (-i.minTranslate() + n.startTranslate + f) ** _))) : f < 0 && (v && y && n.allowThresholdMove && n.currentTranslate < (r.centeredSlides ? i.maxTranslate() + i.slidesSizesGrid[i.slidesSizesGrid.length - 1] : i.maxTranslate()) && i.loopFix({
            direction: "next",
            setTranslate: !0,
            activeSlideIndex: i.slides.length - ("auto" === r.slidesPerView ? i.slidesPerViewDynamic() : Math.ceil(parseFloat(r.slidesPerView, 10)))
        }),
        n.currentTranslate < i.maxTranslate() && (x = !1,
        r.resistance && (n.currentTranslate = i.maxTranslate() + 1 - (i.maxTranslate() - n.startTranslate - f) ** _))),
        x && (c.preventedByNestedSwiper = !0),
        !i.allowSlideNext && "next" === i.swipeDirection && n.currentTranslate < n.startTranslate && (n.currentTranslate = n.startTranslate),
        !i.allowSlidePrev && "prev" === i.swipeDirection && n.currentTranslate > n.startTranslate && (n.currentTranslate = n.startTranslate),
        i.allowSlidePrev || i.allowSlideNext || (n.currentTranslate = n.startTranslate),
        r.threshold > 0) {
            if (!(Math.abs(f) > r.threshold || n.allowThresholdMove))
                return void (n.currentTranslate = n.startTranslate);
            if (!n.allowThresholdMove)
                return n.allowThresholdMove = !0,
                s.startX = s.currentX,
                s.startY = s.currentY,
                n.currentTranslate = n.startTranslate,
                void (s.diff = i.isHorizontal() ? s.currentX - s.startX : s.currentY - s.startY)
        }
        r.followFinger && !r.cssMode && ((r.freeMode && r.freeMode.enabled && i.freeMode || r.watchSlidesProgress) && (i.updateActiveIndex(),
        i.updateSlidesClasses()),
        r.freeMode && r.freeMode.enabled && i.freeMode && i.freeMode.onTouchMove(),
        i.updateProgress(n.currentTranslate),
        i.setTranslate(n.currentTranslate))
    }
    function $y(t) {
        const e = this
          , i = e.touchEventsData;
        let n, r = t;
        r.originalEvent && (r = r.originalEvent);
        if ("touchend" === r.type || "touchcancel" === r.type) {
            if (n = [...r.changedTouches].filter((t => t.identifier === i.touchId))[0],
            !n || n.identifier !== i.touchId)
                return
        } else {
            if (null !== i.touchId)
                return;
            if (r.pointerId !== i.pointerId)
                return;
            n = r
        }
        if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(r.type)) {
            if (!(["pointercancel", "contextmenu"].includes(r.type) && (e.browser.isSafari || e.browser.isWebView)))
                return
        }
        i.pointerId = null,
        i.touchId = null;
        const {params: s, touches: a, rtlTranslate: o, slidesGrid: l, enabled: c} = e;
        if (!c)
            return;
        if (!s.simulateTouch && "mouse" === r.pointerType)
            return;
        if (i.allowTouchCallbacks && e.emit("touchEnd", r),
        i.allowTouchCallbacks = !1,
        !i.isTouched)
            return i.isMoved && s.grabCursor && e.setGrabCursor(!1),
            i.isMoved = !1,
            void (i.startMoving = !1);
        s.grabCursor && i.isMoved && i.isTouched && (!0 === e.allowSlideNext || !0 === e.allowSlidePrev) && e.setGrabCursor(!1);
        const h = _y()
          , u = h - i.touchStartTime;
        if (e.allowClick) {
            const t = r.path || r.composedPath && r.composedPath();
            e.updateClickedSlide(t && t[0] || r.target, t),
            e.emit("tap click", r),
            u < 300 && h - i.lastClickTime < 300 && e.emit("doubleTap doubleClick", r)
        }
        if (i.lastClickTime = _y(),
        xy(( () => {
            e.destroyed || (e.allowClick = !0)
        }
        )),
        !i.isTouched || !i.isMoved || !e.swipeDirection || 0 === a.diff && !i.loopSwapReset || i.currentTranslate === i.startTranslate && !i.loopSwapReset)
            return i.isTouched = !1,
            i.isMoved = !1,
            void (i.startMoving = !1);
        let d;
        if (i.isTouched = !1,
        i.isMoved = !1,
        i.startMoving = !1,
        d = s.followFinger ? o ? e.translate : -e.translate : -i.currentTranslate,
        s.cssMode)
            return;
        if (s.freeMode && s.freeMode.enabled)
            return void e.freeMode.onTouchEnd({
                currentPos: d
            });
        const p = d >= -e.maxTranslate() && !e.params.loop;
        let f = 0
          , m = e.slidesSizesGrid[0];
        for (let t = 0; t < l.length; t += t < s.slidesPerGroupSkip ? 1 : s.slidesPerGroup) {
            const e = t < s.slidesPerGroupSkip - 1 ? 1 : s.slidesPerGroup;
            void 0 !== l[t + e] ? (p || d >= l[t] && d < l[t + e]) && (f = t,
            m = l[t + e] - l[t]) : (p || d >= l[t]) && (f = t,
            m = l[l.length - 1] - l[l.length - 2])
        }
        let g = null
          , v = null;
        s.rewind && (e.isBeginning ? v = s.virtual && s.virtual.enabled && e.virtual ? e.virtual.slides.length - 1 : e.slides.length - 1 : e.isEnd && (g = 0));
        const y = (d - l[f]) / m
          , x = f < s.slidesPerGroupSkip - 1 ? 1 : s.slidesPerGroup;
        if (u > s.longSwipesMs) {
            if (!s.longSwipes)
                return void e.slideTo(e.activeIndex);
            "next" === e.swipeDirection && (y >= s.longSwipesRatio ? e.slideTo(s.rewind && e.isEnd ? g : f + x) : e.slideTo(f)),
            "prev" === e.swipeDirection && (y > 1 - s.longSwipesRatio ? e.slideTo(f + x) : null !== v && y < 0 && Math.abs(y) > s.longSwipesRatio ? e.slideTo(v) : e.slideTo(f))
        } else {
            if (!s.shortSwipes)
                return void e.slideTo(e.activeIndex);
            e.navigation && (r.target === e.navigation.nextEl || r.target === e.navigation.prevEl) ? r.target === e.navigation.nextEl ? e.slideTo(f + x) : e.slideTo(f) : ("next" === e.swipeDirection && e.slideTo(null !== g ? g : f + x),
            "prev" === e.swipeDirection && e.slideTo(null !== v ? v : f))
        }
    }
    function Ky() {
        const t = this
          , {params: e, el: i} = t;
        if (i && 0 === i.offsetWidth)
            return;
        e.breakpoints && t.setBreakpoint();
        const {allowSlideNext: n, allowSlidePrev: r, snapGrid: s} = t
          , a = t.virtual && t.params.virtual.enabled;
        t.allowSlideNext = !0,
        t.allowSlidePrev = !0,
        t.updateSize(),
        t.updateSlides(),
        t.updateSlidesClasses();
        const o = a && e.loop;
        !("auto" === e.slidesPerView || e.slidesPerView > 1) || !t.isEnd || t.isBeginning || t.params.centeredSlides || o ? t.params.loop && !a ? t.slideToLoop(t.realIndex, 0, !1, !0) : t.slideTo(t.activeIndex, 0, !1, !0) : t.slideTo(t.slides.length - 1, 0, !1, !0),
        t.autoplay && t.autoplay.running && t.autoplay.paused && (clearTimeout(t.autoplay.resizeTimeout),
        t.autoplay.resizeTimeout = setTimeout(( () => {
            t.autoplay && t.autoplay.running && t.autoplay.paused && t.autoplay.resume()
        }
        ), 500)),
        t.allowSlidePrev = r,
        t.allowSlideNext = n,
        t.params.watchOverflow && s !== t.snapGrid && t.checkOverflow()
    }
    function tx(t) {
        const e = this;
        e.enabled && (e.allowClick || (e.params.preventClicks && t.preventDefault(),
        e.params.preventClicksPropagation && e.animating && (t.stopPropagation(),
        t.stopImmediatePropagation())))
    }
    function ex() {
        const t = this
          , {wrapperEl: e, rtlTranslate: i, enabled: n} = t;
        if (!n)
            return;
        let r;
        t.previousTranslate = t.translate,
        t.isHorizontal() ? t.translate = -e.scrollLeft : t.translate = -e.scrollTop,
        0 === t.translate && (t.translate = 0),
        t.updateActiveIndex(),
        t.updateSlidesClasses();
        const s = t.maxTranslate() - t.minTranslate();
        r = 0 === s ? 0 : (t.translate - t.minTranslate()) / s,
        r !== t.progress && t.updateProgress(i ? -t.translate : t.translate),
        t.emit("setTranslate", t.translate, !1)
    }
    function ix(t) {
        const e = this;
        Uy(e, t.target),
        e.params.cssMode || "auto" !== e.params.slidesPerView && !e.params.autoHeight || e.update()
    }
    function nx() {
        const t = this;
        t.documentTouchHandlerProceeded || (t.documentTouchHandlerProceeded = !0,
        t.params.touchReleaseOnEdges && (t.el.style.touchAction = "auto"))
    }
    const rx = (t, e) => {
        const i = gy()
          , {params: n, el: r, wrapperEl: s, device: a} = t
          , o = !!n.nested
          , l = "on" === e ? "addEventListener" : "removeEventListener"
          , c = e;
        i[l]("touchstart", t.onDocumentTouchStart, {
            passive: !1,
            capture: o
        }),
        r[l]("touchstart", t.onTouchStart, {
            passive: !1
        }),
        r[l]("pointerdown", t.onTouchStart, {
            passive: !1
        }),
        i[l]("touchmove", t.onTouchMove, {
            passive: !1,
            capture: o
        }),
        i[l]("pointermove", t.onTouchMove, {
            passive: !1,
            capture: o
        }),
        i[l]("touchend", t.onTouchEnd, {
            passive: !0
        }),
        i[l]("pointerup", t.onTouchEnd, {
            passive: !0
        }),
        i[l]("pointercancel", t.onTouchEnd, {
            passive: !0
        }),
        i[l]("touchcancel", t.onTouchEnd, {
            passive: !0
        }),
        i[l]("pointerout", t.onTouchEnd, {
            passive: !0
        }),
        i[l]("pointerleave", t.onTouchEnd, {
            passive: !0
        }),
        i[l]("contextmenu", t.onTouchEnd, {
            passive: !0
        }),
        (n.preventClicks || n.preventClicksPropagation) && r[l]("click", t.onClick, !0),
        n.cssMode && s[l]("scroll", t.onScroll),
        n.updateOnWindowResize ? t[c](a.ios || a.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", Ky, !0) : t[c]("observerUpdate", Ky, !0),
        r[l]("load", t.onLoad, {
            capture: !0
        })
    }
    ;
    const sx = (t, e) => t.grid && e.grid && e.grid.rows > 1;
    var ax = {
        init: !0,
        direction: "horizontal",
        oneWayMovement: !1,
        swiperElementNodeName: "SWIPER-CONTAINER",
        touchEventsTarget: "wrapper",
        initialSlide: 0,
        speed: 300,
        cssMode: !1,
        updateOnWindowResize: !0,
        resizeObserver: !0,
        nested: !1,
        createElements: !1,
        eventsPrefix: "swiper",
        enabled: !0,
        focusableElements: "input, select, option, textarea, button, video, label",
        width: null,
        height: null,
        preventInteractionOnTransition: !1,
        userAgent: null,
        url: null,
        edgeSwipeDetection: !1,
        edgeSwipeThreshold: 20,
        autoHeight: !1,
        setWrapperSize: !1,
        virtualTranslate: !1,
        effect: "slide",
        breakpoints: void 0,
        breakpointsBase: "window",
        spaceBetween: 0,
        slidesPerView: 1,
        slidesPerGroup: 1,
        slidesPerGroupSkip: 0,
        slidesPerGroupAuto: !1,
        centeredSlides: !1,
        centeredSlidesBounds: !1,
        slidesOffsetBefore: 0,
        slidesOffsetAfter: 0,
        normalizeSlideIndex: !0,
        centerInsufficientSlides: !1,
        watchOverflow: !0,
        roundLengths: !1,
        touchRatio: 1,
        touchAngle: 45,
        simulateTouch: !0,
        shortSwipes: !0,
        longSwipes: !0,
        longSwipesRatio: .5,
        longSwipesMs: 300,
        followFinger: !0,
        allowTouchMove: !0,
        threshold: 5,
        touchMoveStopPropagation: !1,
        touchStartPreventDefault: !0,
        touchStartForcePreventDefault: !1,
        touchReleaseOnEdges: !1,
        uniqueNavElements: !0,
        resistance: !0,
        resistanceRatio: .85,
        watchSlidesProgress: !1,
        grabCursor: !1,
        preventClicks: !0,
        preventClicksPropagation: !0,
        slideToClickedSlide: !1,
        loop: !1,
        loopAddBlankSlides: !0,
        loopAdditionalSlides: 0,
        loopPreventsSliding: !0,
        rewind: !1,
        allowSlidePrev: !0,
        allowSlideNext: !0,
        swipeHandler: null,
        noSwiping: !0,
        noSwipingClass: "swiper-no-swiping",
        noSwipingSelector: null,
        passiveListeners: !0,
        maxBackfaceHiddenSlides: 10,
        containerModifierClass: "swiper-",
        slideClass: "swiper-slide",
        slideBlankClass: "swiper-slide-blank",
        slideActiveClass: "swiper-slide-active",
        slideVisibleClass: "swiper-slide-visible",
        slideFullyVisibleClass: "swiper-slide-fully-visible",
        slideNextClass: "swiper-slide-next",
        slidePrevClass: "swiper-slide-prev",
        wrapperClass: "swiper-wrapper",
        lazyPreloaderClass: "swiper-lazy-preloader",
        lazyPreloadPrevNext: 0,
        runCallbacksOnInit: !0,
        _emitClasses: !1
    };
    function ox(t, e) {
        return function(i) {
            void 0 === i && (i = {});
            const n = Object.keys(i)[0]
              , r = i[n];
            "object" == typeof r && null !== r ? (!0 === t[n] && (t[n] = {
                enabled: !0
            }),
            "navigation" === n && t[n] && t[n].enabled && !t[n].prevEl && !t[n].nextEl && (t[n].auto = !0),
            ["pagination", "scrollbar"].indexOf(n) >= 0 && t[n] && t[n].enabled && !t[n].el && (t[n].auto = !0),
            n in t && "enabled"in r ? ("object" != typeof t[n] || "enabled"in t[n] || (t[n].enabled = !0),
            t[n] || (t[n] = {
                enabled: !1
            }),
            My(e, i)) : My(e, i)) : My(e, i)
        }
    }
    const lx = {
        eventsEmitter: By,
        update: Wy,
        translate: qy,
        transition: {
            setTransition: function(t, e) {
                const i = this;
                i.params.cssMode || (i.wrapperEl.style.transitionDuration = `${t}ms`,
                i.wrapperEl.style.transitionDelay = 0 === t ? "0ms" : ""),
                i.emit("setTransition", t, e)
            },
            transitionStart: function(t, e) {
                void 0 === t && (t = !0);
                const i = this
                  , {params: n} = i;
                n.cssMode || (n.autoHeight && i.updateAutoHeight(),
                jy({
                    swiper: i,
                    runCallbacks: t,
                    direction: e,
                    step: "Start"
                }))
            },
            transitionEnd: function(t, e) {
                void 0 === t && (t = !0);
                const i = this
                  , {params: n} = i;
                i.animating = !1,
                n.cssMode || (i.setTransition(0),
                jy({
                    swiper: i,
                    runCallbacks: t,
                    direction: e,
                    step: "End"
                }))
            }
        },
        slide: Yy,
        loop: Xy,
        grabCursor: {
            setGrabCursor: function(t) {
                const e = this;
                if (!e.params.simulateTouch || e.params.watchOverflow && e.isLocked || e.params.cssMode)
                    return;
                const i = "container" === e.params.touchEventsTarget ? e.el : e.wrapperEl;
                e.isElement && (e.__preventObserver__ = !0),
                i.style.cursor = "move",
                i.style.cursor = t ? "grabbing" : "grab",
                e.isElement && requestAnimationFrame(( () => {
                    e.__preventObserver__ = !1
                }
                ))
            },
            unsetGrabCursor: function() {
                const t = this;
                t.params.watchOverflow && t.isLocked || t.params.cssMode || (t.isElement && (t.__preventObserver__ = !0),
                t["container" === t.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "",
                t.isElement && requestAnimationFrame(( () => {
                    t.__preventObserver__ = !1
                }
                )))
            }
        },
        events: {
            attachEvents: function() {
                const t = this
                  , {params: e} = t;
                t.onTouchStart = Zy.bind(t),
                t.onTouchMove = Qy.bind(t),
                t.onTouchEnd = $y.bind(t),
                t.onDocumentTouchStart = nx.bind(t),
                e.cssMode && (t.onScroll = ex.bind(t)),
                t.onClick = tx.bind(t),
                t.onLoad = ix.bind(t),
                rx(t, "on")
            },
            detachEvents: function() {
                rx(this, "off")
            }
        },
        breakpoints: {
            setBreakpoint: function() {
                const t = this
                  , {realIndex: e, initialized: i, params: n, el: r} = t
                  , s = n.breakpoints;
                if (!s || s && 0 === Object.keys(s).length)
                    return;
                const a = t.getBreakpoint(s, t.params.breakpointsBase, t.el);
                if (!a || t.currentBreakpoint === a)
                    return;
                const o = (a in s ? s[a] : void 0) || t.originalParams
                  , l = sx(t, n)
                  , c = sx(t, o)
                  , h = t.params.grabCursor
                  , u = o.grabCursor
                  , d = n.enabled;
                l && !c ? (r.classList.remove(`${n.containerModifierClass}grid`, `${n.containerModifierClass}grid-column`),
                t.emitContainerClasses()) : !l && c && (r.classList.add(`${n.containerModifierClass}grid`),
                (o.grid.fill && "column" === o.grid.fill || !o.grid.fill && "column" === n.grid.fill) && r.classList.add(`${n.containerModifierClass}grid-column`),
                t.emitContainerClasses()),
                h && !u ? t.unsetGrabCursor() : !h && u && t.setGrabCursor(),
                ["navigation", "pagination", "scrollbar"].forEach((e => {
                    if (void 0 === o[e])
                        return;
                    const i = n[e] && n[e].enabled
                      , r = o[e] && o[e].enabled;
                    i && !r && t[e].disable(),
                    !i && r && t[e].enable()
                }
                ));
                const p = o.direction && o.direction !== n.direction
                  , f = n.loop && (o.slidesPerView !== n.slidesPerView || p)
                  , m = n.loop;
                p && i && t.changeDirection(),
                My(t.params, o);
                const g = t.params.enabled
                  , v = t.params.loop;
                Object.assign(t, {
                    allowTouchMove: t.params.allowTouchMove,
                    allowSlideNext: t.params.allowSlideNext,
                    allowSlidePrev: t.params.allowSlidePrev
                }),
                d && !g ? t.disable() : !d && g && t.enable(),
                t.currentBreakpoint = a,
                t.emit("_beforeBreakpoint", o),
                i && (f ? (t.loopDestroy(),
                t.loopCreate(e),
                t.updateSlides()) : !m && v ? (t.loopCreate(e),
                t.updateSlides()) : m && !v && t.loopDestroy()),
                t.emit("breakpoint", o)
            },
            getBreakpoint: function(t, e, i) {
                if (void 0 === e && (e = "window"),
                !t || "container" === e && !i)
                    return;
                let n = !1;
                const r = yy()
                  , s = "window" === e ? r.innerHeight : i.clientHeight
                  , a = Object.keys(t).map((t => {
                    if ("string" == typeof t && 0 === t.indexOf("@")) {
                        const e = parseFloat(t.substr(1));
                        return {
                            value: s * e,
                            point: t
                        }
                    }
                    return {
                        value: t,
                        point: t
                    }
                }
                ));
                a.sort(( (t, e) => parseInt(t.value, 10) - parseInt(e.value, 10)));
                for (let t = 0; t < a.length; t += 1) {
                    const {point: s, value: o} = a[t];
                    "window" === e ? r.matchMedia(`(min-width: ${o}px)`).matches && (n = s) : o <= i.clientWidth && (n = s)
                }
                return n || "max"
            }
        },
        checkOverflow: {
            checkOverflow: function() {
                const t = this
                  , {isLocked: e, params: i} = t
                  , {slidesOffsetBefore: n} = i;
                if (n) {
                    const e = t.slides.length - 1
                      , i = t.slidesGrid[e] + t.slidesSizesGrid[e] + 2 * n;
                    t.isLocked = t.size > i
                } else
                    t.isLocked = 1 === t.snapGrid.length;
                !0 === i.allowSlideNext && (t.allowSlideNext = !t.isLocked),
                !0 === i.allowSlidePrev && (t.allowSlidePrev = !t.isLocked),
                e && e !== t.isLocked && (t.isEnd = !1),
                e !== t.isLocked && t.emit(t.isLocked ? "lock" : "unlock")
            }
        },
        classes: {
            addClasses: function() {
                const t = this
                  , {classNames: e, params: i, rtl: n, el: r, device: s} = t
                  , a = function(t, e) {
                    const i = [];
                    return t.forEach((t => {
                        "object" == typeof t ? Object.keys(t).forEach((n => {
                            t[n] && i.push(e + n)
                        }
                        )) : "string" == typeof t && i.push(e + t)
                    }
                    )),
                    i
                }(["initialized", i.direction, {
                    "free-mode": t.params.freeMode && i.freeMode.enabled
                }, {
                    autoheight: i.autoHeight
                }, {
                    rtl: n
                }, {
                    grid: i.grid && i.grid.rows > 1
                }, {
                    "grid-column": i.grid && i.grid.rows > 1 && "column" === i.grid.fill
                }, {
                    android: s.android
                }, {
                    ios: s.ios
                }, {
                    "css-mode": i.cssMode
                }, {
                    centered: i.cssMode && i.centeredSlides
                }, {
                    "watch-progress": i.watchSlidesProgress
                }], i.containerModifierClass);
                e.push(...a),
                r.classList.add(...e),
                t.emitContainerClasses()
            },
            removeClasses: function() {
                const {el: t, classNames: e} = this;
                t.classList.remove(...e),
                this.emitContainerClasses()
            }
        }
    }
      , cx = {};
    class hx {
        constructor() {
            let t, e;
            for (var i = arguments.length, n = new Array(i), r = 0; r < i; r++)
                n[r] = arguments[r];
            1 === n.length && n[0].constructor && "Object" === Object.prototype.toString.call(n[0]).slice(8, -1) ? e = n[0] : [t,e] = n,
            e || (e = {}),
            e = My({}, e),
            t && !e.el && (e.el = t);
            const s = gy();
            if (e.el && "string" == typeof e.el && s.querySelectorAll(e.el).length > 1) {
                const t = [];
                return s.querySelectorAll(e.el).forEach((i => {
                    const n = My({}, e, {
                        el: i
                    });
                    t.push(new hx(n))
                }
                )),
                t
            }
            const a = this;
            a.__swiper__ = !0,
            a.support = Oy(),
            a.device = zy({
                userAgent: e.userAgent
            }),
            a.browser = ky(),
            a.eventsListeners = {},
            a.eventsAnyListeners = [],
            a.modules = [...a.__modules__],
            e.modules && Array.isArray(e.modules) && a.modules.push(...e.modules);
            const o = {};
            a.modules.forEach((t => {
                t({
                    params: e,
                    swiper: a,
                    extendParams: ox(e, o),
                    on: a.on.bind(a),
                    once: a.once.bind(a),
                    off: a.off.bind(a),
                    emit: a.emit.bind(a)
                })
            }
            ));
            const l = My({}, ax, o);
            return a.params = My({}, l, cx, e),
            a.originalParams = My({}, a.params),
            a.passedParams = My({}, e),
            a.params && a.params.on && Object.keys(a.params.on).forEach((t => {
                a.on(t, a.params.on[t])
            }
            )),
            a.params && a.params.onAny && a.onAny(a.params.onAny),
            Object.assign(a, {
                enabled: a.params.enabled,
                el: t,
                classNames: [],
                slides: [],
                slidesGrid: [],
                snapGrid: [],
                slidesSizesGrid: [],
                isHorizontal: () => "horizontal" === a.params.direction,
                isVertical: () => "vertical" === a.params.direction,
                activeIndex: 0,
                realIndex: 0,
                isBeginning: !0,
                isEnd: !1,
                translate: 0,
                previousTranslate: 0,
                progress: 0,
                velocity: 0,
                animating: !1,
                cssOverflowAdjustment() {
                    return Math.trunc(this.translate / 2 ** 23) * 2 ** 23
                },
                allowSlideNext: a.params.allowSlideNext,
                allowSlidePrev: a.params.allowSlidePrev,
                touchEventsData: {
                    isTouched: void 0,
                    isMoved: void 0,
                    allowTouchCallbacks: void 0,
                    touchStartTime: void 0,
                    isScrolling: void 0,
                    currentTranslate: void 0,
                    startTranslate: void 0,
                    allowThresholdMove: void 0,
                    focusableElements: a.params.focusableElements,
                    lastClickTime: 0,
                    clickTimeout: void 0,
                    velocities: [],
                    allowMomentumBounce: void 0,
                    startMoving: void 0,
                    pointerId: null,
                    touchId: null
                },
                allowClick: !0,
                allowTouchMove: a.params.allowTouchMove,
                touches: {
                    startX: 0,
                    startY: 0,
                    currentX: 0,
                    currentY: 0,
                    diff: 0
                },
                imagesToLoad: [],
                imagesLoaded: 0
            }),
            a.emit("_swiper"),
            a.params.init && a.init(),
            a
        }
        getDirectionLabel(t) {
            return this.isHorizontal() ? t : {
                width: "height",
                "margin-top": "margin-left",
                "margin-bottom ": "margin-right",
                "margin-left": "margin-top",
                "margin-right": "margin-bottom",
                "padding-left": "padding-top",
                "padding-right": "padding-bottom",
                marginRight: "marginBottom"
            }[t]
        }
        getSlideIndex(t) {
            const {slidesEl: e, params: i} = this
              , n = Py(Ey(e, `.${i.slideClass}, swiper-slide`)[0]);
            return Py(t) - n
        }
        getSlideIndexByData(t) {
            return this.getSlideIndex(this.slides.filter((e => 1 * e.getAttribute("data-swiper-slide-index") === t))[0])
        }
        recalcSlides() {
            const {slidesEl: t, params: e} = this;
            this.slides = Ey(t, `.${e.slideClass}, swiper-slide`)
        }
        enable() {
            const t = this;
            t.enabled || (t.enabled = !0,
            t.params.grabCursor && t.setGrabCursor(),
            t.emit("enable"))
        }
        disable() {
            const t = this;
            t.enabled && (t.enabled = !1,
            t.params.grabCursor && t.unsetGrabCursor(),
            t.emit("disable"))
        }
        setProgress(t, e) {
            const i = this;
            t = Math.min(Math.max(t, 0), 1);
            const n = i.minTranslate()
              , r = (i.maxTranslate() - n) * t + n;
            i.translateTo(r, void 0 === e ? 0 : e),
            i.updateActiveIndex(),
            i.updateSlidesClasses()
        }
        emitContainerClasses() {
            const t = this;
            if (!t.params._emitClasses || !t.el)
                return;
            const e = t.el.className.split(" ").filter((e => 0 === e.indexOf("swiper") || 0 === e.indexOf(t.params.containerModifierClass)));
            t.emit("_containerClasses", e.join(" "))
        }
        getSlideClasses(t) {
            const e = this;
            return e.destroyed ? "" : t.className.split(" ").filter((t => 0 === t.indexOf("swiper-slide") || 0 === t.indexOf(e.params.slideClass))).join(" ")
        }
        emitSlidesClasses() {
            const t = this;
            if (!t.params._emitClasses || !t.el)
                return;
            const e = [];
            t.slides.forEach((i => {
                const n = t.getSlideClasses(i);
                e.push({
                    slideEl: i,
                    classNames: n
                }),
                t.emit("_slideClass", i, n)
            }
            )),
            t.emit("_slideClasses", e)
        }
        slidesPerViewDynamic(t, e) {
            void 0 === t && (t = "current"),
            void 0 === e && (e = !1);
            const {params: i, slides: n, slidesGrid: r, slidesSizesGrid: s, size: a, activeIndex: o} = this;
            let l = 1;
            if ("number" == typeof i.slidesPerView)
                return i.slidesPerView;
            if (i.centeredSlides) {
                let t, e = n[o] ? Math.ceil(n[o].swiperSlideSize) : 0;
                for (let i = o + 1; i < n.length; i += 1)
                    n[i] && !t && (e += Math.ceil(n[i].swiperSlideSize),
                    l += 1,
                    e > a && (t = !0));
                for (let i = o - 1; i >= 0; i -= 1)
                    n[i] && !t && (e += n[i].swiperSlideSize,
                    l += 1,
                    e > a && (t = !0))
            } else if ("current" === t)
                for (let t = o + 1; t < n.length; t += 1) {
                    (e ? r[t] + s[t] - r[o] < a : r[t] - r[o] < a) && (l += 1)
                }
            else
                for (let t = o - 1; t >= 0; t -= 1) {
                    r[o] - r[t] < a && (l += 1)
                }
            return l
        }
        update() {
            const t = this;
            if (!t || t.destroyed)
                return;
            const {snapGrid: e, params: i} = t;
            function n() {
                const e = t.rtlTranslate ? -1 * t.translate : t.translate
                  , i = Math.min(Math.max(e, t.maxTranslate()), t.minTranslate());
                t.setTranslate(i),
                t.updateActiveIndex(),
                t.updateSlidesClasses()
            }
            let r;
            if (i.breakpoints && t.setBreakpoint(),
            [...t.el.querySelectorAll('[loading="lazy"]')].forEach((e => {
                e.complete && Uy(t, e)
            }
            )),
            t.updateSize(),
            t.updateSlides(),
            t.updateProgress(),
            t.updateSlidesClasses(),
            i.freeMode && i.freeMode.enabled && !i.cssMode)
                n(),
                i.autoHeight && t.updateAutoHeight();
            else {
                if (("auto" === i.slidesPerView || i.slidesPerView > 1) && t.isEnd && !i.centeredSlides) {
                    const e = t.virtual && i.virtual.enabled ? t.virtual.slides : t.slides;
                    r = t.slideTo(e.length - 1, 0, !1, !0)
                } else
                    r = t.slideTo(t.activeIndex, 0, !1, !0);
                r || n()
            }
            i.watchOverflow && e !== t.snapGrid && t.checkOverflow(),
            t.emit("update")
        }
        changeDirection(t, e) {
            void 0 === e && (e = !0);
            const i = this
              , n = i.params.direction;
            return t || (t = "horizontal" === n ? "vertical" : "horizontal"),
            t === n || "horizontal" !== t && "vertical" !== t || (i.el.classList.remove(`${i.params.containerModifierClass}${n}`),
            i.el.classList.add(`${i.params.containerModifierClass}${t}`),
            i.emitContainerClasses(),
            i.params.direction = t,
            i.slides.forEach((e => {
                "vertical" === t ? e.style.width = "" : e.style.height = ""
            }
            )),
            i.emit("changeDirection"),
            e && i.update()),
            i
        }
        changeLanguageDirection(t) {
            const e = this;
            e.rtl && "rtl" === t || !e.rtl && "ltr" === t || (e.rtl = "rtl" === t,
            e.rtlTranslate = "horizontal" === e.params.direction && e.rtl,
            e.rtl ? (e.el.classList.add(`${e.params.containerModifierClass}rtl`),
            e.el.dir = "rtl") : (e.el.classList.remove(`${e.params.containerModifierClass}rtl`),
            e.el.dir = "ltr"),
            e.update())
        }
        mount(t) {
            const e = this;
            if (e.mounted)
                return !0;
            let i = t || e.params.el;
            if ("string" == typeof i && (i = document.querySelector(i)),
            !i)
                return !1;
            i.swiper = e,
            i.parentNode && i.parentNode.host && i.parentNode.host.nodeName === e.params.swiperElementNodeName.toUpperCase() && (e.isElement = !0);
            const n = () => `.${(e.params.wrapperClass || "").trim().split(" ").join(".")}`;
            let r = ( () => {
                if (i && i.shadowRoot && i.shadowRoot.querySelector) {
                    return i.shadowRoot.querySelector(n())
                }
                return Ey(i, n())[0]
            }
            )();
            return !r && e.params.createElements && (r = Ay("div", e.params.wrapperClass),
            i.append(r),
            Ey(i, `.${e.params.slideClass}`).forEach((t => {
                r.append(t)
            }
            ))),
            Object.assign(e, {
                el: i,
                wrapperEl: r,
                slidesEl: e.isElement && !i.parentNode.host.slideSlots ? i.parentNode.host : r,
                hostEl: e.isElement ? i.parentNode.host : i,
                mounted: !0,
                rtl: "rtl" === i.dir.toLowerCase() || "rtl" === Cy(i, "direction"),
                rtlTranslate: "horizontal" === e.params.direction && ("rtl" === i.dir.toLowerCase() || "rtl" === Cy(i, "direction")),
                wrongRTL: "-webkit-box" === Cy(r, "display")
            }),
            !0
        }
        init(t) {
            const e = this;
            if (e.initialized)
                return e;
            if (!1 === e.mount(t))
                return e;
            e.emit("beforeInit"),
            e.params.breakpoints && e.setBreakpoint(),
            e.addClasses(),
            e.updateSize(),
            e.updateSlides(),
            e.params.watchOverflow && e.checkOverflow(),
            e.params.grabCursor && e.enabled && e.setGrabCursor(),
            e.params.loop && e.virtual && e.params.virtual.enabled ? e.slideTo(e.params.initialSlide + e.virtual.slidesBefore, 0, e.params.runCallbacksOnInit, !1, !0) : e.slideTo(e.params.initialSlide, 0, e.params.runCallbacksOnInit, !1, !0),
            e.params.loop && e.loopCreate(),
            e.attachEvents();
            const i = [...e.el.querySelectorAll('[loading="lazy"]')];
            return e.isElement && i.push(...e.hostEl.querySelectorAll('[loading="lazy"]')),
            i.forEach((t => {
                t.complete ? Uy(e, t) : t.addEventListener("load", (t => {
                    Uy(e, t.target)
                }
                ))
            }
            )),
            Vy(e),
            e.initialized = !0,
            Vy(e),
            e.emit("init"),
            e.emit("afterInit"),
            e
        }
        destroy(t, e) {
            void 0 === t && (t = !0),
            void 0 === e && (e = !0);
            const i = this
              , {params: n, el: r, wrapperEl: s, slides: a} = i;
            return void 0 === i.params || i.destroyed || (i.emit("beforeDestroy"),
            i.initialized = !1,
            i.detachEvents(),
            n.loop && i.loopDestroy(),
            e && (i.removeClasses(),
            r.removeAttribute("style"),
            s.removeAttribute("style"),
            a && a.length && a.forEach((t => {
                t.classList.remove(n.slideVisibleClass, n.slideFullyVisibleClass, n.slideActiveClass, n.slideNextClass, n.slidePrevClass),
                t.removeAttribute("style"),
                t.removeAttribute("data-swiper-slide-index")
            }
            ))),
            i.emit("destroy"),
            Object.keys(i.eventsListeners).forEach((t => {
                i.off(t)
            }
            )),
            !1 !== t && (i.el.swiper = null,
            function(t) {
                const e = t;
                Object.keys(e).forEach((t => {
                    try {
                        e[t] = null
                    } catch (t) {}
                    try {
                        delete e[t]
                    } catch (t) {}
                }
                ))
            }(i)),
            i.destroyed = !0),
            null
        }
        static extendDefaults(t) {
            My(cx, t)
        }
        static get extendedDefaults() {
            return cx
        }
        static get defaults() {
            return ax
        }
        static installModule(t) {
            hx.prototype.__modules__ || (hx.prototype.__modules__ = []);
            const e = hx.prototype.__modules__;
            "function" == typeof t && e.indexOf(t) < 0 && e.push(t)
        }
        static use(t) {
            return Array.isArray(t) ? (t.forEach((t => hx.installModule(t))),
            hx) : (hx.installModule(t),
            hx)
        }
    }
    Object.keys(lx).forEach((t => {
        Object.keys(lx[t]).forEach((e => {
            hx.prototype[e] = lx[t][e]
        }
        ))
    }
    )),
    hx.use([function(t) {
        let {swiper: e, on: i, emit: n} = t;
        const r = yy();
        let s = null
          , a = null;
        const o = () => {
            e && !e.destroyed && e.initialized && (n("beforeResize"),
            n("resize"))
        }
          , l = () => {
            e && !e.destroyed && e.initialized && n("orientationchange")
        }
        ;
        i("init", ( () => {
            e.params.resizeObserver && void 0 !== r.ResizeObserver ? e && !e.destroyed && e.initialized && (s = new ResizeObserver((t => {
                a = r.requestAnimationFrame(( () => {
                    const {width: i, height: n} = e;
                    let r = i
                      , s = n;
                    t.forEach((t => {
                        let {contentBoxSize: i, contentRect: n, target: a} = t;
                        a && a !== e.el || (r = n ? n.width : (i[0] || i).inlineSize,
                        s = n ? n.height : (i[0] || i).blockSize)
                    }
                    )),
                    r === i && s === n || o()
                }
                ))
            }
            )),
            s.observe(e.el)) : (r.addEventListener("resize", o),
            r.addEventListener("orientationchange", l))
        }
        )),
        i("destroy", ( () => {
            a && r.cancelAnimationFrame(a),
            s && s.unobserve && e.el && (s.unobserve(e.el),
            s = null),
            r.removeEventListener("resize", o),
            r.removeEventListener("orientationchange", l)
        }
        ))
    }
    , function(t) {
        let {swiper: e, extendParams: i, on: n, emit: r} = t;
        const s = []
          , a = yy()
          , o = function(t, i) {
            void 0 === i && (i = {});
            const n = new (a.MutationObserver || a.WebkitMutationObserver)((t => {
                if (e.__preventObserver__)
                    return;
                if (1 === t.length)
                    return void r("observerUpdate", t[0]);
                const i = function() {
                    r("observerUpdate", t[0])
                };
                a.requestAnimationFrame ? a.requestAnimationFrame(i) : a.setTimeout(i, 0)
            }
            ));
            n.observe(t, {
                attributes: void 0 === i.attributes || i.attributes,
                childList: void 0 === i.childList || i.childList,
                characterData: void 0 === i.characterData || i.characterData
            }),
            s.push(n)
        };
        i({
            observer: !1,
            observeParents: !1,
            observeSlideChildren: !1
        }),
        n("init", ( () => {
            if (e.params.observer) {
                if (e.params.observeParents) {
                    const t = function(t, e) {
                        const i = [];
                        let n = t.parentElement;
                        for (; n; )
                            e ? n.matches(e) && i.push(n) : i.push(n),
                            n = n.parentElement;
                        return i
                    }(e.hostEl);
                    for (let e = 0; e < t.length; e += 1)
                        o(t[e])
                }
                o(e.hostEl, {
                    childList: e.params.observeSlideChildren
                }),
                o(e.wrapperEl, {
                    attributes: !1
                })
            }
        }
        )),
        n("destroy", ( () => {
            s.forEach((t => {
                t.disconnect()
            }
            )),
            s.splice(0, s.length)
        }
        ))
    }
    ]);
    let ux, dx, px, fx = uo() ? null : new class {
        constructor({wrapper: t=window, content: e=document.documentElement, wheelEventsTarget: i=t, eventsTarget: n=i, smoothWheel: r=!0, syncTouch: s=!1, syncTouchLerp: a=.075, touchInertiaMultiplier: o=35, duration: l, easing: c=(t => Math.min(1, 1.001 - Math.pow(2, -10 * t))), lerp: h=!l && .1, infinite: u=!1, orientation: d="vertical", gestureOrientation: p="vertical", touchMultiplier: f=1, wheelMultiplier: m=1, autoResize: g=!0, __experimental__naiveDimensions: v=!1}={}) {
            this.__isSmooth = !1,
            this.__isScrolling = !1,
            this.__isStopped = !1,
            this.__isLocked = !1,
            this.onVirtualScroll = ({deltaX: t, deltaY: e, event: i}) => {
                if (i.ctrlKey)
                    return;
                const n = i.type.includes("touch")
                  , r = i.type.includes("wheel");
                if (this.options.syncTouch && n && "touchstart" === i.type && !this.isStopped && !this.isLocked)
                    return void this.reset();
                const s = 0 === t && 0 === e
                  , a = "vertical" === this.options.gestureOrientation && 0 === e || "horizontal" === this.options.gestureOrientation && 0 === t;
                if (s || a)
                    return;
                let o = i.composedPath();
                if (o = o.slice(0, o.indexOf(this.rootElement)),
                o.find((t => {
                    var e, i, s, a, o;
                    return (null === (e = t.hasAttribute) || void 0 === e ? void 0 : e.call(t, "data-lenis-prevent")) || n && (null === (i = t.hasAttribute) || void 0 === i ? void 0 : i.call(t, "data-lenis-prevent-touch")) || r && (null === (s = t.hasAttribute) || void 0 === s ? void 0 : s.call(t, "data-lenis-prevent-wheel")) || (null === (a = t.classList) || void 0 === a ? void 0 : a.contains("lenis")) && !(null === (o = t.classList) || void 0 === o ? void 0 : o.contains("lenis-stopped"))
                }
                )))
                    return;
                if (this.isStopped || this.isLocked)
                    return void i.preventDefault();
                if (this.isSmooth = this.options.syncTouch && n || this.options.smoothWheel && r,
                !this.isSmooth)
                    return this.isScrolling = !1,
                    void this.animate.stop();
                i.preventDefault();
                let l = e;
                "both" === this.options.gestureOrientation ? l = Math.abs(e) > Math.abs(t) ? e : t : "horizontal" === this.options.gestureOrientation && (l = t);
                const c = n && this.options.syncTouch
                  , h = n && "touchend" === i.type && Math.abs(l) > 5;
                h && (l = this.velocity * this.options.touchInertiaMultiplier),
                this.scrollTo(this.targetScroll + l, Object.assign({
                    programmatic: !1
                }, c ? {
                    lerp: h ? this.options.syncTouchLerp : 1
                } : {
                    lerp: this.options.lerp,
                    duration: this.options.duration,
                    easing: this.options.easing
                }))
            }
            ,
            this.onNativeScroll = () => {
                if (!this.__preventNextScrollEvent && !this.isScrolling) {
                    const t = this.animatedScroll;
                    this.animatedScroll = this.targetScroll = this.actualScroll,
                    this.velocity = 0,
                    this.direction = Math.sign(this.animatedScroll - t),
                    this.emit()
                }
            }
            ,
            window.lenisVersion = "1.0.42",
            t !== document.documentElement && t !== document.body || (t = window),
            this.options = {
                wrapper: t,
                content: e,
                wheelEventsTarget: i,
                eventsTarget: n,
                smoothWheel: r,
                syncTouch: s,
                syncTouchLerp: a,
                touchInertiaMultiplier: o,
                duration: l,
                easing: c,
                lerp: h,
                infinite: u,
                gestureOrientation: p,
                orientation: d,
                touchMultiplier: f,
                wheelMultiplier: m,
                autoResize: g,
                __experimental__naiveDimensions: v
            },
            this.animate = new fo,
            this.emitter = new go,
            this.dimensions = new mo({
                wrapper: t,
                content: e,
                autoResize: g
            }),
            this.toggleClassName("lenis", !0),
            this.velocity = 0,
            this.isLocked = !1,
            this.isStopped = !1,
            this.isSmooth = s || r,
            this.isScrolling = !1,
            this.targetScroll = this.animatedScroll = this.actualScroll,
            this.options.wrapper.addEventListener("scroll", this.onNativeScroll, !1),
            this.virtualScroll = new yo(n,{
                touchMultiplier: f,
                wheelMultiplier: m
            }),
            this.virtualScroll.on("scroll", this.onVirtualScroll)
        }
        destroy() {
            this.emitter.destroy(),
            this.options.wrapper.removeEventListener("scroll", this.onNativeScroll, !1),
            this.virtualScroll.destroy(),
            this.dimensions.destroy(),
            this.toggleClassName("lenis", !1),
            this.toggleClassName("lenis-smooth", !1),
            this.toggleClassName("lenis-scrolling", !1),
            this.toggleClassName("lenis-stopped", !1),
            this.toggleClassName("lenis-locked", !1)
        }
        on(t, e) {
            return this.emitter.on(t, e)
        }
        off(t, e) {
            return this.emitter.off(t, e)
        }
        setScroll(t) {
            this.isHorizontal ? this.rootElement.scrollLeft = t : this.rootElement.scrollTop = t
        }
        resize() {
            this.dimensions.resize()
        }
        emit() {
            this.emitter.emit("scroll", this)
        }
        reset() {
            this.isLocked = !1,
            this.isScrolling = !1,
            this.animatedScroll = this.targetScroll = this.actualScroll,
            this.velocity = 0,
            this.animate.stop()
        }
        start() {
            this.isStopped && (this.isStopped = !1,
            this.reset())
        }
        stop() {
            this.isStopped || (this.isStopped = !0,
            this.animate.stop(),
            this.reset())
        }
        raf(t) {
            const e = t - (this.time || t);
            this.time = t,
            this.animate.advance(.001 * e)
        }
        scrollTo(t, {offset: e=0, immediate: i=!1, lock: n=!1, duration: r=this.options.duration, easing: s=this.options.easing, lerp: a=!r && this.options.lerp, onComplete: o, force: l=!1, programmatic: c=!0}={}) {
            if (!this.isStopped && !this.isLocked || l) {
                if (["top", "left", "start"].includes(t))
                    t = 0;
                else if (["bottom", "right", "end"].includes(t))
                    t = this.limit;
                else {
                    let i;
                    if ("string" == typeof t ? i = document.querySelector(t) : (null == t ? void 0 : t.nodeType) && (i = t),
                    i) {
                        if (this.options.wrapper !== window) {
                            const t = this.options.wrapper.getBoundingClientRect();
                            e -= this.isHorizontal ? t.left : t.top
                        }
                        const n = i.getBoundingClientRect();
                        t = (this.isHorizontal ? n.left : n.top) + this.animatedScroll
                    }
                }
                if ("number" == typeof t) {
                    if (t += e,
                    t = Math.round(t),
                    this.options.infinite ? c && (this.targetScroll = this.animatedScroll = this.scroll) : t = po(0, t, this.limit),
                    i)
                        return this.animatedScroll = this.targetScroll = t,
                        this.setScroll(this.scroll),
                        this.reset(),
                        void (null == o || o(this));
                    if (!c) {
                        if (t === this.targetScroll)
                            return;
                        this.targetScroll = t
                    }
                    this.animate.fromTo(this.animatedScroll, t, {
                        duration: r,
                        easing: s,
                        lerp: a,
                        onStart: () => {
                            n && (this.isLocked = !0),
                            this.isScrolling = !0
                        }
                        ,
                        onUpdate: (t, e) => {
                            this.isScrolling = !0,
                            this.velocity = t - this.animatedScroll,
                            this.direction = Math.sign(this.velocity),
                            this.animatedScroll = t,
                            this.setScroll(this.scroll),
                            c && (this.targetScroll = t),
                            e || this.emit(),
                            e && (this.reset(),
                            this.emit(),
                            null == o || o(this),
                            this.__preventNextScrollEvent = !0,
                            requestAnimationFrame(( () => {
                                delete this.__preventNextScrollEvent
                            }
                            )))
                        }
                    })
                }
            }
        }
        get rootElement() {
            return this.options.wrapper === window ? document.documentElement : this.options.wrapper
        }
        get limit() {
            return this.options.__experimental__naiveDimensions ? this.isHorizontal ? this.rootElement.scrollWidth - this.rootElement.clientWidth : this.rootElement.scrollHeight - this.rootElement.clientHeight : this.dimensions.limit[this.isHorizontal ? "x" : "y"]
        }
        get isHorizontal() {
            return "horizontal" === this.options.orientation
        }
        get actualScroll() {
            return this.isHorizontal ? this.rootElement.scrollLeft : this.rootElement.scrollTop
        }
        get scroll() {
            return this.options.infinite ? (this.animatedScroll % (t = this.limit) + t) % t : this.animatedScroll;
            var t
        }
        get progress() {
            return 0 === this.limit ? 1 : this.scroll / this.limit
        }
        get isSmooth() {
            return this.__isSmooth
        }
        set isSmooth(t) {
            this.__isSmooth !== t && (this.__isSmooth = t,
            this.toggleClassName("lenis-smooth", t))
        }
        get isScrolling() {
            return this.__isScrolling
        }
        set isScrolling(t) {
            this.__isScrolling !== t && (this.__isScrolling = t,
            this.toggleClassName("lenis-scrolling", t))
        }
        get isStopped() {
            return this.__isStopped
        }
        set isStopped(t) {
            this.__isStopped !== t && (this.__isStopped = t,
            this.toggleClassName("lenis-stopped", t))
        }
        get isLocked() {
            return this.__isLocked
        }
        set isLocked(t) {
            this.__isLocked !== t && (this.__isLocked = t,
            this.toggleClassName("lenis-locked", t))
        }
        get className() {
            let t = "lenis";
            return this.isStopped && (t += " lenis-stopped"),
            this.isLocked && (t += " lenis-locked"),
            this.isScrolling && (t += " lenis-scrolling"),
            this.isSmooth && (t += " lenis-smooth"),
            t
        }
        toggleClassName(t, e) {
            this.rootElement.classList.toggle(t, e),
            this.emitter.emit("className change", this)
        }
    }
    ({
        lerp: .06
    });
    if (fx) {
        function Px(t) {
            fx.raf(t),
            requestAnimationFrame(Px)
        }
        fx.stop(),
        requestAnimationFrame(Px)
    }
    const mx = function() {
        if (0 !== document.querySelectorAll(".preload").length && document.querySelectorAll(".preload").forEach((t => {
            let e = new Image;
            e.src = t.getAttribute("src"),
            e.onload = () => {
                to.refresh()
            }
        }
        )),
        0 !== document.querySelectorAll("video").length && document.querySelectorAll("video").forEach((t => {
            t.onloadeddata = function() {
                to.refresh()
            }
        }
        )),
        document.getElementById("footer2").addEventListener("mouseenter", ( () => {
            window.webgl.killRaf(),
            window.webgl.raf(),
            Xn.killTweensOf("#webgl canvas"),
            Xn.to("#webgl canvas", {
                duration: 1,
                opacity: .75
            })
        }
        )),
        document.getElementById("footer2").addEventListener("mouseleave", ( () => {
            Xn.to("#webgl canvas", {
                duration: 1,
                opacity: 0,
                onComplete: () => {
                    window.webgl.killRaf()
                }
            })
        }
        )),
        document.getElementById("webgl").classList.remove("cache"),
        document.body.classList.contains("single") || document.body.classList.contains("p404") || to.create({
            trigger: ".toContact",
            start: "top bottom",
            onToggle: t => {
                t.isActive ? document.querySelector(".toContact").classList.add("actif") : document.querySelector(".toContact").classList.remove("actif")
            }
        }),
        null !== document.querySelector("#main .h1 span") && Xn.to("#main .h1 span", {
            opacity: 1,
            y: "0%",
            stagger: .1,
            delay: .2,
            ease: "power2.out",
            duration: 1
        }),
        document.querySelectorAll("#main .h2").forEach((t => {
            to.create({
                trigger: t,
                start: "top 100%",
                onEnter: () => {
                    Xn.to(t.querySelectorAll("span"), {
                        opacity: 1,
                        y: "0%",
                        stagger: .1,
                        ease: "power2.out",
                        duration: 1
                    })
                }
                ,
                onLeaveBack: () => {
                    Xn.killTweensOf(t.querySelectorAll("span")),
                    Xn.set(t.querySelectorAll("span"), {
                        opacity: 0,
                        y: "40%"
                    })
                }
            })
        }
        )),
        document.body.classList.contains("home") ? window.webgl.fondHome() : window.webgl.fondAutreQueHome(),
        document.body.classList.contains("home"))
            window.items = [],
            document.querySelectorAll(".mediaHov").forEach((t => {
                const e = t.querySelector(".media");
                let i = Xn.quickTo(e, "x", {
                    duration: .6,
                    ease: "power1"
                })
                  , n = Xn.quickTo(e, "y", {
                    duration: .6,
                    ease: "power1"
                });
                t.addEventListener("mouseenter", ( () => {
                    t.classList.add("actif")
                }
                )),
                t.addEventListener("mouseleave", ( () => {
                    t.classList.remove("actif"),
                    i(0),
                    n(0)
                }
                )),
                window.items.push({
                    el: t,
                    xTo: i,
                    yTo: n
                })
            }
            )),
            window.addEventListener("mousemove", window.mMove),
            Xn.to(".cStag", {
                opacity: 1,
                y: 0,
                ease: "power3.out",
                duration: 1,
                stagger: .07,
                delay: 1.3
            });
        else if (document.body.classList.contains("about")) {
            window.webglAbout = new dy,
            window.webglAbout.initJoin(),
            Xn.to(".innerCarte", {
                y: 0,
                stagger: .1,
                ease: "power4.out",
                duration: 2
            });
            let t = ".carteDesk";
            window.innerWidth < 768 && (t = ".carteMob"),
            Xn.to(t, {
                scrollTrigger: {
                    trigger: ".puzzle",
                    start: "top top",
                    end: "bottom top",
                    scrub: !0
                },
                x: 0,
                y: 0,
                ease: "none"
            }),
            to.create({
                trigger: ".innerPuzzle",
                start: "top top",
                end: "bottom bottom",
                pin: ".bloqueCarte"
            }),
            to.create({
                trigger: ".innerCan",
                start: "top bottom",
                end: "bottom top",
                onUpdate: () => {
                    null != window.webglAbout.materialP && (window.webglAbout.materialP.uniforms.uTranslate.value = window.scrollY / 100,
                    window.webglAbout.renderPost(window.webglAbout.sceneJ, window.webglAbout.cameraJ))
                }
            }),
            document.querySelectorAll(".layer").forEach((t => {
                Xn.to(t, {
                    scaleY: 0,
                    duration: 1.2,
                    ease: "power4.inOut",
                    scrollTrigger: {
                        trigger: t,
                        start: "top bottom"
                    }
                })
            }
            )),
            document.querySelectorAll(".trait").forEach((t => {
                Xn.to(t, {
                    scaleX: 1,
                    duration: .8,
                    ease: "power4.inOut",
                    scrollTrigger: {
                        trigger: t.parentNode,
                        start: "top bottom",
                        end: "bottom top",
                        toggleActions: "play reverse play reverse"
                    }
                })
            }
            )),
            window.innerWidth > 767 && new hx(".swiper-about",{
                slidesPerView: 3,
                spaceBetween: .016 * window.innerWidth,
                mousewheel: {
                    forceToAxis: !0
                }
            }),
            document.querySelector(".formNewsletter").addEventListener("submit", (t => {
                t.preventDefault();
                const e = {
                    email: document.querySelector(".email").value,
                    groups: ["90943656708540050"]
                };
                fetch("https://connect.mailerlite.com/api/subscribers", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        Accept: "application/json",
                        Authorization: "Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJhdWQiOiI0IiwianRpIjoiMGIxNTc3ZDhlNDRlYzM0YjQ2NzM1YmI1Y2JiNmZkOWQ3Yjk5NDU5OTc2NjFiZWE2ZDdhZDljNTUzMDk3ODQ0NWMwMzcyNGRhMDA2YTcwNDIiLCJpYXQiOjE2ODcxODE3ODQuNjc3NzUyLCJuYmYiOjE2ODcxODE3ODQuNjc3NzU3LCJleHAiOjQ4NDI4NTUzODQuNjcxMjM3LCJzdWIiOiI0OTM3MDYiLCJzY29wZXMiOltdfQ.YoKv0auMFULj0Dwdsc6VZ2MeXAuBwJx6MFKIl0oPApt90tPSzIk1JRvehTRUh8pkyAhzLf7v6qm2CXpv-rGT8S64p8J6CiqtvVOvbi_0_yl2WWltxEAZI9iGq_YPZ2dgb0RhFiXRBgpEwsPYATod-Vl2EGH32jS_SewQULWuMJxsF_7NT3pYUy4bz4QVgmUokUQKErV7zcI2pfT3BAl9M0ukzhSIZZGgcDNKgtdSvVJt5ZhHuAkRWdvVuqRvCxWY-b5wbDc_YGygmIRj3zpLBGoMG7AIDG-0PHb_R7TbQwQDhqPtAm9vD0dKkJEgVExiV0_Jx5xffJ4tS1ejl4dxkZUx1H8Wtn3_YDGE_-6L5jLpKIfnby90k_D9W1Ev79975FWyRN1gBQeZoloHFeCGv143P3-lm8sBPeUHMYzXIfEpisG3r9LWxsj9nKQVI0RRN5it0Q_lxiBB0rPm0T3nc4T-YJyZk162keb9KVvdAlJUGbL1xvwvo4kVA8xoK0422yc5ZoXpk8iQtIJDZfPwTQcYIPCgHjF3vD0kyZMWgqjm0fGJnDolG95Q9iQpQOLFMyzJd5S4-5jTj_-kgRVbDZHJVX_7AntC8gc2bXyqkqMFkrZreU6bb12CMZ4ioxvnki2yRTXFVZNFDANCj0GlQ03SpEIaNf9UWqxZHtQQdsc"
                    },
                    body: JSON.stringify(e)
                }).then((t => t.json())).then((t => {
                    document.querySelector(".email").value = "",
                    document.querySelector(".email").setAttribute("placeholder", "Thank you")
                }
                )).catch((t => {
                    console.error(t)
                }
                ))
            }
            ))
        } else if (document.body.classList.contains("newsletter-page"))
            document.querySelector(".formNewsletter").addEventListener("submit", (t => {
                t.preventDefault();
                const e = {
                    email: document.querySelector(".email").value,
                    groups: ["90943656708540050"]
                };
                fetch("https://connect.mailerlite.com/api/subscribers", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        Accept: "application/json",
                        Authorization: "Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJhdWQiOiI0IiwianRpIjoiMGIxNTc3ZDhlNDRlYzM0YjQ2NzM1YmI1Y2JiNmZkOWQ3Yjk5NDU5OTc2NjFiZWE2ZDdhZDljNTUzMDk3ODQ0NWMwMzcyNGRhMDA2YTcwNDIiLCJpYXQiOjE2ODcxODE3ODQuNjc3NzUyLCJuYmYiOjE2ODcxODE3ODQuNjc3NzU3LCJleHAiOjQ4NDI4NTUzODQuNjcxMjM3LCJzdWIiOiI0OTM3MDYiLCJzY29wZXMiOltdfQ.YoKv0auMFULj0Dwdsc6VZ2MeXAuBwJx6MFKIl0oPApt90tPSzIk1JRvehTRUh8pkyAhzLf7v6qm2CXpv-rGT8S64p8J6CiqtvVOvbi_0_yl2WWltxEAZI9iGq_YPZ2dgb0RhFiXRBgpEwsPYATod-Vl2EGH32jS_SewQULWuMJxsF_7NT3pYUy4bz4QVgmUokUQKErV7zcI2pfT3BAl9M0ukzhSIZZGgcDNKgtdSvVJt5ZhHuAkRWdvVuqRvCxWY-b5wbDc_YGygmIRj3zpLBGoMG7AIDG-0PHb_R7TbQwQDhqPtAm9vD0dKkJEgVExiV0_Jx5xffJ4tS1ejl4dxkZUx1H8Wtn3_YDGE_-6L5jLpKIfnby90k_D9W1Ev79975FWyRN1gBQeZoloHFeCGv143P3-lm8sBPeUHMYzXIfEpisG3r9LWxsj9nKQVI0RRN5it0Q_lxiBB0rPm0T3nc4T-YJyZk162keb9KVvdAlJUGbL1xvwvo4kVA8xoK0422yc5ZoXpk8iQtIJDZfPwTQcYIPCgHjF3vD0kyZMWgqjm0fGJnDolG95Q9iQpQOLFMyzJd5S4-5jTj_-kgRVbDZHJVX_7AntC8gc2bXyqkqMFkrZreU6bb12CMZ4ioxvnki2yRTXFVZNFDANCj0GlQ03SpEIaNf9UWqxZHtQQdsc"
                    },
                    body: JSON.stringify(e)
                }).then((t => t.json())).then((t => {
                    document.querySelector(".email").value = "",
                    document.querySelector(".email").setAttribute("placeholder", "Thank you")
                }
                )).catch((t => {
                    console.error(t)
                }
                ))
            }
            ));
        else if (document.body.classList.contains("single")) {
            cancelAnimationFrame(window.leRaf),
            document.getElementById("garciScroll").classList.contains("evolt") ? Xn.to(".trans", {
                scrollTrigger: {
                    trigger: ".fiveCards",
                    start: "top bottom",
                    end: "bottom top",
                    scrub: !0
                },
                y: "0%",
                ease: "none"
            }) : document.getElementById("garciScroll").classList.contains("kard") ? Xn.to(".content .fond svg", {
                scrollTrigger: {
                    trigger: ".fond",
                    start: "top bottom",
                    end: "bottom top",
                    scrub: !0
                },
                scale: .8,
                ease: "none"
            }) : document.getElementById("garciScroll").classList.contains("nabla") ? window.innerWidth > 767 && (Xn.to(".content .paraS2", {
                scrollTrigger: {
                    trigger: ".duo",
                    start: "top bottom",
                    end: "bottom top",
                    scrub: !0
                },
                y: "-10%",
                ease: "none"
            }),
            Xn.to(".content .paraS", {
                scrollTrigger: {
                    trigger: ".duo",
                    start: "top bottom",
                    end: "bottom top",
                    scrub: !0
                },
                y: "-15%",
                ease: "none"
            })) : document.getElementById("garciScroll").classList.contains("spendesk") ? (Xn.to(".t1", {
                scrollTrigger: {
                    trigger: ".content .fond",
                    start: "top bottom",
                    end: "bottom top",
                    scrub: !0
                },
                y: "-10%",
                ease: "none"
            }),
            Xn.to(".t2", {
                scrollTrigger: {
                    trigger: ".content .fond",
                    start: "top bottom",
                    end: "bottom top",
                    scrub: !0
                },
                y: "-20%",
                ease: "none"
            }),
            Xn.to(".t3", {
                scrollTrigger: {
                    trigger: ".content .fond",
                    start: "top bottom",
                    end: "bottom top",
                    scrub: !0
                },
                y: "-5%",
                ease: "none"
            })) : document.getElementById("garciScroll").classList.contains("shift") && window.innerWidth > 767 && (Xn.to(".content .paraS2", {
                scrollTrigger: {
                    trigger: ".duo",
                    start: "top bottom",
                    end: "bottom top",
                    scrub: !0
                },
                y: "-10%",
                ease: "none"
            }),
            Xn.to(".content .paraS", {
                scrollTrigger: {
                    trigger: ".duo",
                    start: "top bottom",
                    end: "bottom top",
                    scrub: !0
                },
                y: "-15%",
                ease: "none"
            })),
            document.body.classList.contains("fromFiche") || (Xn.to("#garciScroll h1 .haut", {
                duration: 1,
                y: "-100%",
                ease: "power4.inOut"
            }),
            Xn.to("#garciScroll h1 .bas", {
                duration: 1,
                y: "0%",
                ease: "power4.inOut"
            })),
            document.body.classList.remove(".fromFiche");
            const i = document.querySelector(".content");
            ux = new ResizeObserver(( (t, e) => {
                t.forEach((t => {
                    window.innerWidth > 767 ? (dx && dx.kill(),
                    dx = to.create({
                        trigger: "#main",
                        start: "bottom bottom+=" + .6 * window.innerHeight,
                        end: "bottom bottom",
                        onEnter: () => {
                            document.getElementById("projets").classList.add("actifFooter"),
                            window.raf()
                        }
                        ,
                        onLeaveBack: () => {
                            cancelAnimationFrame(window.leRaf),
                            document.getElementById("projets").classList.remove("actifFooter")
                        }
                    }),
                    px && px.kill(),
                    px = Xn.timeline(),
                    px.fromTo("#projets", {
                        y: "100%"
                    }, {
                        scrollTrigger: {
                            id: "projetsY",
                            trigger: "#main",
                            start: "bottom bottom+=" + .6 * window.innerHeight,
                            end: "bottom bottom",
                            scrub: !0
                        },
                        y: "30%",
                        ease: "none"
                    }, 0),
                    px.fromTo(".innerExp", {
                        scale: 1,
                        perspectiveOrigin: "50% 10%"
                    }, {
                        scrollTrigger: {
                            id: "innerExpScale",
                            trigger: "#main",
                            start: "bottom bottom+=" + .6 * window.innerHeight,
                            end: "bottom bottom",
                            scrub: !0
                        },
                        perspectiveOrigin: "50% -65%",
                        y: .045 * window.innerHeight + "px",
                        scale: .658,
                        ease: "none"
                    }, 0),
                    to.refresh()) : (dx && dx.kill(),
                    dx = to.create({
                        trigger: ".content",
                        start: "bottom 200%",
                        end: "bottom 40%",
                        onEnter: () => {
                            document.getElementById("projets").classList.add("actifFooter"),
                            window.raf(),
                            document.getElementById("projets").style.top = document.getElementById("main").offsetHeight - 400 + "px"
                        }
                        ,
                        onLeaveBack: () => {
                            cancelAnimationFrame(window.leRaf),
                            document.getElementById("projets").classList.remove("actifFooter"),
                            document.getElementById("projets").style.top = "0px"
                        }
                    }),
                    to.refresh())
                }
                ))
            }
            )),
            ux.observe(i);
            let n, r = document.querySelector(".liste button.current");
            n = null != r.nextElementSibling ? r.nextElementSibling : document.querySelectorAll(".liste button")[0],
            t = n,
            e = new MouseEvent("click",{
                bubbles: !0,
                cancelable: !0,
                view: window
            }),
            t.dispatchEvent(e),
            window.changementSlideSet(document.querySelector(".fiche.current"), -1),
            raf(),
            document.getElementById("projets").classList.add("fake"),
            Xn.delayedCall(.6, ( () => {
                cancelAnimationFrame(leRaf),
                document.getElementById("projets").classList.remove("fake")
            }
            ))
        } else
            document.body.classList.contains("join") ? (window.webglJoin = new dy,
            window.webglJoin.initJoin(),
            to.create({
                trigger: ".innerCan",
                start: "top bottom",
                end: "bottom top",
                onUpdate: () => {
                    null != window.webglJoin.materialP && (window.webglJoin.materialP.uniforms.uTranslate.value = window.scrollY / 100,
                    window.webglJoin.renderPost(window.webglJoin.sceneJ, window.webglJoin.cameraJ))
                }
            })) : document.body.classList.contains("p404") && (fx.stop(),
            window.webgl404 = new dy,
            window.webgl404.init404(),
            uo() ? window.webgl404.touchmove() : window.webgl404.wheel());
        var t, e;
        null !== document.querySelector(".selected") && to.create({
            trigger: ".selected",
            start: "top 80%",
            onEnter: () => {
                Xn.killTweensOf(".logos svg"),
                Xn.to(".logos svg", {
                    opacity: 1,
                    duration: .5,
                    stagger: .08,
                    ease: "power4.out"
                })
            }
            ,
            onLeaveBack: () => {
                Xn.killTweensOf(".logos svg"),
                Xn.set(".logos svg", {
                    opacity: 0
                })
            }
        })
    };
    window.homeVideosDesktopToMobile = function() {
        let t = document.getElementById("vid1");
        t.classList.add("vidMob"),
        document.querySelector(".vid1Mob").appendChild(t);
        let e = document.getElementById("vid2");
        e.classList.add("vidMob"),
        document.querySelector(".vid2Mob").appendChild(e);
        let i = document.getElementById("vid3");
        i.classList.add("vidMob"),
        document.querySelector(".vid3Mob").appendChild(i)
    }
    ,
    window.mMove = function(t) {
        window.items.forEach((e => {
            e.el.classList.contains("actif") && (e.xTo(Xn.utils.mapRange(0, e.el.clientWidth, -20, 20, t.clientX - e.el.getBoundingClientRect().left)),
            e.yTo(Xn.utils.mapRange(0, e.el.clientHeight, -20, 20, t.clientY - e.el.getBoundingClientRect().top)))
        }
        ))
    }
    ;
    let gx, vx, yx = 0, xx = 0, _x = !1, wx = !1, bx = {}, Mx = {}, Sx = 0, Tx = !1;
    bx.x = 0,
    bx.y = 0,
    Mx.x = 0,
    Mx.y = 0,
    window.velocity = 0,
    Xn.registerPlugin(to);
    const Ex = new class {
        constructor(t) {
            this.currentStep = 0,
            this.allSteps = 2,
            this.newClass,
            this.newTitle,
            this.newDOM,
            this.animEnCours = !0
        }
        start(t) {
            this.animEnCours = !0,
            this.animationSortie(),
            this.changementDOM(t)
        }
        animationSortie() {
            if (window.webgl.killRaf(),
            null != window.webgl404 && (uo() ? window.webgl404.untouchmove() : window.webgl404.unwheel(),
            window.webgl404.killRaf404()),
            document.getElementById("projets").classList.contains("actif") || document.getElementById("projets").classList.contains("actifFooter")) {
                if (document.getElementById("explore").classList.remove("actif"),
                null !== fx && fx.stop(),
                document.getElementById("projets").classList.contains("actifFooter") && (document.querySelector(".fiche.current .actif").classList.remove("actif"),
                null != to.getById("projetsY") && (to.getById("projetsY").kill(!1),
                to.getById("innerExpScale").kill(!1)),
                Xn.to(".content", {
                    y: -window.innerHeight / 2 + "px",
                    opacity: 0,
                    ease: "power4.inOut",
                    duration: .8
                }),
                Xn.to("#projets", {
                    duration: .8,
                    y: "0%",
                    ease: "power4.inOut"
                }),
                window.innerWidth < 768)) {
                    document.getElementById("projets").style.overflow = "visible";
                    let t = document.getElementById("main").offsetHeight - window.innerHeight - window.scrollY;
                    Xn.to(".nextP, .toNext", {
                        opacity: 0,
                        duration: 1
                    }),
                    Xn.to("#projets", {
                        duration: 1.6,
                        y: 400 - window.innerHeight - t + "px",
                        ease: "power4.inOut"
                    })
                }
                Xn.to(".innerExp", {
                    duration: .6,
                    perspectiveOrigin: "50% 50%",
                    ease: "power4.inOut",
                    onComplete: function() {
                        Xn.to(".fiche", {
                            duration: .8,
                            rotationY: "0deg",
                            rotationX: "0deg",
                            z: "0px",
                            ease: "power4.inOut"
                        })
                    }
                }),
                Xn.to(".liste, .innerBtn, .innerC", {
                    duration: .4,
                    opacity: 0
                }),
                Xn.to(".innerExp", {
                    duration: 1.3,
                    delay: .4,
                    ease: "power4.inOut",
                    y: "0%",
                    scale: 1,
                    onComplete: () => {
                        null !== fx && fx.stop(),
                        this.incrementStep(),
                        cancelAnimationFrame(window.leRafPush),
                        Xn.set(".liste, .innerBtn, .innerC", {
                            clearProps: "all"
                        }),
                        this.killAll()
                    }
                }),
                Xn.to(".current .h1Single .haut", {
                    duration: 1.3,
                    y: "-100%",
                    delay: .4,
                    ease: "power4.inOut"
                }),
                Xn.to(".current .h1Single .bas", {
                    duration: 1.3,
                    y: "0%",
                    delay: .4,
                    ease: "power4.inOut",
                    onComplete: () => {
                        Xn.set(".current .h1Single .haut", {
                            y: "0%"
                        }),
                        Xn.set(".current .h1Single .bas", {
                            y: "100%"
                        })
                    }
                })
            } else
                Xn.to("#main", {
                    opacity: 0,
                    onComplete: () => {
                        null !== fx && fx.stop(),
                        this.incrementStep(),
                        cancelAnimationFrame(window.leRafPush),
                        this.killAll()
                    }
                });
            document.body.classList.contains("home") && window.removeEventListener("mousemove", window.mMove),
            document.body.classList.contains("single") && (void 0 !== ux && ux.disconnect(),
            dx && dx.kill(),
            px && px.kill())
        }
        killAll() {
            to.getAll().forEach((t => {
                t.kill()
            }
            ))
        }
        changementDOM(t) {
            this.ajaxPromise(t).then((t => {
                let e = (new DOMParser).parseFromString(t, "text/html");
                e.body.getAttribute("class"),
                this.newTitle = e.querySelector("title").innerHTML,
                this.newClass = e.body.getAttribute("class"),
                this.newDOM = e.getElementById("main").innerHTML,
                this.incrementStep()
            }
            ))
        }
        animationEntree(t, e, i) {
            window.scrollTo(0, 0),
            this.currentStep = 0,
            this.uneFois = !0,
            document.title = this.newTitle,
            document.body.setAttribute("class", this.newClass),
            document.getElementById("main").innerHTML = this.newDOM,
            document.body.classList.contains("single") ? (Xn.to("header, .premierTexte", {
                opacity: 1
            }),
            document.querySelectorAll("#projets .fiche").forEach((t => {
                t.setAttribute("href", t.getAttribute("data-url"))
            }
            )),
            document.querySelector(".lienHome").setAttribute("href", "../"),
            document.querySelector(".toAbout").setAttribute("href", "../about"),
            document.querySelector(".toJoin").setAttribute("href", "../join-the-club")) : document.querySelectorAll("#projets .fiche").forEach((t => {
                t.setAttribute("href", t.getAttribute("data-url-basic"))
            }
            )),
            (document.getElementById("projets").classList.contains("actif") || document.getElementById("projets").classList.contains("actifFooter")) && (Xn.set("#main", {
                opacity: 1
            }),
            document.getElementById("projets").classList.remove("actif", "actifFooter"),
            window.innerWidth < 768 && (Xn.set("#projets", {
                y: "0px"
            }),
            Xn.set(".nextP, .toNext", {
                clearProps: "all"
            }),
            document.getElementById("projets").style.overflow = "hidden"),
            document.body.classList.add("fromFiche")),
            null !== fx && fx.scrollTo(0, {
                immediate: !0
            }),
            Xn.to("#main", {
                opacity: 1,
                duration: .4,
                onComplete: () => {
                    null !== fx && fx.start(),
                    this.animEnCours = !1,
                    mx()
                }
            })
        }
        incrementStep() {
            this.currentStep++,
            this.currentStep == this.allSteps && this.animationEntree()
        }
        ajaxPromise(t) {
            return new Promise((e => {
                const i = new XMLHttpRequest;
                i.open("GET", t),
                i.onload = () => e(i.responseText),
                i.send()
            }
            ))
        }
    }
    ;
    function Lx(t) {
        var e = window.getComputedStyle(t);
        return new WebKitCSSMatrix(e.webkitTransform).m43
    }
    function Ax(t) {
        _x || (_x = !0,
        vx = parseInt(20 - t * Lx(document.querySelectorAll(".fiche")[ho(document.querySelector(".liste .current"))])),
        document.querySelectorAll(".fiche").forEach((e => {
            let i = parseInt(e.getAttribute("data-z"));
            e.setAttribute("data-z", i + t * vx)
        }
        )),
        setTimeout((function() {
            _x = !1
        }
        ), 550))
    }
    window.addEventListener("resize", ( () => {
        document.body.classList.contains("home"),
        Tx != uo() && document.location.reload()
    }
    )),
    window.addEventListener("popstate", (t => {
        Ex.start(location.href)
    }
    ), !1),
    window.addEventListener("DOMContentLoaded", ( () => {
        window.scrollTo(0, 0),
        Tx = uo(),
        window.webgl = new dy(bx),
        window.webgl.init(),
        Sx = document.querySelectorAll(".fiche").length,
        document.querySelectorAll(".fiche").forEach((t => {
            t.addEventListener("mouseenter", ( () => {
                document.getElementById("explore").classList.add("actif"),
                document.getElementById("projets").classList.contains("actifFooter") && document.querySelector(".current .toNext").classList.add("actif")
            }
            )),
            t.addEventListener("mouseleave", ( () => {
                document.getElementById("explore").classList.remove("actif"),
                document.querySelector(".current .toNext").classList.remove("actif")
            }
            ))
        }
        )),
        document.querySelectorAll(".aimant").forEach((t => {
            t.addEventListener("mouseenter", ( () => {
                t.classList.add("actif")
            }
            )),
            t.addEventListener("mouseleave", ( () => {
                t.classList.remove("actif"),
                Xn.to(t.querySelector(".suit"), {
                    x: "0px",
                    y: "0px",
                    duration: .2,
                    ease: "power2.inOut"
                })
            }
            ))
        }
        )),
        document.addEventListener("click", (function(t) {
            if (t.target.closest(".lien"))
                t.preventDefault(),
                Ex.animEnCours || (Ex.start(t.target.closest(".lien").getAttribute("href")),
                history.pushState({}, "", t.target.closest(".lien").getAttribute("href")),
                t.target.closest(".lien").classList.contains("fiche") && cancelAnimationFrame(leRaf));
            else if (t.target.closest(".next"))
                Ax(1);
            else if (t.target.closest(".prev"))
                Ax(-1);
            else if (t.target.closest(".liste button") && !_x) {
                _x = !0;
                const e = t.target.closest(".liste button")
                  , i = Math.round(document.querySelectorAll(".liste button").length / 2)
                  , n = Math.abs(ho(document.querySelector(".liste .current")) - ho(e));
                let r = 0;
                r = ho(e) < ho(document.querySelector(".liste .current")) ? n >= i ? document.querySelectorAll(".liste button").length - Math.abs(ho(e) - ho(document.querySelector(".liste .current"))) : ho(e) - ho(document.querySelector(".liste .current")) : n >= i ? -(document.querySelectorAll(".liste button").length - Math.abs(ho(e) - ho(document.querySelector(".liste .current")))) : ho(e) - ho(document.querySelector(".liste .current")),
                vx = parseInt(20 - Lx(document.querySelectorAll(".fiche")[ho(document.querySelector(".liste .current"))])),
                document.querySelectorAll(".fiche").forEach((t => {
                    let e = parseInt(t.getAttribute("data-z"));
                    t.setAttribute("data-z", e + vx * r)
                }
                )),
                setTimeout(( () => {
                    _x = !1
                }
                ), 550)
            } else if (t.target.closest(".toMenu") && !_x) {
                _x = !0,
                document.querySelector(".toClose").style.display = "block",
                null !== document.querySelector("#garciScroll .hero") && Xn.to("#garciScroll .hero", {
                    height: window.innerHeight + "px",
                    ease: "power4.inOut",
                    duration: 1.4
                }),
                Xn.to(".viewport", {
                    opacity: 0,
                    ease: "power4.inOut",
                    duration: 1.4,
                    onComplete: () => {
                        _x = !1,
                        document.querySelector(".toMenu").style.display = "none"
                    }
                }),
                Xn.to(".toMenu", {
                    duration: 1.4,
                    ease: "power4.inOut",
                    y: "100%",
                    opacity: 0
                }),
                Xn.to(".toClose", {
                    duration: 1.4,
                    ease: "power4.inOut",
                    y: "0%",
                    opacity: 1
                }),
                Xn.delayedCall(1, ( () => {
                    Xn.to("nav", {
                        opacity: 1,
                        duration: 1,
                        ease: "power4.out"
                    })
                }
                ));
                const t = {};
                t.currentY = window.scrollY,
                Xn.to(t, {
                    currentY: 0,
                    onUpdate: () => {
                        window.scrollTo(0, t.currentY)
                    }
                    ,
                    duration: 1.4,
                    ease: "power4.inOut"
                }),
                document.body.classList.add("bloque"),
                document.querySelector("nav").classList.add("actif")
            } else
                t.target.closest(".toClose") && !_x ? (_x = !0,
                document.querySelector(".toMenu").style.display = "block",
                null !== document.querySelector("#garciScroll .hero") && Xn.to("#garciScroll .hero", {
                    height: "500px",
                    ease: "power4.inOut",
                    duration: 1.4
                }),
                Xn.to(".viewport", {
                    opacity: 1,
                    ease: "power4.inOut",
                    duration: 1.4,
                    onComplete: () => {
                        _x = !1,
                        document.querySelector("nav").classList.remove("actif"),
                        document.querySelector(".toClose").style.display = "none"
                    }
                }),
                Xn.to(".toMenu", {
                    duration: 1.4,
                    ease: "power4.inOut",
                    y: "0%",
                    opacity: 1
                }),
                Xn.to(".toClose", {
                    duration: 1.4,
                    ease: "power4.inOut",
                    y: "-100%",
                    opacity: 0
                }),
                Xn.to("nav", {
                    opacity: 0,
                    duration: 1,
                    ease: "power4.out"
                }),
                document.body.classList.remove("bloque")) : t.target.closest(".toProjets") && !wx ? (wx = !0,
                Xn.set(".fiche", {
                    z: "0px"
                }),
                document.querySelectorAll(".fiche.cache").forEach((t => {
                    t.classList.add("off")
                }
                )),
                Xn.delayedCall(1.2, ( () => {
                    document.querySelectorAll(".fiche.off").forEach((t => {
                        t.classList.remove("off")
                    }
                    ))
                }
                )),
                Xn.to("#main", {
                    opacity: 0,
                    onComplete: () => {
                        wx = !1,
                        null !== fx && fx.stop(),
                        document.getElementById("projets").setAttribute("style", ""),
                        document.getElementById("projets").classList.add("actif"),
                        window.innerWidth > 767 ? Xn.fromTo(".innerExp", {
                            perspectiveOrigin: "50% 50%",
                            scale: .6,
                            y: .045 * window.innerHeight
                        }, {
                            duration: .7,
                            scale: .658,
                            ease: "back.out"
                        }) : Xn.fromTo(".innerExp", {
                            perspectiveOrigin: "50% 50%",
                            scale: .6,
                            y: .16 * window.innerHeight
                        }, {
                            duration: .7,
                            scale: .75,
                            ease: "back.out"
                        }),
                        Xn.to("#projets", {
                            opacity: 1
                        }),
                        raf()
                    }
                })) : t.target.closest(".innerC") && Xn.to("#projets", {
                    opacity: 0,
                    onComplete: () => {
                        to.refresh(),
                        document.getElementById("projets").classList.remove("actif"),
                        Xn.to("#main", {
                            opacity: 1
                        }),
                        cancelAnimationFrame(leRaf),
                        null !== fx && fx.start()
                    }
                })
        }
        )),
        window.addEventListener("wheel", (function(t) {
            document.querySelector(".fiche.off") || (t.detlaY < -280 || t.detlaY > 280 ? t.detlaY < -280 ? yx = -280 / 120 : t.detlaY > 280 && (yx = 280 / 120) : yx = t.deltaY / 120),
            window.clearTimeout(gx),
            gx = setTimeout((t => {
                yx = 0
            }
            ), 66)
        }
        ), {
            passive: !0
        });
        let t = 0
          , e = 0
          , i = !0;
        window.addEventListener("touchmove", (n => {
            document.getElementById("projets").classList.contains("actifFooter") || (e = n.touches[0].clientY - t,
            !i && document.getElementById("projets").classList.contains("actif") && (yx = e / 6),
            i = !1,
            t = n.touches[0].clientY,
            window.clearTimeout(gx),
            gx = setTimeout((n => {
                yx = 0,
                e = 0,
                t = 0,
                i = !0
            }
            ), 66))
        }
        ), {
            passive: !0
        }),
        Ex.start(window.location.href),
        window.addEventListener("mousemove", (t => {
            bx.x = t.x,
            bx.y = t.y
        }
        ), {
            passive: !0
        })
    }
    )),
    window.raf = function() {
        window.leRaf = requestAnimationFrame(raf),
        document.getElementById("projets").classList.contains("actif") && (xx += yx),
        document.querySelectorAll(".fiche").forEach((t => {
            Xn.to(t, {
                duration: .3,
                ease: "none",
                z: -t.getAttribute("data-nb") * Sx * 20 + parseInt(t.getAttribute("data-z")) + parseInt(xx) + "px"
            }),
            Lx(t) > 10 && !t.classList.contains("desc") ? changementSlide(120, 10, t, -1) : Lx(t) < -(20 * Sx - 10) && !t.classList.contains("desc") && changementSlide(10, 120, t, 1),
            t.classList.contains("cache") && Lx(t) > -150 && remonter(t, 10),
            !t.classList.contains("cache") && Lx(t) < -150 && !t.classList.contains("encours") && descendre(t)
        }
        )),
        document.getElementById("projets").classList.contains("actif") && (Tx ? Xn.to(".innerExp", {
            duration: .2,
            perspectiveOrigin: "50% " + (20 * -(bx.y / window.innerHeight - .5) - 65) + "%",
            ease: "none"
        }) : (Xn.to(".fiche", {
            duration: .2,
            rotationY: (bx.x / window.innerWidth - .5) / 2 + "deg",
            rotationX: -(bx.y / window.innerHeight - .5) / 2 - yx / 5 * 1.5 + "deg",
            ease: "none"
        }),
        Xn.to(".innerExp", {
            duration: .2,
            perspectiveOrigin: 20 * -(bx.x / window.innerWidth - .5) + 50 + "% " + (20 * -(bx.y / window.innerHeight - .5) - 65) + "%",
            ease: "none"
        }))),
        Xn.to("#explore", {
            x: bx.x + "px",
            y: bx.y + "px",
            duration: .4,
            ease: "none"
        }),
        Xn.to(".iEx div", {
            x: 1.6 * (Mx.x - bx.x) + "px",
            y: 1.6 * (Mx.y - bx.y) + "px",
            duration: .3,
            ease: "none"
        }),
        Mx.x = bx.x,
        Mx.y = bx.y,
        null != document.querySelector(".aimant.actif") && Xn.to(".aimant.actif .suit", {
            x: (bx.x - document.querySelector(".aimant.actif").getBoundingClientRect().left - document.querySelector(".aimant.actif").offsetHeight / 2) / 1.5 + "px",
            y: (bx.y - document.querySelector(".aimant.actif").getBoundingClientRect().top - document.querySelector(".aimant.actif").offsetWidth / 2) / 1.5 + "px",
            duration: .2,
            ease: "none"
        })
    }
    ,
    window.rafPush = function() {
        window.leRafPush = requestAnimationFrame(rafPush),
        Xn.to(".push.actif img", {
            rotationY: Xn.utils.mapRange(document.querySelector(".push.actif").getBoundingClientRect().left, document.querySelector(".push.actif").offsetWidth + document.querySelector(".push.actif").getBoundingClientRect().left, -8, 8, bx.x) + "deg",
            rotationX: Xn.utils.mapRange(document.querySelector(".push.actif").getBoundingClientRect().top, document.querySelector(".push.actif").offsetHeight + document.querySelector(".push.actif").getBoundingClientRect().top, 6, -6, bx.y) + "deg",
            ease: "none",
            duration: .2
        })
    }
    ,
    window.changementSlide = function(t, e, i, n) {
        i.classList.add("desc"),
        Xn.to(i, {
            y: t + "%",
            ease: "power2.in",
            duration: .4,
            onComplete: function(r) {
                i.setAttribute("data-nb", parseInt(i.getAttribute("data-nb")) - 1 * n),
                i.setAttribute("data-index", parseInt(i.getAttribute("data-index")) + n * document.querySelectorAll(".fiche").length),
                i.style.zIndex = i.getAttribute("data-index"),
                Xn.killTweensOf(i),
                Xn.set(i, {
                    z: -i.getAttribute("data-nb") * Sx * 20 + parseInt(i.getAttribute("data-z")) + parseInt(xx) + "px"
                }),
                i.classList.remove("desc"),
                120 === t ? i.classList.add("cache") : (i.classList.remove("cache"),
                Xn.fromTo(i, {
                    y: e + "%"
                }, {
                    y: 0,
                    ease: "power2.out",
                    duration: .4
                }))
            }
        });
        const r = document.querySelector(".liste .current");
        r.classList.remove("current");
        const s = document.querySelector(".fiche.current");
        s.classList.remove("current"),
        -1 == n ? null !== r.nextElementSibling ? (r.nextElementSibling.classList.add("current"),
        s.nextElementSibling.classList.add("current")) : (document.querySelectorAll(".liste button")[0].classList.add("current"),
        document.querySelectorAll(".fiche")[0].classList.add("current")) : null !== r.previousElementSibling ? (r.previousElementSibling.classList.add("current"),
        s.previousElementSibling.classList.add("current")) : (document.querySelectorAll(".liste button")[document.querySelectorAll(".liste button").length - 1].classList.add("current"),
        document.querySelectorAll(".fiche")[document.querySelectorAll(".fiche").length - 1].classList.add("current"))
    }
    ,
    window.remonter = function(t, e) {
        t.classList.remove("cache"),
        Xn.fromTo(t, {
            y: e + "%"
        }, {
            y: 0,
            ease: "power2.out",
            duration: .4
        })
    }
    ,
    window.descendre = function(t, e) {
        t.classList.add("encours"),
        Xn.to(t, {
            y: "10%",
            ease: "power2.in",
            duration: .4,
            onComplete: () => {
                t.classList.add("cache"),
                t.classList.remove("encours")
            }
        })
    }
    ,
    window.changementSlideSet = function(t, e) {
        t.classList.add("desc"),
        t.setAttribute("data-nb", parseInt(t.getAttribute("data-nb")) - 1 * e),
        t.setAttribute("data-index", parseInt(t.getAttribute("data-index")) + e * document.querySelectorAll(".fiche").length),
        t.style.zIndex = t.getAttribute("data-index"),
        Xn.killTweensOf(t),
        Xn.set(t, {
            z: -t.getAttribute("data-nb") * Sx * 20 + parseInt(t.getAttribute("data-z")) + parseInt(xx) + "px"
        }),
        t.classList.remove("desc");
        const i = document.querySelector(".liste .current");
        i.classList.remove("current");
        const n = document.querySelector(".fiche.current");
        n.classList.remove("current"),
        -1 == e ? null !== i.nextElementSibling ? (i.nextElementSibling.classList.add("current"),
        n.nextElementSibling.classList.add("current")) : (document.querySelectorAll(".liste button")[0].classList.add("current"),
        document.querySelectorAll(".fiche")[0].classList.add("current")) : null !== i.previousElementSibling ? (i.previousElementSibling.classList.add("current"),
        n.previousElementSibling.classList.add("current")) : (document.querySelectorAll(".liste button")[document.querySelectorAll(".liste button").length - 1].classList.add("current"),
        document.querySelectorAll(".fiche")[document.querySelectorAll(".fiche").length - 1].classList.add("current"))
    }
    ,
    document.addEventListener("keydown", (function(t) {
        const e = t.key;
        "ArrowDown" == e ? Ax(1) : "ArrowUp" == e && Ax(-1)
    }
    ))
}();
//# sourceMappingURL=app.js.map
